{"name":"sketch-fetch","version":"0.0.12","description":"Util library for sketch plugins handeling async HTTP requests","main":"lib/index.js","scripts":{"symlink-fix":"node ./scripts/symlink-fix.js","prepublish":"npm run symlink-fix"},"repository":"https://github.com/julianburr/sketch-fetch","keywords":["sketch","sketch-fetch","sketch-plugin","sketch-http","http-requests"],"license":"MIT","homepage":"https://github.com/julianburr/sketch-fetch#readme","dependencies":{"sketch-debugger":"git+https://github.com/julianburr/sketch-debugger.git"},"devDependencies":{"chalk":"^1.1.3","fs-extra":"^3.0.1","path":"^0.12.7"},"gitHead":"2e71742dfa8d25e987bca91463237dfe71473d12","versions":[{"number":"0.0.1","date":"2017-03-26T06:48:50.416Z"},{"number":"0.0.2","date":"2017-03-26T06:56:51.914Z"},{"number":"0.0.3","date":"2017-03-26T07:01:52.451Z"},{"number":"0.0.4","date":"2017-03-26T07:41:59.044Z"},{"number":"0.0.5","date":"2017-03-26T08:40:31.371Z"},{"number":"0.0.6","date":"2017-03-26T23:02:28.127Z"},{"number":"0.0.7","date":"2017-05-26T23:58:05.095Z"},{"number":"0.0.8","date":"2017-05-27T01:06:15.239Z"},{"number":"0.0.9","date":"2017-05-27T06:09:28.698Z"},{"number":"0.0.10","date":"2017-05-27T08:48:03.332Z"},{"number":"0.0.11","date":"2017-05-28T06:17:55.804Z"},{"number":"0.0.12","date":"2017-05-28T07:48:46.548Z"}],"readme":"# sketch-fetch\n\nUtil library for sketch plugins handling async HTTP requests\n\n**NOTE: This library is still very experimental, and ideally the API will completely change, so I don't recommend using it in production just yet unless you know what you are doing ðŸ˜‰**\n\n## The problem\n\nIn Sketch plugins we are not within a browser environment, so the usual AJAX libraries like [fetch](https://github.com/github/fetch) don't work. However, I really like the syntax and easy usage of such libraries, and I'd like to be able to make HTTP Requests in Sketch plugins (or any other cocoascript project really) just as easy as in the browser.\n\nThe problem is, that asynchronous requests run on different threads, and therefore we loose the current application context when we get the HTTP Response.\n\nI am working on ideas around that, not really successful as of now, so there is a current and an ideal solution to this problem.\n\n## Current usage\n\nUnder the hood this libtary is just an abstraction of `NSMutableURLRequest` that gets executed using `NSURLSession`'s method:\n\n```js\n[session dataTaskWithRequest:NSMutableURLRequest completionHandler:Block]\n```\n\nThe first currrent problem is that cocoascript doesn't allow you to define blocks (ObjC's equivalent to closures), so there is currently the need for an ObjC framework to be loaded to be able to use this library.\n\nAlso, due to the context issues described above, the workflow of asynchronous HTTP requests is not as intuitive as I hope it will be in the end just yet.\n\n### 1. Load the framework\n\nEither copy the framework files into your project or use the util function provided in your node build process, like so:\n\n```js\nvar fetch = require('sketch-fetch/lib/node');\nfetch.copyFrameworks(targetPath);\n```\n\nThen you have to load the framework before any of your requests, so to make sure this happens just include this snippet in your plugin in the beginning of every call of your `plugin.js` file:\n\n```js\nimport { FetchCore } from 'sketch-fetch';\n\nfunction initWithContext (context) {\n  FetchCore.initWithContext(context);\n  // Do your stuff...\n}\n\nfunction myAwesomePluginEndpoint (context) {\n  initWithContext(context);\n  // Do whatever your plugin should do...\n}\n```\n\nIt is good practise in general to have such an `initWithContext` method to be able to prepare your context for every initiation of a Sketch instance / new thread.\n\n### 2. Do your requests\n\nThis is as simple as this:\n\n```js\nimport fetch from 'sketch-fetch';\n\nconst options = { /* See available options */ };\nfetch('https://awesome.url', options);\n```\n\n### 3. Handle the response\n\nYou currently need to define a plugin entrypoint to be able to handle the responses. You can do that as follows:\n\n```js\nimport { handleResponses } from 'sketch-fetch';\n\nfunction handleHttpResponse (context) {\n  initWithContext(context);\n  handleResponses((callback, response) => {\n    switch (callback) {\n      case 'myCallback.ALWAYS':\n        // Do something...\n      break;\n      default:\n        log('ERROR: Callback unknown');\n      break;\n    }\n  });\n}\n```\n\nFor every key (in this case `myCallback`), there will be two responses fired, one for `[KEY].ALWAYS`, and the other one `[KEY].SUCCESS` or `[KEY].FAILURE`, depending on the response.\n\nThe entry point `handleHttpResponse` as of now has to be manually mapped into your `manifest.json`, `handleHttpResponse` being both handler and identifier.\n\n### Bringing it all together\n\n```js\nimport fetch, { FetchCore, handleResponses } from 'sketch-fetch';\n\nfunction initWithContext (context) {\n  FetchCore.initWithContext(context);\n  // Do your stuff...\n}\n\nfunction myAwesomePluginEndpoint (context) {\n  initWithContext(context);\n    \n  // Fetch data from url\n  const options = {\n    callback: 'myCallback',\n    // See available options...\n  };\n  fetch('https://awesome.url', options);\n}\n\nfunction handleHttpResponse (context) {\n  initWithContext(context);\n  handleResponses((callback, response) => {\n    switch (callback) {\n      case 'myCallback.SUCCESS':\n        // Do something...\n      break;\n      default:\n        log('ERROR: Callback unknown');\n      break;\n    }\n  });\n}\n```\n\n### Available options\n\n```js\n{\n  callback: 'something', // string, identifier for the response handling\n  headers: {}, // object, key value pairs for the request header\n  args: {}, // object, key value pairs for normal string parameters\n  files: { // object, file paths to be sent (for any request type but GET)\n    varName: 'filepath'\n  },\n  method: 'GET', //string, GET|POST|PUT|DELETE|..., default is GET\n}\n```\n\n## The ideal world\n\nThis is all still not ideal. In a perfect world, we could handle requests just like we can with fetch in a browser environment, like so:\n\n```js\nimport fetch from 'sketch-fetch';\n\nfetch(url, options)\n  .then(json => {\n    // Do something\n  })\n  .catch(() => {\n    // Handle any errors\n  })\n  .send(); // we would need that, cause we need to define the callbacks before we actually send the request...\n```\n\nThe only problem with this is that we loose the current context. We could save (a serialized version of) the callbacks on the main thread and retrieve these on response, but we would need to make sure that all contexts will be saved and retrieved as well, such as already imported helper functions or other external libraries...\n\nI am currently working on some ideas for that and will update this repo when I find something worth sharing ðŸ˜Š","created":"2017-03-26T06:48:50.416Z","modified":"2017-05-28T07:48:46.548Z","lastPublisher":{"name":"julianburr","email":"hello@julianburr.de"},"owners":[{"name":"julianburr","email":"hello@julianburr.de"}],"other":{"_attachments":{},"_from":".","_id":"sketch-fetch","_nodeVersion":"7.2.0","_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/sketch-fetch-0.0.12.tgz_1495957726409_0.35524301463738084"},"_npmUser":{"name":"julianburr","email":"hello@julianburr.de"},"_npmVersion":"3.10.9","_rev":"12-61b52b4d89016f81a6c86a9259572dc0","_shasum":"9964bed7f571545571802d69d9f203387b7e4c92","author":{"name":"Julian Burr","email":"hello@julianburr.de"},"bugs":{"url":"https://github.com/julianburr/sketch-fetch/issues"},"directories":{},"dist-tags":{"latest":"0.0.12"},"dist":{"shasum":"9964bed7f571545571802d69d9f203387b7e4c92","tarball":"https://registry.npmjs.org/sketch-fetch/-/sketch-fetch-0.0.12.tgz"},"maintainers":[{"name":"julianburr","email":"hello@julianburr.de"}],"readmeFilename":"README.md","time":{"modified":"2017-05-28T07:48:46.548Z","created":"2017-03-26T06:48:50.416Z","0.0.1":"2017-03-26T06:48:50.416Z","0.0.2":"2017-03-26T06:56:51.914Z","0.0.3":"2017-03-26T07:01:52.451Z","0.0.4":"2017-03-26T07:41:59.044Z","0.0.5":"2017-03-26T08:40:31.371Z","0.0.6":"2017-03-26T23:02:28.127Z","0.0.7":"2017-05-26T23:58:05.095Z","0.0.8":"2017-05-27T01:06:15.239Z","0.0.9":"2017-05-27T06:09:28.698Z","0.0.10":"2017-05-27T08:48:03.332Z","0.0.11":"2017-05-28T06:17:55.804Z","0.0.12":"2017-05-28T07:48:46.548Z"}}}