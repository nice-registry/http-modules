{"name":"httppromise","version":"2.0.1","description":"A concise, promise-based HTTP Request library for your browser.","main":"dist/httppromise.js","scripts":{"test":"testem"},"repository":"https://github.com/burlesona/httppromise","keywords":["http","ajax","promise"],"license":"MIT","homepage":"https://github.com/burlesona/httppromise","gitHead":"cd0a329bc000a55ae59f4b25a3b923d1e112d1e7","versions":[{"number":"1.1.0","date":"2015-11-10T21:05:53.045Z"},{"number":"1.1.1","date":"2015-11-11T15:24:04.556Z"},{"number":"2.0.0","date":"2016-05-26T19:19:39.443Z"},{"number":"2.0.1","date":"2016-05-27T14:21:16.815Z"}],"readme":"# HttpPromise\n\n*Version 2.0* (see changelog below)\n\nA concise, Promise-based HTTP Request (aka AJAX) library\nfor your browser.\n\nPromises are great except when your browser doesn't support them.\nThankfully, this can be fixed with a [polyfill](https://www.promisejs.org/)\nlike this one:\n\n[https://www.promisejs.org/polyfills/promise-7.0.1.js](https://www.promisejs.org/polyfills/promise-7.0.1.js)\n\nI made this for fun, and I really like it. I've been using it in production for several years,\nand it's been great. I keep it working nicely because I need it all the time, and if you\nuse this and run into an issue I'll do my best to help you out.\n\n\n## Note on 2.0\n\nThis used to be called `HTTPromise`, which is *much* better. But NPM.\n\nSo, now it's called `HttpPromise` because nobody had taken that spelling.\nBastards.\n\nAnyway, renaming the core class is obviously a breaking change, so I\nwent ahead and made some more NPM naming friendly changes for this 2.0\nrelease. The core features are identical, the only thing that changed is\nhow you set custom request formats. See examples below.\n\n## Quick-Start\n\nMake requests like this:\n\n```\n// You can pass a type option. Default types are 'json' and 'formData'\n// 'json' is the default, therefore you don't have to pass anything.\nvar http = new HTTPromise({type: 'json'});\nvar http = new HTTPromise; // same thing.\n\n// Call an HTTP method and pass a URL!\nhttp.get('/whatever');\n\n// Woah, that was easy. What about URL params?\nhttp.get('/whatever',{query: \"how awesome is this?\"});\n\n// Neato, but where do I put my callback?\nrequest = http.get('/whatever');\nrequest.then(function(data,xhr){\n  console.log(\"This is the best data:\",data);\n});\n\n// O snap! Can I just chain that stuff?\nvar pass = function(data,xhr) { alert(\"FOR GREAT JUSTICE!\"); };\nvar fail = function(xhr) { alert(\"TAKE UP EVERY ZIG!\"); };\nhttp.get('/whatever').then(pass).error(fail);\n\n// Hey wait a minute, I need to post stuff!\nhttp.post('/whatever',{any:\"data\",goes:\"here\"});\n\n// Ok so, I'm talking to this nice API that uses meaningful\n// http status codes like ---\nhttp.get('/whatever')\n  .when(200, function(data,xhr) { console.log(\"Got me some data!\"); })\n  .when(204, function() { console.log(\"No data here :(\"); });\n\n// ZOMG! WHAT?\nconfirm(\"Yes it's amazing, can we proceed?\");\n\n// OKOK so, what all methods do I get?\nhttp.get(url,params)\nhttp.post(url,data)\nhttp.put(url,data)\nhttp.patch(url,data)\nhttp.delete(url,data) // I guess you can send data with a delete request?\nhttp.request(method,url,data) // If you gotta be l33t\n\n// NICE! and what methods are on the response object?\nresponse = http.get('/whatever')\nresponse.then() // always happens\nresponse.success() // 200 status codes\nresponse.error() // non-200 status codes, timeouts, and such\nresponse.when(status,callback) // whatever status code you want\n\n// for reals how have I lived without this my whole life?\nhttp.takesBow()\n\n// ^ lol that's not a real function don't try calling it.\n```\n\n## With NPM / Browserify etc.\n\nIf you're using NPM + Browserify, cheers, me too. If you're using one of the million\nother flavors of JS package management... well, good for you. I wish we could all\njust agree on how to do this thing, right?\n\nIn any case, via Browserify it works like this:\n\n```\nvar HttpPromise = require('httppromise')\n```\n\nDone.\n\n## Built-In Types\n\nHTTPromise knows about two kinds of requests by default: JSON and FormData.\nIf you don't specify a type, JSON is the default. You can make FormData requests\nlike so:\n\n```\nvar http = new HTTPromise({type: 'formData'});\nvar form = document.getElementById('my-form');\nhttp.post('/formdata',form).then(function(data,xhr){console.log(data,xhr)});\n```\n\nThe form data is generated from the second argument. You can pass a form element\nor a selector string. Note that if you input a selector it will be passed to\n`document.querySelector`, therefore only the first match will be passed on to\n`FormData`. Use a unique selector, IDs are recommended.\n\nExample HTML\n\n```html\n<form id=\"my-form\">\n  <input name=\"test\" type=\"text\" value=\"foo\">\n</form>\n```\n\nExample JS\n\n```js\nvar http = new HTTPromise({type: 'formData'});\nhttp.post('/formdata','#my-form').then(function(data,xhr){console.log(data,xhr)});\n```\n\n## Custom Request Formats\n\nI'm keen on moving past old browsers, and not fond of XML. But if you want to tackle\nthose beasts, you could easily add a new format aimed at them.\n\nTo do this, you need to add a format to HTTPromise.\nA \"format\" needs properties: `headers`, `encode`, and `parse`.\n\nIn the minimum case these can be no-ops. For instance:\n\n```\nHTTPromise.setFormat('noop',{\n  headers: {},\n  encode: function(data) { return data; }\n  parse: function(xhr) { return xhr; }\n});\n```\n\nIn this case:\n\n1. There will be no headers on the request.\n\n2. Whatever you pass in as data will be be passed directly to the `XMLHttpRequest` instance's `send` method.\n\n3. The xhr response object will be returned to your promises as-is.\n\nThis all happens in the HTTPromise Request object's constructor, and is pretty straightforward,\nso please just check the source code to see the default types and what all happens under the hood,\nthen feel free to extend this however you like.\n\n## Per-Instance Headers\n\nIn addition to the `type` option, you can also pass a `headers` option to the HTTPromise constructor.\nFor example:\n\n```js\nvar http = new HTTPromise({type:'json',headers:{'X-Client-ID':'cl_6251523'}})\n```\n\nIf you pass the `headers` option it must be an object where they keys and values represent headers.\n\nThese headers will be added to the default headers for the request format you're using.\n\n## About the X-HTTP-Requested-With Header\n\nThe [X-HTTP-Requested-With](https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#Common_non-standard_request_fields)\nheader is non-standard but used by jQuery and therefore ubiquitous. This means a lot of server-side libraries\nand frameworks, such as Ruby's Rack framework, provide convenience methods for checking this header,\nand a lot of code relies on these convenience methods to determine if a request is \"ajax\" or not.\n\nSince this header is not standard, the browsers don't set it, and neither does HTTPromise. But that means\nthat if you are, for example, using a ruby rack-based webserver and you write a method like this:\n\n```ruby\nif request.xhr?\n  # send some json\nelse\n  # send some html\n```\n\n... then HTTPromise is going to get the HTML by default, which may surprise you.\n\nYou have two choices here:\n\n1. Check for the request \"Accept\" header instead. Since your JSON requests should\n   not accept HTML, your server should not send HTML. This is the standards-compliant\n   way to go, and it's what I do.\n\n2. Add the `X-HTTP-Requested-With` header to your requests. This will make your\n   requests look more like they come from jQuery, which will make more server frameworks\n   recognize them as ajax \"automatically.\" Personally, I think this is not as good\n   of a solution, but it is probably an easier \"hack\" for many systems.\n\nIf you want to add this header to all requests from a particular HTTPromise instance,\njust pass it into the constructor:\n\n```js\nvar http = new HTTPromise({type:'json',headers:{'X-HTTP-Requested-With':'XMLHttpRequest'})\n```\n\n\n\n## Development / Testing\n\nThe docs are in JS and the distribution is as well.\nI wrote this library in CoffeeScript, which I personally like better.\nYou'll need [TestEm](https://github.com/airportyh/testem) installed\nto build/run the project, because using the test runner as a sort of\nbuild-tool has the nice side effect of making it a lot harder to skip\nwriting tests. You'll also want to run the little sinatra app that's\nattached so you have something to send test requests too. I might redo\nthat in Node later, but who knows...\n\n## Compatibility\n\nWith the Promise Polyfill, this has been tested and works all the\nreal browsers, plus Internet Explorer >= 9.0.\n\nThis is the polyfill I use in my production environments:\n```\n<script src=\"https://www.promisejs.org/polyfills/promise-7.0.1.min.js\"></script>\n```\n\n## License\n\nHTTP Promise is distributed under the MIT License.\nCopyright (c) 2014-2015 Andrew Burleson.\n\nPS, if you do something neat with it, I'd love to know. You can open an issue\non this repo to tell me about it, and I might even feature your project on\nthe readme :)\n\n## Changelog\n*Version 2.0.1 (May 27, 2016)*\n- Fix a stupid typo that made Browserify require global\n\n*Version 2.0.0 (May 26, 2016)*\n- Goodbye HTTPromise, hello HttpPromise. Because names.\n- Goodybe HTTPromiseRequestFormat, hello HttpPromise.setFormat()\n- Per semver standards, this is a potentially breaking change for old code\n  so I'm bumping to 2.0.0\n- I've added a minify step on the testem build. This is a super non-traditional\n  way of building a distro but it makes me run the tests always for every build\n  in a very noisy way, which I adore. So, there's that.\n\n*Version 1.1.1 (November 11, 2015)*\n- Merge PR from Travis Nesland to fix issue of HTTPromiseRequestFormat not being found when lib is loaded through NPM.\n- Update dist and package.json\n\n*Version 1.1 (August 13, 2015)*\n- Add config option to set request headers per instance\n- Update development dependencies\n\n*Version 1.0 (May 11, 2015)*\n- Start Versioning\n- Change error response to deliver consistent two argument return rather than a single object payload.\n\n*Version 0.x Part 2*\n- Add FormData request type\n\n*Version 0.x* (August 2014 - Feb 2014)\n- Write this\n- Test it\n- Use it in production\n- Love it\n- High-fives all around\n","created":"2015-11-10T21:05:53.045Z","modified":"2016-05-27T14:21:16.815Z","lastPublisher":{"name":"burlesona","email":"burlesona+npm@gmail.com"},"owners":[{"name":"burlesona","email":"burlesona+npm@gmail.com"}],"other":{"_attachments":{},"_from":".","_id":"httppromise","_nodeVersion":"5.6.0","_npmOperationalInternal":{"host":"packages-16-east.internal.npmjs.com","tmp":"tmp/httppromise-2.0.1.tgz_1464358874647_0.4122568385209888"},"_npmUser":{"name":"burlesona","email":"burlesona+npm@gmail.com"},"_npmVersion":"3.6.0","_rev":"1-09ff13f2e81fd040ca8c2182b2c1413f","_shasum":"ab1806b068d3648db9797208ca34193a1f32eb93","author":{"name":"Andrew Burleson"},"bugs":{"url":"https://github.com/burlesona/httppromise/issues"},"directories":{"test":"test"},"dist-tags":{"latest":"2.0.1"},"dist":{"shasum":"ab1806b068d3648db9797208ca34193a1f32eb93","tarball":"http://registry.npmjs.org/httppromise/-/httppromise-2.0.1.tgz"},"maintainers":[{"name":"burlesona","email":"burlesona+npm@gmail.com"}],"readmeFilename":"Readme.md","time":{"modified":"2016-05-27T14:21:16.815Z","created":"2015-11-10T21:05:53.045Z","1.1.0":"2015-11-10T21:05:53.045Z","1.1.1":"2015-11-11T15:24:04.556Z","2.0.0":"2016-05-26T19:19:39.443Z","2.0.1":"2016-05-27T14:21:16.815Z"}}}