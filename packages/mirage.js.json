{"name":"mirage.js","version":"1.0.0","description":"A fake HTTP server for modern web development","main":"dist/mirage.js","scripts":{"test":"karma start karma.conf.js","test:local":"karma start karma.conf.js --local","build":"webpack --config webpack.config.js -p","build:dev":"webpack --config webpack.config.js"},"keywords":["fakes","mocks"],"license":"MIT","dependencies":{"chance":"^1.0.4","lodash":"^4.17.4","pretender":"^1.4.2","slash":"^1.0.0"},"devDependencies":{"axios":"^0.15.3","babel-core":"^6.22.1","babel-eslint":"^7.1.1","babel-loader":"^6.2.10","babel-plugin-lodash":"^3.2.11","babel-preset-latest":"^6.22.0","chai":"^3.5.0","cz-conventional-changelog":"^1.2.0","eslint":"^3.14.1","eslint-config-standard":"^6.2.1","eslint-loader":"^1.6.1","eslint-plugin-promise":"^3.4.0","eslint-plugin-standard":"^2.0.1","karma":"^1.4.1","karma-chrome-launcher":"^2.0.0","karma-mocha":"^1.3.0","karma-webpack":"^2.0.2","mocha":"^3.2.0","webpack":"^2.2.1"},"config":{"commitizen":{"path":"./node_modules/cz-conventional-changelog"}},"gitHead":"08cbb26da607d61c881feb1d909fcb1dad4fa534","versions":[{"number":"1.0.0","date":"2017-02-01T13:23:34.866Z"}],"readme":"# Mirage\n\nMirage is HTTP mocking library for modern era development. It is quite similar to [Ember Mirage](http://www.ember-cli-mirage.com/) but less opinionated, since is does not targets any library or framework.\n\n---\n\n> Mirage plays well with any framework of your choice. Whether it is **VueJs**, **React** or **Riot**.\n\n## Features\n\nUnder the hood it supports.\n\n1. Routing.\n2. Database factories and fakes.\n3. Database fixtures.\n\n\n## But Why?\n\nTesting HTTP/Ajax requests are hard, since they will hit the real server and slow down your tests. Not only the speed is the issue, when running your tests inside CI (travis, etc), you need to make sure that your API server is reachable, otherwise your tests will fail.\n\nTo overcome these issues, everyone tries following ways:\n\n1. Mock HTTP requests using Sinon or similar.\n2. Make use of a local HTTP server bundled within the frontend app.\n\nBoth of the above are hard to setup and maintain in long run. Testing needs to be simple\n\n## How it works?\n\nMirage starts simply by intercepting all Ajax requests made by your Ajax library and returns a mocked response. Which means, you won't have to touch a single line of code inside your tests or actual code when testing AJAX requests.\n\n### Directory Structure\n\n```\n|-- mirage\n|---- config.js\n|---- blueprints/\n|---- fixtures/\n```\n\n\n### Hardcoded response\n\nYou are free to skip the blueprints or fixtures and keep your mirage logic simple by returning hardcoded response from your routes.\n\n```js\nexport default (app) {\n  app.get('/users', () => {\n    const status = 200\n    const headers = {}\n    const body = body: [{\n      username: 'virk',\n      age: 27\n    }]\n\n    return [status, headers, body]\n  })\n}\n```\n\n### Using Factories and Fakes\n\nDatabase factories makes it simple to have logic around your mocked server. Returning a list of hardcoded users may be fine for a single scanerio. But think of situations, where you want to perform CRUD operations by showing a list of all the users and then deleting one and making sure new list does not return the deleted user.\n\n**blueprints/users.js**\n```js\nexport default (faker, i) {\n  return {\n    id: i + 1,\n    username: faker.username(),\n    password: faker.password()\n  }\n}\n```\n\n```js\n// fetching a single user\napp.get('/users/:id', (request, db) => {\n  const userId = request.input('id')\n  const user = db.get('users').findBy('id', userId)\n  return [200, {}, user]\n})\n\n// removing user\napp.delete('/users/:id', (request, db) => {\n  const userId = request.input('id')\n  db.get('users').lazyFilter((user) => user.id === userId).remove()\n  return [200, {}, {deleted: true}]\n})\n\n// updating user\napp.put('/users/:id', (request, db) => {\n  const userId = request.input('id')\n  \n  db\n    .get('users')\n    .lazyFilter((user) => user.id === userId)\n    .update({admin: true})\n  \n  return [200, {}, {updated: true}]\n})\n```\n\n\n### Clearing DB State\n\nDatabase has a persistent memory store. Which means changes made to the db while running your tests are persistent. It is a good practice to work with a clean state for each test.\n\n```js\nimport { db } from 'mirage'\n\nbeforeEach(() => {\n  db.clear()\n})\n```\n\n### Fixtures\n\nFixtures are used to seed your database to have your world setup. For example, you want to test your application with some default state. It is quite common to have fixtures for **Settings API** or **Locale Strings** etc.\n\nAll fixtures are defined inside `mirage/fixutres` library and they can accessed by the DB instance.\n\n```js\nimport { db } from 'mirage'\ndb.loadFixtures(['locales', 'settings'])\n```\n\n","created":"2017-02-01T13:23:34.866Z","modified":"2017-02-01T13:23:34.866Z","lastPublisher":{"name":"amanvirk","email":"virk.officials@gmail.com"},"owners":[{"name":"amanvirk","email":"virk.officials@gmail.com"}],"other":{"_attachments":{},"_from":".","_id":"mirage.js","_nodeVersion":"7.2.0","_npmOperationalInternal":{"host":"packages-18-east.internal.npmjs.com","tmp":"tmp/mirage.js-1.0.0.tgz_1485955414233_0.6108601486776024"},"_npmUser":{"name":"amanvirk","email":"virk.officials@gmail.com"},"_npmVersion":"3.10.9","_rev":"1-0503be636f20f20925ddcbeb8f9d643d","_shasum":"e6210a31859f7fa79913b2cf49ea0e879958edc3","author":{"name":"amanvirk"},"directories":{"test":"test"},"dist-tags":{"latest":"1.0.0"},"dist":{"shasum":"e6210a31859f7fa79913b2cf49ea0e879958edc3","tarball":"https://registry.npmjs.org/mirage.js/-/mirage.js-1.0.0.tgz"},"maintainers":[{"name":"amanvirk","email":"virk.officials@gmail.com"}],"readmeFilename":"README.md","time":{"modified":"2017-02-01T13:23:34.866Z","created":"2017-02-01T13:23:34.866Z","1.0.0":"2017-02-01T13:23:34.866Z"}}}