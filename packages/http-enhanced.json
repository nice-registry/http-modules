{"name":"http-enhanced","version":"0.5.3","main":"index.js","description":"Drop-in replacement for Node.js standard `http` API with various helpers.","keywords":["http","enhanced","maximal","helpers","streaming","nodeps"],"homepage":"http://github.com/chbrown/http-enhanced","license":"MIT","repository":"https://github.com/chbrown/http-enhanced","devDependencies":{"request":"*","tap":"*"},"scripts":{"test":"tap test"},"gitHead":"51a448fc7b4ce598ff5c4e30a5487fcc2c11d57b","versions":[{"number":"0.2.1","date":"2013-05-20T18:38:26.767Z"},{"number":"0.2.2","date":"2013-05-21T07:54:01.767Z"},{"number":"0.2.3","date":"2013-05-27T19:49:22.290Z"},{"number":"0.3.0","date":"2013-06-13T16:55:10.175Z"},{"number":"0.3.1","date":"2013-10-08T04:51:07.457Z"},{"number":"0.4.0","date":"2014-03-11T17:12:41.556Z"},{"number":"0.4.1","date":"2014-03-29T16:52:44.693Z"},{"number":"0.4.2","date":"2014-03-29T18:22:14.965Z"},{"number":"0.5.0","date":"2014-04-02T05:41:50.911Z"},{"number":"0.5.1","date":"2014-10-14T20:41:10.475Z"},{"number":"0.5.2","date":"2014-12-03T04:50:31.327Z"},{"number":"0.5.3","date":"2014-12-16T01:40:22.103Z"}],"readme":"# http-enhanced\n\nMy [wrappers](https://github.com/chbrown/wrappers) library was a bit over the top.\n\nThis is meant to be thinner, just a few helpers for the very simple `req` /\n`res` that Node.js's [`http`](http://nodejs.org/api/http.html) API provides.\n\nIf you don't call any of the methods, nothing changes. You'll just have\nsome extra prototype methods lying around that never did anything.\n\n\n## Install\n\nAt the command line from the [npm](https://npmjs.org/) registry:\n\n    npm install http-enhanced\n\nOr from github:\n\n    npm install git://github.com/chbrown/http-enhanced.git\n\nOr in your `package.json`:\n\n    \"dependencies\" : {\n      \"http-enhanced\": \"*\",\n      ...\n    }\n\n\n## Usage\n\nMost often, you'll [create a server](http://nodejs.org/api/http.html#http_event_request)\nlike this:\n\n    var http = require('http');\n    http.createServer(function (req, res) {\n\n      // req (request) is an instance of http.IncomingMessage\n      var url = req.url;\n\n      // res (response) is an instance of http.ServerResponse\n      res.writeHead(200, {'Content-Type': 'text/html'});\n      res.write('Hello, world!');\n      res.end();\n\n    }).listen(80);\n\nA simple change will let you use some shortcuts:\n\n    var http = require('http-enhanced');\n    http.createServer(function (req, res) {\n\n      // save incoming data to req.data and wait until the request ends,\n      //   or callback immediately (setImmediate) if it already has\n      req.readToEnd('utf8', function(err, data) {\n        var reversed = data.split('').reverse().join('');\n\n        // 1. set HTTP status code to 200,\n        // 2. the Content-Type header to 'application/json',\n        // 3. and stringify the given object, all in one go:\n        res.json({success: true, message: reversed});\n      });\n\n    }).listen(80);\n\n\n## Request\n\n### request.readToEnd([encoding], [callback])\n\n* `encoding` String | null If specified, callback gets a String instead of a Buffer.\n* `callback` Function | null Call some `function(err, data)` when the request ends.\n    * If only one argument is given, it must be the callback.\n\nRead the request into a buffer until the `end` event is triggered, which will\ntrigger `callback(Error || null, Buffer || null)`. This uses \"new-style\"\nstreams, listening for `readable` events and calling `read()`, coercing to a\nBuffer when needed.\n\nThis function can be called multiple times, with or without the callback.\n\nA popular use case might be if you want to upload a file and do a lot of I/O\nindependently but at the same time. You might call `req.readToEnd()` with no\narguments at the beginning of your request handler, and _then_ set off your\nexpensive I/O calls.\n\nYou can get back a **string** if you specify the encoding, e.g.,\n`req.readToEnd('utf8', function(err, string) { ... })`. This is exactly\nequivalent to calling:\n\n    req.readToEnd(function(err, buffer) {\n      var string = buffer.toString(encoding);\n      ...\n    });\n\nIf the request has already ended, any captured buffer will be immediately\nreturned, via `setImmediate` (which replaced `process.nextTick` in node v0.10).\nThis might occur if you start listening for `data` at some point, in which\ncase the request is flipped to \"old-style\" streams, and `end` might occur\nbefore you listen for it.\n\nFor that reason, and that calling `req.read()` from multiple listeners could\nproduce problems, you should not use either of these:\n\n    req.setEncoding('utf8'); // no!\n    req.on('data', function(chunk) { ... }); // robot, NO!\n\nSo you shouldn't call `req.readToEnd()` (without a callback) in your pipeline\nunless you're going to call it again with a callback, later.\n\n### request.readData(callback)\n\nWraps `req.readToEnd()` and uses the request's `Content-Type` header to determine whether to parse the request as JSON or a form querystring.\n\n    callback = function(error, data) { ... }\n\n- `application/json`: Returns result of `JSON.parse`. Interprets empty `application/json` requests as `null`, instead of throwing an Error, since `JSON.parse('')` will raise a SyntaxError normally. If `JSON.parse(body)` throws an error due to invalid JSON, calls back with the error.\n- `application/x-www-form-urlencoded`: Returns result of `querystring.parse`.\n- otherwise, returns the same thing as `readToEnd`, a Buffer.\n\nDoes not work for uploads (use something like [formidable](https://github.com/felixge/node-formidable)).\n\nReturns the parsed querystring for GET requests.\n\n\n## Response\n\n### response.writeEnd(data)\n\n* `data` String String to write to response\n\nThe standard `http` built-in `response.end(data)` is supposed to write the\ndata and then end the response. From the docs:\n\n> If data is specified, it is equivalent to calling\n> `request.write(data, encoding)` followed by `request.end()`.\n\nBut sometimes it doesn't, and `writeEnd` makes sure that's what it really does\n(minus the optional encoding).\n\n    res.writeEnd('Hello world');\n\n### response.writeAll(statusCode, contentType, data)\n\n* `statusCode` Number Three-digit HTTP status code\n* `contentType` String MIME type\n* `data` String String to write to response\n\nRoll `writeHead(statusCode, contentType)` and `writeEnd(data)` all into one:\n\n    res.writeAll(200, 'text/xml', '<root>Haha, not really.</root>');\n\n### response.json(object)\n\n* `object` Object JSON-stringifiable object\n\nWrite response to end with `Content-Type: application/json` and HTTP status\ncode 200, encoding the object with `JSON.stringify`.\n\n    res.json({success: true, message: \"Hello world!\"});\n\nIf `JSON.stringify` throws an error trying to encode your object (e.g., if it\nhas circular references), it will fall back to `util.inspect` with the options:\n`{showHidden: true, depth: null}`.\n\n### response.html(data)\n\n* `data` String HTML to write to response.\n\nSet status code to 200 and `Content-Type` to `text/html`.\n\n    res.html('<p><i>Hello</i> world!.</p>');\n\n### response.text(data)\n\n* `data` String Plain text to write to response.\n\nSet status code to 200 and `Content-Type` to `text/plain`.\n\n    res.text('Hello world.');\n\n### response.die([error])\n\n* `error` String | Error Will call `error.toString()`.\n\nSet status code to 500 (if it's currently 200) and `Content-Type` to\n`text/plain`, using the string representation of the given error, prepended\nwith the label \"Failure: \", as the response body (or just \"Failure\" if no\nerror is provided). If you want to use a 4xx or 5xx status code other than\n500, call, e.g., `.status(418)` before calling `.die()`.\n\n    res.die('Goodbye, cruel world.');\n\n### response.redirect(location)\n\n* `location` String (a URL)\n\nSet status code to given status code (302 by default) and the `Location`\nheader to the given string. Also writes the text,\n\"Redirecting to: /index?error=404\" (or whatever url you use).\n\n    res.redirect('/index?error=404');\n\nTo use a different 3xx status code, set it before calling redirect.\n\n    res.status(303).redirect('/login');\n\n## License\n\nCopyright © 2013–2014 Christopher Brown. [MIT Licensed](LICENSE).\n","starsCount":0,"created":"2013-05-20T18:38:26.450Z","modified":"2014-12-16T01:40:22.103Z","lastPublisher":{"name":"chbrown","email":"io@henrian.com"},"owners":[{"name":"chbrown","email":"io@henrian.com"}],"other":{"_attachments":{},"_from":".","_id":"http-enhanced","_nodeVersion":"0.10.33","_npmUser":{"name":"chbrown","email":"io@henrian.com"},"_npmVersion":"2.1.10","_rev":"1-5371cf9d84dfbddffe41293694d004ec","_shasum":"44edc1b3c270fefabf9641a7313c0c0b7bc27c55","author":{"name":"Christopher Brown","email":"io@henrian.com","url":"http://henrian.com"},"bugs":{"url":"http://github.com/chbrown/http-enhanced/issues"},"directories":{},"dist-tags":{"latest":"0.5.3"},"dist":{"shasum":"44edc1b3c270fefabf9641a7313c0c0b7bc27c55","tarball":"http://registry.npmjs.org/http-enhanced/-/http-enhanced-0.5.3.tgz"},"maintainers":[{"name":"chbrown","email":"io@henrian.com"}],"readmeFilename":"README.md","time":{"modified":"2014-12-16T01:40:22.103Z","created":"2013-05-20T18:38:26.450Z","0.2.1":"2013-05-20T18:38:26.767Z","0.2.2":"2013-05-21T07:54:01.767Z","0.2.3":"2013-05-27T19:49:22.290Z","0.3.0":"2013-06-13T16:55:10.175Z","0.3.1":"2013-10-08T04:51:07.457Z","0.4.0":"2014-03-11T17:12:41.556Z","0.4.1":"2014-03-29T16:52:44.693Z","0.4.2":"2014-03-29T18:22:14.965Z","0.5.0":"2014-04-02T05:41:50.911Z","0.5.1":"2014-10-14T20:41:10.475Z","0.5.2":"2014-12-03T04:50:31.327Z","0.5.3":"2014-12-16T01:40:22.103Z"},"users":{}}}