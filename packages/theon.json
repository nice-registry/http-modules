{"name":"theon","version":"0.1.28","description":"A library to build domain-specific, extensible and expressive HTTP API clients in node.js and browsers","repository":"https://github.com/h2non/theon","license":"MIT","main":"./lib/theon","engines":{"node":">= 0.10"},"scripts":{"test":"standard 'lib/**/*.js' 'test/**/*.js' && mocha --bail --timeout 3000 --reporter spec --ui tdd 'test/**/*.js'","browserify":"browserify --exports require --standalone theon --ignore request --ignore ./node --entry ./lib/theon.js > ./theon.js","uglify":"uglifyjs theon.js --mangle --preamble \"/*! theon v${VERSION} - MIT license - https://github.com/h2non/theon */\" --source-map theon.min.js.map --source-map-url http://cdn.rawgit.com/h2non/theon.js/${VERSION}/theon.min.js.map > theon.min.js","browser":"npm run browserify && npm run uglify","size":"wc -c theon.min.js","gzip":"gzip -c theon.min.js | wc -c","loc":"wc -l theon.js","stats":"npm run loc && npm run size && npm run gzip"},"keywords":["http","client","rest","restful","api","builder","composer","factory","dls","domain","specific","language","context","middleware","sdk"],"dependencies":{"lil-http":"^0.1.16","midware-pool":"^0.1.1","path-params":"^0.1.0","request":"^2.64.0"},"devDependencies":{"browserify":"^11.2.0","chai":"^3.0.0","mocha":"^2.2.5","nock":"^2.13.0","sinon":"^1.17.1","standard":"^5.4.1","supertest":"^1.0.1","uglify-js":"^2.4.24"},"standard":{"globals":["suite","test","beforeEach","before"]},"gitHead":"bc985b529ae322d893943611040abfb6b4f8c23b","homepage":"https://github.com/h2non/theon#readme","versions":[{"number":"0.1.0-beta.0","date":"2015-10-08T14:10:14.111Z"},{"number":"0.1.0-beta.1","date":"2015-10-13T22:00:36.148Z"},{"number":"0.1.0","date":"2015-10-18T13:31:02.395Z"},{"number":"0.1.1","date":"2015-10-18T22:35:59.207Z"},{"number":"0.1.2","date":"2015-10-19T22:31:02.138Z"},{"number":"0.1.3","date":"2015-10-21T17:09:40.086Z"},{"number":"0.1.4","date":"2015-10-23T17:40:25.217Z"},{"number":"0.1.5","date":"2015-10-26T12:27:03.780Z"},{"number":"0.1.6","date":"2015-10-29T14:05:44.214Z"},{"number":"0.1.7","date":"2015-12-08T00:31:56.844Z"},{"number":"0.1.8","date":"2015-12-09T19:49:21.170Z"},{"number":"0.1.9","date":"2015-12-09T22:20:50.926Z"},{"number":"0.1.10","date":"2015-12-10T00:25:46.489Z"},{"number":"0.1.11","date":"2015-12-10T00:33:02.591Z"},{"number":"0.1.12","date":"2015-12-11T13:46:57.388Z"},{"number":"0.1.13","date":"2015-12-12T00:48:37.793Z"},{"number":"0.1.14","date":"2015-12-12T16:27:54.916Z"},{"number":"0.1.15","date":"2015-12-12T18:33:12.058Z"},{"number":"0.1.16","date":"2015-12-14T10:33:00.288Z"},{"number":"0.1.17","date":"2015-12-14T17:08:33.154Z"},{"number":"0.1.18","date":"2015-12-15T21:43:31.434Z"},{"number":"0.1.19","date":"2015-12-21T09:57:42.056Z"},{"number":"0.1.20","date":"2015-12-28T20:04:59.736Z"},{"number":"0.1.21","date":"2015-12-30T13:22:14.474Z"},{"number":"0.1.22","date":"2015-12-30T13:49:09.967Z"},{"number":"0.1.23","date":"2015-12-30T14:31:49.941Z"},{"number":"0.1.24","date":"2016-01-01T12:04:08.570Z"},{"number":"0.1.25","date":"2016-01-01T20:13:04.546Z"},{"number":"0.1.26","date":"2016-01-04T15:47:31.678Z"},{"number":"0.1.27","date":"2016-02-01T12:50:48.603Z"},{"number":"0.1.28","date":"2016-02-09T11:32:24.592Z"}],"readme":"# theon [![Build Status](https://api.travis-ci.org/h2non/theon.svg?branch=master&style=flat)][travis] [![Codacy Badge](https://api.codacy.com/project/badge/grade/a612f7996c864d47915a0d268d7e720a)](https://www.codacy.com/app/tomas/theon) [![NPM](https://img.shields.io/npm/v/theon.svg)](https://www.npmjs.org/package/theon) [![js-standard-style](https://img.shields.io/badge/code%20style-standard-brightgreen.svg)](http://standardjs.com) [![jsdoc-reference](https://img.shields.io/badge/jsdoc-reference-blue.svg)](http://jsdocs.herokuapp.com/github.com/h2non/theon)\n\n> Because writting API clients should be fast and elegant. Because using API clients should be simple and fun.\n\ntheon is a dependency-free, [featured](#features), [pluggable](#middleware) and [declarative](#tutorial) JavaScript library to design and create domain-specific and fluent programmatic API clients and SDKs in node.js and browsers which interacts with one or multiple HTTP layers.\n\nIt was designed to be extremely extensible via to its built-in hierarchical [middleware layer](#middleware), which supports high-level [plugins](#plugins), observer [hooks](#hooks), [validators](#validators) and traffic [interceptors](#interceptors).\n\nIt's also HTTP agent agnostic, so you can use `theon` with [superagent](https://github.com/visionmedia/superagent), [request](https://github.com/request/request), [fetch](https://fetch.spec.whatwg.org), [$.ajax](http://api.jquery.com/jquery.ajax/), [angular.$http](https://docs.angularjs.org/api/ng/service/$http) or any other agent via [adapters](#http-adapters).\n\nTo get started, take a look to [core concepts](#entities), [tutorial](#tutorial) and [examples](https://github.com/h2non/theon/tree/master/examples).\n\ntheon is currently used in production applications in both node.js and browser environments.\n\n## Contents\n\n- [Features](#features)\n- [Benefits](#benefits)\n- [Installation](#installation)\n- [Environments](#environments)\n- [Motivation](#motivation)\n- [Entities](#entities)\n  - [Client](#client)\n  - [Collection](#collection)\n  - [Resource](#resource)\n  - [Mixin](#mixin)\n- [Tutorial](#tutorial)\n- [Examples](#examples)\n- [HTTP adapters](#http-adapters)\n    - [Node.js](#nodejs)\n    - [Browsers](#browsers)\n  - [API](#api)\n  - [Writing HTTP adapters](#writing-http-adapters)\n- [Plugins](#plugins)\n- [Middleware](#middleware)\n  - [Phases](#phases)\n  - [API](#api-1)\n  - [Writing a middleware](#writing-a-middleware)\n- [Hooks](#hooks)\n  - [Phases](#phases-1)\n  - [API](#api-2)\n  - [Writing hooks](#writing-hooks)\n- [Validators](#validators)\n  - [Phases](#phases-2)\n  - [API](#api-3)\n  - [Writing a validator](#writing-a-validator)\n- [Interceptors](#interceptors)\n  - [Phases](#phases-3)\n  - [API](#api-4)\n  - [Writing an interceptor](#writing-an-interceptor)\n- [Evaluators](#evaluators)\n  - [Phases](#phases-4)\n  - [API](#api-5)\n  - [Writing an evaluator](#writing-an-evaluator)\n- [API](#api-6)\n- [License](#license)\n\n## Features\n\n- Simple, fluent and declarative API\n- Modular pluggable design with poweful composition capabilities\n- Hierarchical middleware layer (inspired in [connect](https://github.com/senchalabs/connect) middleware)\n- Nested configurations with powerful inheritance (based on radix tree data structure)\n- Domain specific and fluent API generation (inspired by [superagent](https://github.com/visionmedia/superagent))\n- Observable hooks at any phase of the HTTP flow live cycle.\n- Domain-specific API definition with built-in decorators support.\n- Perfectly fitted to be used with behavior-driven patterns based on observables.\n- Request/response interceptors\n- Request/response validators\n- Bind bodies to custom models easily\n- Supports node.js [streams](https://github.com/h2non/theon/tree/master/examples/streams.js) (HTTP adapter must support streams too)\n- Supports [promises](https://github.com/h2non/theon/blob/master/examples/promise.js) (only in modern JS engines)\n- Powerful HTTP fields reusability supporting hierarchical inheritance.\n- Built-in HTTP context data store to persist data, such as token or session data.\n- Maps HTTP entities to programmatic entities with custom logic.\n- Able to persist HTTP fields shared across all requests, such as headers, cookies...\n- Path params parsing and matching (with express-like path notation)\n- HTTP client agnostic: use `request`, `superagent`, `jQuery` or any other HTTP agent via adapters\n- Dependency free\n- Designed for testability\n- Lightweight: ~2K LOC (~8KB gzipped)\n- Runs in browsers and node.js (ES5 compliant)\n\n## Benefits\n\n- Write APIs in a declarative and powerful way\n- Easily create domain-specific fluent APIs\n- Create API clients that are simple to use and easy to maintain\n- Decouple API definition from API consumption layer\n- Underline HTTP interface details from API consumers\n- Map HTTP interfaces and resources to programmatic entities\n- And make future changes silently from consumers eyes.\n- Use or write your own plugins to augment some specific feature\n- Validate request and response params and bodies easily\n- Map and bind bodies to custom models easily\n- Perform pre/post operations (e.g: logging, validation, defaults...)\n- Save session data based on the client state live cycle (e.g: auth tokens, sessions...)\n- Minimize the boilerplate process while writing API clients\n- HTTP agent agnostic: pick what do you need based on the environment (`request`, `superagent`, `$.ajax`, `angular.$http` via agents)\n- Ubiquitous: write one API. Run it in any JavaScript environment\n- Easy to test via interceptor/mock middleware\n\n## Installation\n\nVia `npm`:\n```bash\nnpm install theon --save\n```\n\nVia `bower`:\n```bash\nbower install theon.js --save\n```\n\nOr loading the script from CDN:\n```html\n<script src=\"//cdn.rawgit.com/h2non/theon/master/theon.js\"></script>\n```\n\n## Environments\n\nRuns in any [ES5 compliant](http://kangax.github.io/mcompat-table/es5/) engine:\n\n![Node.js](https://cdn0.iconfinder.com/data/icons/long-shadow-web-icons/512/nodejs-48.png) | ![Chrome](https://raw.github.com/alrra/browser-logos/master/chrome/chrome_48x48.png) | ![Firefox](https://raw.github.com/alrra/browser-logos/master/firefox/firefox_48x48.png) | ![IE](https://raw.github.com/alrra/browser-logos/master/internet-explorer/internet-explorer_48x48.png) | ![Opera](https://raw.github.com/alrra/browser-logos/master/opera/opera_48x48.png) | ![Safari](https://raw.github.com/alrra/browser-logos/master/safari/safari_48x48.png)\n---  | --- | --- | --- | --- | --- |\n+0.10 | +5 | +3.5 | +9 | +12 | +5 |\n\n## Motivation\n\nI initially wrote this library to mitigate my frustration while writing further programmatic API clients for multiple HTTP layers across JavaScript environments.\n\nAfter dealing with recurrent scenarios, I realized that the process is essentially boilerplate in most cases, so then an specific solution can be conceived to simplify the process and provide a more convenient layer to do it better and faster.\n\nIn most scenarios, when you are writing APIs, you have to build a programmatic layer which maps to specific HTTP resources, usually when dealing with resource-oriented HTTP services.\nWith `theon` you can decouple those parts and provide a convenient abstraction between the HTTP interface details and the programmatic layer you want to provide to the API consumers.\n\nAdditionally, it provides a rich set of features to make you programmatic layer more powerful for either you as API builder and for your API consumers through a hierarchical middleware/hook layer which allows you to plug in and compose intermediate logic.\n\nI took some inspiration from [Google API client for node.js](https://github.com/google/google-api-nodejs-client) and in the way they are building a huge programmatic API layer, but you can probably do it even better with `theon`.\n\n## Entities\n\n`theon` introduces the concept of entity, which is basically an abstract object which stores and encapsulates HTTP specific protocol level data (such as headers, method, path or query params) and represents a hierachical entity in your API structure, which is usually mapped into an HTTP resource, subresource or endpoint.\n\nEntities hierarchy in `theon` are analog to a [radix tree](https://en.wikipedia.org/wiki/Radix_tree) structure, providing a associative implicit linking and feature inheritance across hierarchical entities.\n\nIn order to build your API you have to understand and use the concept of entity properly, and know how to use the different built-in entitities provided by `theon`.\n\nEntities are also useful as a sort of extensibility and composition layer, since you can plug in them at any level of your API. Also, entities can inherit from other entities, inheriting its functionality, configuration, middleware and hooks too.\n\nThe following graph represent the relation between theon entities and a common HTTP REST-like endpoint:\n\n```\n   /api         /users          /id      /favorites\n     ↓             ↓             ↓           ↓\n  [client] + [collection] + [resource] + [resource]\n     ↓             ↓             ↓           ↓\n  [mixin]?      [mixin]?      [mixin]?    [mixin]?\n```\n\n### Supported entities\n\n#### Client\n\n`client` represents the API client root high-level entity.\nEvery `theon` instance is a client entity itself, and it's mostly used as parent container for nested entities.\n\nSince `theon` is fully hierarchical, you can bind HTTP specific fields, such as headers, at client entity level. That means all the configuration attached at client level will be inherited in child entities.\n\n- Can inherit behavior from other `entity`, usually another `client`.\n- Can host `collections` and `resources`.\n- Can have `mixins`.\n- Supports middleware and observable hooks.\n\n#### Collection\n\n`collection` represents a set of entities. It was mainly designed to store a bunch of  other `collection` or `resources`, mostly used as sort of isolation entity to divide and compose different parts of your API.\n\n- Can inherit behavior from other `entity`, usually a `client`.\n- Can host other `collections` or `resources`.\n- Can have `mixins`.\n- Cannot perform requests itself.\n- Supports middleware and observable hooks.\n\n#### Resource\n\n`resource` is an entity designed to be attached to a specific HTTP resource, endpoint or HTTP action.\nThey're usually embedded as part of collections.\n\n- Can inherit behavior from other `entity`, usually a `collection`.\n- Can host `collections`, `resource`.\n- Can have `mixins`.\n- Can perform requests.\n- Supports middleware and observable hooks.\n\n#### Mixin\n\nA `mixin` is a custom user defined function hosting any kind of logic and supporting a free arguments input.\n\nThe `mixin` entity is analog to its programmaming terminology, meaning it mostly to extend a component with some specific feature as a sort of plug in.\n\n[Mixin example](https://github.com/h2non/theon/blob/master/examples/mixin.js).\n\n- Can inherit behavior from any other entity.\n- Cannot host other entities.\n- Cannot have other `mixins`.\n- Can perform requests (either by native implementation or inheriting the client from parent entities).\n- Supports middleware and observable hooks.\n\n## Tutorial\n\nLet's imagine we want to create a programmatic API client to interact with a remote HTTP service easily.\n\nWe have the following requirements:\n\n- The HTTP API only uses JSON as interchange format.\n- We have to pass a header to define the API version we want to use.\n- Certain resources are protected and we must to pass an authorization token.\n\nWe have the following HTTP interface:\n\n- POST /api/auth/login\n- POST /api/auth/signup\n- GET /api/users - `auth required`\n- GET /api/users/:id - `auth required`\n- POST /api/users/:id - `auth required`\n- DELETE /api/users/:id - `auth required`\n\nFirstly, as API developers, we're going to create and configure our base client using `theon`:\n\n```js\nvar theon = require('theon')\n\nvar client = theon('http://my.api.com')\n  .set('Version', '1.0') // Define the API version header at global level\n  .basePath('/api') // We define the base path for all the requests\n  .type('json') // Our payloads and responses will be always JSON\n```\n\nThen, we can start declaring the entities based on the HTTP API paths.\n\nLet's start building the `auth` entity.\n```js\nvar auth = client\n  .collection('auth')\n  .basePath('/auth')\n  .method('POST') // use this method for all the requests\n\n// Maps to POST /api/auth/login\nauth\n  .action('login')\n  .path('/login')\n\n// Maps to POST /api/auth/signup\nauth\n  .action('signup')\n  .path('/signup')\n  // Every time a new user is created successfully\n  // we store the session and set the auth header for future requests\n  .useResponse(function (req, res, next) {\n    // Store the response for future use\n    req.root.store.set('session', res.body)\n    // Set token for autentication to all the outgoing requests\n    req.root.persistHeader('Authorization', res.body.token)\n    // Continue the middleware chain\n    next()\n  })\n````\n\nNow we have our `auth` entity declared.\nLet's continue declaring the `users` entity in a different collection:\n\n```js\nvar users = client\n  .collection('users')\n  .basePath('/users')\n\n// Maps to GET /api/users\nusers\n  .action('find')\n  .alias('search')\n\n// Maps to GET /api/users/:id\nusers\n  .action('get')\n  .path('/:id')\n\n// Maps to POST /api/users/:id\nusers\n  .action('update')\n  .path('/:id')\n  .method('POST')\n\n// Maps to DELETE /api/users/:id\nusers\n  .action('delete')\n  .path('/:id')\n  .method('DELETE')\n  // Attach a response middleware to perform post request operations\n  .useResponse(function (req, res, next) {\n    // Every time the user is deleted, we clean its session\n    req.root.store.remove('session')\n    req.root.unset('Authorization')\n    // Continue the middleware chain\n    next()\n  })\n```\n\nNow we have all our API defined, but it's not ready yet for API end consumers.\nWe have to render it to provide the public API ready to be used by API consumers.\n\nLet's render it:\n```js\nvar api = client.render()\n```\n\nNow the public API is available via `api`.\nLet's see how it was rendered and play a bit with it as end API consumers.\n\nIn the following example we're going to register a new user:\n```js\napi.auth\n  .signup()\n  .send({ username: 'foo', password: 'b@r' })\n  .end(function (err, res, client) {\n    console.log('Response:', res.statusCode, res.body)\n  })\n```\n\nNow our client is authenticated, so we can try fetching the user:\n```js\napi.users\n  .get()\n   // important: we have to pass the path param\n  .param('id', 1)\n  // Note the don't have to explicitely pass any authentication credentials\n  .end(function (err, res) {\n    console.log('User:', res.body)\n  })\n```\n\nAlso, we can perform a user search:\n```js\napi.users\n  .find()\n  .query({ username: 'foo' })\n  .end(function (err, res) {\n    console.log('Search:', res.body)\n  })\n```\n\nThen we want to delete the user:\n```js\napi.users\n  .delete()\n  .param('id', 123)\n  .end(function (err, res) {\n    console.log('Search:', res.body)\n  })\n```\n\nFinally, to summarize, now our new API client provides a programmatic binding layer to the HTTP API resources, so we can draw the following relation map:\n\n- POST /api/auth/login => `api.auth.login()`\n- POST /api/auth/signup => `api.auth.login()`\n- GET /api/users => `api.users.find()`\n- GET /api/users/:id => `api.users.get()`\n- POST /api/users/:id => `api.users.create()`\n- DELETE /api/users/:id => `api.users.delete()`\n\nYou can see (and run) the tutorial script [here](https://github.com/h2non/theon/tree/master/examples/tutorial.js).\n\n## Examples\n\nTake a look to the [`examples`](https://github.com/h2non/theon/tree/master/examples) directory for featured use case examples.\n\n## HTTP adapters\n\nOne of the design goals of `theon` is making it HTTP agent agnostic, meaning it's not coupled to any specific HTTP client and runtime environment boundaries.\n\nIn other words, `theon` gives the ability to the developer to pick the prefered one based on its particular needs and runtime scenario, so if you're creating an API client for browsers and particular framework, let's say AngularJS, you don't have any constraint impossed by `theon` to use the native HTTP agent natively provided by the framework.\n\nTo clarify this, it worth to say that `theon` is not an HTTP client perse, neither implements stuff related to the HTTP network domain, it's just an abstraction layer providing a DSL to build and configure high-level HTTP protocol specific stuff.\n\nSo instead of implementing an HTTP client, `theon` relies on an external adapter which should be responsible of communicating with the real HTTP client, making it accesible by the proxy layer between `theon` interface and the target HTTP agent. Then all the HTTP network level stuff is completely delegated in the agent adapter. When the request is handled by the real HTTP agent, it should resolve the result properly and to report it to `theon` layer.\n\nIn other to be more pragmatic, `theon` provides by default two HTTP adapters for both node.js and browser environments, but it's up to you to write your own adapter to talk with another HTTP client, such as `superagent`, `got`, `$.ajax`, `angular.$http` or any other.\n\n#### Node.js\n\n- [request](https://github.com/request/request) `default` - Popular and featured HTTP client\n- [superagent](https://github.com/theonjs/superagent-adapter) - superagent HTTP adapter.\n- [resilient](https://github.com/theonjs/resilient-adapter) - [resilient.js](https://github.com/resilient-http/resilient.js) HTTP adapter.\n\n#### Browsers\n\n- [lil-http](https://github.com/lil-js/http) `default` - Lightweight XHR wrapper for browsers.\n- [angular](https://github.com/theonjs/angular-adapter) - Angular's $http adapter.\n\n### API\n\nAn HTTP agent should be a `function` expecting the following params:\n\n- **req** - [`theon.RawContext`](#rawcontext) - Request params context storing headers\n- **res** - [`theon.Response`](#responserequest) - Response object to fill\n- **cb** - `Function(Error, theon.Response)` - Callback to resolve the request\n\nAnd the `function` must return an object, which should implement at least the `abort()` method.\n\nTo clarify, using the TypeScript interface notation, it would be:\n```ts\ninterface AdapterResponse {\n  abort(): void;\n}\n\nfunction httpAdapter(\n  req: theon.RawContext,\n  res: theon.Response,\n  cb: (Error, theon.Response) => void\n) AdapterResponse\n```\n\n### Writing HTTP adapters\n\nOne of the main responsabilities of an HTTP agent adapter is acting as a interface mapper between `theon` scope and the target HTTP client, adapting both request and response interfaces.\n\nHere you can see an example of an HTTP adapter implementation for the node's [request](https://github.com/request/request) package:\n\n```js\nvar theon = require('theon')\nvar request = require('request')\n\nfunction requestAdapter(req, res, cb) {\n  var opts = {\n    url: req.url,\n    qs: req.query,\n    body: req.body,\n    headers: req.headers,\n    method: req.method,\n    useQuerystring: true\n  }\n\n  // Set JSON format\n  opts.json = req.opts.format === 'json'\n\n  // Set auth credentials, if required\n  if (req.opts.auth) {\n    opts.auth = req.opts.auth\n  }\n\n  // Extend agent-specific options\n  Object.assign(opts, req.agentOpts)\n\n  // If stream passed, pipe it!\n  // Note: not all the HTTP clients has to support stream\n  // in that case, you can resolve with an error or throw something\n  return req.stream\n    ? req.stream.pipe(request(opts, handler))\n    : request(opts, handler)\n\n  function handler(err, _res, body) {\n    cb(err, adapter(res, _res, body))\n  }\n}\n\n// We map fields to theon.Response interface for full compatibility\nfunction adapter(res, _res, body) {\n  if (!_res) return res\n\n  // Expose the agent-specific response\n  res.setOriginalResponse(_res)\n\n  // Define recurrent HTTP fields\n  res.setStatus(_res.statusCode)\n  res.setStatusText(_res.statusText)\n  res.setHeaders(_res.headers)\n\n  // Define body, if present\n  if (body) res.setBody(body)\n\n  return res\n}\n\n// Important: tell theon to use the HTTP adapter\ntheon.agents.set(requestAdapter)\n```\n\n## Plugins\n\n`theon` allows you to attach plugins to any HTTP high-level entity. Plugins are useful to encapsulate common logic through a clean and simple interface in `theon` based clients.\n\nYou can see an example [here](https://github.com/h2non/theon/blob/master/examples/plugin.js).\n\n### Third-party plugins\n\n- [expect](https://github.com/theonjs/expect) - supertest inspired HTTP expectation for your tests.\n\n#### Upcoming plugins\n\nPotential upcoming plugins based on my personal needs and wishes:\n\n- **consul** - Server discovery and balancing using Consul.\n- **retry** - Provide a simple retry logic policy in your API clients.\n- **JSONSchema** - Validate incoming and outgoing bodies againts a JSON schema.\n- **APIDocs** - Generate Swagger/Apiary docs reading the resource metadata annotations.\n\n## Middleware\n\n`theon` has been designed with strong extensibility capabilities in mind.\nExtensibility is mostly achieved via its built-in middleware layer,\nwhich allows you to plug in and extend the client features with custom logic.\n\nMiddleware layer has a hierarchical design, meaning you can plug in middlewares in parent scopes and them will be called from child scopes. For instance, you can plug in a middleware tasks to both global and resource levels. Then both middleware will be called, from top to bottom in hierarchical order, thus global will come always first.\n\nMiddleware layer behavies like a FIFO queue with control-flow capabilities, where asynchronicity is supported by detault.\n\nIt was strongly inspired in the well-known middleware pattern by connect/express.\n\n### Phases\n\n- **request** - Dispatched before send the request over the network\n- **response** - Dispatched after the client receives the response\n\n### API\n\n#### Request#use(middleware)\nAlias: `useRequest`\n\nAttach a new middleware in the `request` phase.\n\n#### Request#useEntity(middleware)\nAlias: `useEntityRequest`\n\nAttach a new middleware in the `request` phase in the current entity scope.\n\n#### Request#useResponse(middleware)\n\nAttach a new middleware in the `response` phase.\n\n#### Request#useEntityResponse(middleware)\n\nAttach a new middleware in the `response` phase in the current entity scope.\n\n#### Middleware notation\n\n`middleware` must implement the following TypeScript notation:\n\n```ts\nfunction middleware(\n  req: theon.RawContext,\n  res: theon.Response,\n  next: (Error?, theon.Response?) => void\n)\n```\n\n### Writing a middleware\n\nWriting a middleware is simple.\nIf you already know how to write a middleware for connect/express, you're mostly done.\n\n```js\nvar client = theon('http://my.api.com')\n  .set('Version', '1.0')\n  .basePath('/api')\n  .use(function (req, res, next) {\n    // Global HTTP middleware\n    console.log('Running global middleware...')\n    next()\n  })\n\nclient\n  .collection('users')\n  .basePath('/users')\n  .resource('get')\n  .path('/:id')\n  .use(function (req, res, next) {\n    console.log('Resource request middleware...')\n    next()\n  })\n  .useResponse(function (req, res, next) {\n    console.log('Resource response middleware...')\n    next()\n  })\n\n// Render the cient\nvar api = client.render()\n\napi.users.get()\n  .param('id', function (ctx, req) {\n    return ctx.root.store('currentUserId')\n  })\n  .end(function (err, res) {\n    console.log('Response:', res.status)\n    console.log('Body:', res.body)\n  })\n```\n\nSee [examples/middleware.js](https://github.com/h2non/theon/tree/master/examples/middleware.js) for a working example.\n\n## Hooks\n\n`theon` provides a built-in layer to attach hooks to observe and manage in detail the different phases in the HTTP flow live cycle inside your client.\n\nThey has been specially designed to provide control capabilities across the different internal phases of any HTTP transaction handled internally in `theon` clients.\nFurthermore, they are mostly useful to perform `pre` and `post` processing operations, such as defining defaults params and adapt/map things before they're processed by subsequent phases.\n\nHooks behavies like a traditional middleware, meaning you can alter, replace, intercept or even cancel any HTTP transaction at any stage.\n\nHooks can be attached to any entity, from client globa scope to resource level.\n\nHooks also rely in control-flow capabilities, so you can run asynchronous tasks inside them.\n\n### Phases\n\nSupported hook phases available for subscription, listed by execution order:\n\n- **before**\n- **before request**\n- **before middleware request**\n- **middleware request**\n- **after middleware request**\n- **before validator request**\n- **validator request**\n- **after validator request**\n- **after request**\n- **before dial**\n- **dialing**\n- **after dial**\n- **before response**\n- **before middleware response**\n- **middleware response**\n- **after middleware response**\n- **before validator response**\n- **validator response**\n- **after validator response**\n- **after response**\n- **after**\n- **error** - Only dispatched in case of error\n\n### API\n\n#### Request#observe(phase, hook)\n\nAttach a new observer hook to a given phase.\n\n#### Request#observeEntity(phase, hook)\n\nAttach a new observer hook to a given phase in the current entity scope.\n\n#### Request#before(hook)\n\nAttach a new observer hook to the `before` phase.\n\n#### Request#after(hook)\n\nAttach a new observer hook to the `after` phase.\n\n#### Hook notation\n\n`hook` must implement the following TypeScript notation:\n\n```ts\nfunction hook(\n  req: theon.RawContext,\n  res: theon.Response,\n  next: (Error?, theon.Response?) => void\n)\n```\n\n### Writing hooks\n\nObservable hooks has the same interface, and thus the same implementation as standard middleware or validators.\n\n```js\nvar client = theon('http://my.api.com')\n\nvar users = client\n  .basePath('/api')\n  .set('Version', '1.0')\n  .collection('users')\n  .basePath('/users')\n  .resource('get')\n  .path('/:id')\n\n// Attach a default observer for all the requests\nusers\n  .observe('after response', function (req, res, next) {\n    console.log('Log response:', res.statusCode, res.headers)\n    next()\n  })\n\n// Render the API client\nvar api = users.renderAll()\n\napi\n  .users\n  .get()\n  .param('id', 123)\n  // Attach an observer for the current request at API client level\n  .observe('after response', function (req, res, next) {\n    console.log('Log body:', res.body)\n    next()\n  })\n  .end(function (err, res) {\n    console.log('Done!')\n  })\n```\n\nSee [examples/hooks.js](https://github.com/h2non/theon/tree/master/examples/hooks.js) for a working example.\n\n## Validators\n\nA validator is technically a middleware that is executed after the standard middleware call chain and it's responsible of validating the request/response objects, for instance, you can validate payloads againts a JSON schema or HAR interface.\n\nValidators can be attached to any `theon` entity and supports both request/response phases.\n\nYou can use a validator to perform a validation of the request object before it's sent over the network in order to verify it has all the required params expected by the server, such as query params, headers, payload...\n\nIn the other hand, you can validate the response too, in order to determine if it can satisfy a certain requirements in the client side (e.g: response body, error messages, headers...).\n\n### Phases\n\n- **request** - Validate the request object before it's send over the network\n- **response** - Validate the response object once it has been received in the client\n\n### API\n\n#### Request#validator(validator)\n\nAttach a new request validator.\n\n#### Request#entityValidator(validator)\n\nAttach a new request validator at entity scope only.\n\n#### Request#responseValidator(validator)\n\nAttach a new response validator.\n\n#### Request#responseEntityValidator(validator)\n\nAttach a new response validator at entity scope only.\n\n#### Validator notation\n\nValidators has the same interface as middleware or hooks.\n\nA `validator` function must implement the following TypeScript notation:\n\n```ts\nfunction validator(\n  req: theon.RawContext,\n  res: theon.Response,\n  next: (Error?, theon.Response?) => void\n)\n```\n\n### Writing a validator\n\n```js\nvar client = theon('http://my.api.com')\n\nvar users = client\n  .basePath('/api')\n  .collection('users')\n  .resource('get')\n  .path('/:id')\n  // Attach a resource level validator\n  .validator(function (req, res, next) {\n    if (req.params.id > 10000) {\n      return next(new Error('validation error: id param must be lower than 10000'))\n    }\n    next() // otherwise continue\n  })\n  // Attach a resource level response validator\n  .responseValidator(function (req, res, next) {\n    if (!res.body) {\n      return next(new Error('response validation error: body cannot be empty'))\n    }\n    next() // otherwise continue\n  })\n\n// Render the API client\nvar api = users.renderAll()\n\napi\n  .users\n  .get()\n  .param('id', 123)\n  // Attach another validator at public API client level\n  .validator(function (req, res, next) {\n    if (typeof req.params.id !== 'number') {\n      return next(new Error('validation error: id param must a number'))\n    }\n    next() // otherwise continue\n  })\n  .end(function (err, res) {\n    console.log('Done!')\n  })\n```\n\nSee [examples/validator.js](https://github.com/h2non/theon/tree/master/examples/validator.js) for a working example.\n\n## Interceptors\n\nInterceptors are a useful built-in feature provided in `theon` when you need to intercept some HTTP flow.\n\nIt becomes particularly useful to mock requests while testing or to provide default responses given a certain conditions.\n\nTechnically speaking it's equivalent to a middleware, so you can rely in control flow capatibilities and inspect both request/response objects to determine when the traffic should be intercepted.\n\n### Phases\n\n- **before dial** - Executed before proceed with the network dialing phase.\n\n### API\n\n#### Request#interceptor(interceptor)\n\nAttach a new interceptor.\n\n#### Request#entityInterceptor(interceptor)\n\nAttach a new interceptor at entity scope only.\n\n#### Interceptor notation\n\nValidators has the same interface as middleware or hooks.\n\nAn `interceptor` function must implement the following TypeScript notation:\n\n```ts\nfunction interceptor(\n  req: theon.RawContext,\n  res: theon.Response,\n  next: (Error?, theon.Response?) => void\n)\n```\n\n### Writing an interceptor\n\n```js\nvar client = theon('http://my.api.com')\n\nvar users = client\n  .basePath('/api')\n  .collection('users')\n  .basePath('/users')\n  .resource('get')\n  .path('/:id')\n  // Attach a resource level interceptor\n  .interceptor(function (req, res, next) {\n    // Determine if we should interceptor the request\n    if (req.params.id > 100) {\n      res.setStatus(400)\n      res.setStatusText('Bad Request')\n      res.setBody({ error: 'Invalid user ID' })\n      // We must pass an custom string to notify we intercepted the request\n      return next('intercept')\n    }\n\n    next() // otherwise continue\n  })\n\n// Render the API\nvar api = users.renderAll()\n\n// Intercepted request\napi.users\n  .get()\n  .param('id', 101)\n  .end(function (err, res) {\n    console.log('Response:', res.statusCode)\n  })\n\n// Non-intercepted\napi.users\n  .get()\n  .param('id', 99)\n  .end(function (err, res) {\n    console.log('Response:', res.statusCode)\n  })\n```\n\nSee [examples/interceptor.js](https://github.com/h2non/theon/tree/master/examples/interceptor.js) for a working example.\n\n## Evaluators\n\nEvaluators are designed to inspect the response object and determine, given a certain user-defined rules, if the request was failed or not, and handle it accordinly.\n\nBy default `theon` doesn't handle error status such as `400` as failed request, but you can use a validator to do it and behave accordingly to your needs.\n\n### Phases\n\n- **response** - Executed once the client received the response from the server\n\n### API\n\n#### Request#evaluator(evaluator)\n\nAttach a new evaluator function.\n\n#### Evaluator notation\n\nEvaluators has the same interface as middleware or hooks.\n\nAn `evaluator` function must implement the following TypeScript notation:\n\n```ts\nfunction evaluator(\n  req: theon.RawContext,\n  res: theon.Response,\n  next: (Error?, theon.Response?) => void\n)\n```\n\n### Writing an evaluator\n\n```js\nvar users = client\n  .basePath('/api')\n  .collection('users')\n  .basePath('/users')\n  .resource('get')\n  .path('/:id')\n  // Attach a resource level evaluator\n  .evaluator(function (req, res, next) {\n    if (res.status >= 400) {\n      return next(new Error('Invalid status code: ' + res.status))\n    }\n    next() // otherwise continue\n  })\n\n// Render the API\nvar api = users.renderAll()\n\n// Invalid request\napi.users\n  .get()\n  .param('id', 1)\n  .end(function (err, res) {\n    console.log('Error:', err)\n  })\n\n// Non-intercepted\napi.users\n  .get()\n  .param('id', 2)\n  .end(function (err, res) {\n    console.log('Response:', res.statusCode)\n  })\n```\n\nSee [examples/evaluator.js](https://github.com/h2non/theon/tree/master/examples/evaluator.js) for a working example.\n\n## API\n\n### theon([ url ]) => `Client`\n\nCreate a new API builder.\n\n#### theon.client([ url ])\nInherits from [`Entity`](#entity)\n\nCreate a new `client` entity.\n\n#### theon.collection(name)\nInherits from [`Entity`](#entity)\n\nCreate a new `collection` entity.\n\n#### theon.resource(name)\nInherits from [`Entity`](#entity)\n\nCreate a new `resource` entity.\n\n#### theon.mixin(name, fn)\nInherits from [`Entity`](#entity)\n\nCreate a new `mixin` entity.\n\n#### theon.agents\n\nAPI to manage HTTP agents adapters.\n\n#### theon.agents.agents = { name: agentAdapterFn }\n\nMap of agents by name and adapter function.\n\n#### theon.agents.defaults() => `function`\n\nRetrieve the default HTTP agent adapter bases on the runtime environment.\n\n#### theon.agents.get(name) => `function`\n\nRetrieve an HTTP agent adapter by name.\n\n#### theon.agents.set(agent)\n\nSet an HTTP agent to be used by default.\nAll the HTTP traffic will be handled by this agent.\n\n#### theon.agents.add(name, adapterFn)\n\nRegister a new HTTP agent adapter by name.\n\n#### theon.Request([ ctx ])\n\nCreates a new HTTP request instance based on the given context\n\n#### theon.Response(req)\n\nCreates a new HTTP response instance for the given request.\n\n#### theon.Store([ parent ])\n\nCreates a new data store instance, optionally inheriting from a parent store.\n\n### Entity\nInherits from [`Request`](#request)\n\n#### Entity#alias(name)\n\nAdd an additional entity alias name.\n\n#### Entity#decorate(decorator)\nAlias: `decorator`\n\nDecorate entity constructor.\n\nSee [examples/decorator.js](https://github.com/h2non/theon/blob/master/examples/decorator.js) for an example.\n\n#### Entity#collection(collection)\n\nAttach a collection to the current entity.\n\n#### Entity#action(action)\nAlias: `resource`\n\nAttach an action to the current entity.\n\n#### Entity#mixin(mixin)\nAlias: `helper`\n\nAttach a mixin to the current entity.\n\n#### Entity#useConstructor(fn)\n\nDefine a custom entity constructor function.\nOnly implemented for `Resource` and `Collection` entities.\n\n#### Entity#addEntity(entity)\n\nAttach a custom subentity.\n\n#### Entity#getEntity(name, [ type ])\nAlias: `findEntity`\n\nRetrieves a child entity looking by name.\n\n#### Entity#getCollection(name)\nAlias: `findCollection`\n\nRetrieves a child collection entity looking by name.\n\n#### Entity#getResource(name)\nAlias: `getAction`, `findResource`\n\nRetrieves a child resource entity looking by name.\n\n#### Entity#getMixin(name)\nAlias: `findMixin`\n\nRetrieves a child mixin entity looking by name.\n\n#### Entity#getClient(name)\nAlias: `findClient`\n\nRetrieves a child client entity looking by name.\n\n#### Entity#extend(name, value)\n\nExtend the entity with a custom property and value.\nSimilar to mixins, but simpler.\n\n#### Entity#meta(metadata)\n\nAttach metadata to the current entity.\nMostly useful for annotations, flagging and documentation purposes.\n\n#### Entity#render([ entity ]) => ClientEngine\n\nRender all the entities, from current to root entity.\n\n#### Entity#renderEntity([ entity ])\n\nRender the current entity, without rendering parent entities.\nThis method is mostly used internally.\n\n### Request([ ctx ])\n\n#### Request#parent = `Request`\n\nReference to the parent `Request`, in case that it has a parent node.\n\n#### Request#root = `Request`\n\nReference to the parent root node, in case that it has a parent node.\n\nInternally, it walks across all the parent nodes recursively until find the latest.\n\n#### Request#store = `Store`\n\nReference to the current request `Store` instance.\n\n#### Request#ctx = `Context`\n\nReference to the current request `Context` instance.\n\n#### Request#api = `engine.Client`\n\nReference to the root public API client DSL generated via: `.render()`.\n\nUseful to make public calls from nested/child entities to parent entities via the public generated DSL.\n\n#### Request#url(url)\n\nDefine the base URL of the server.\n\n#### Request#path(path)\n\nDefine an URL final path value. `path` will be concatenated to `basePath`.\n\n#### Request#basePath(path)\n\nDefine a URL base path value.\n\n#### Request#method(name)\n\nHTTP method to use. Default to `GET`.\n\n#### Request#param(name, value)\n\nDefines a path param.\n\n`value` argument can be a `string`, `number` or a `function` supporting the following interface:\n\n```js\nfunction getParam (\n  ctx. theon.Content,\n  req: theon.RawContext,\n) String|Number\n```\n\n#### Request#params(params)\n\n#### Request#persistParam(name, value)\n\n#### Request#persistParams(params)\n\n#### Request#unsetParam(name)\n\n#### Request#setParams(params)\n\n#### Request#query(query)\n\n#### Request#setQuery(query)\n\n#### Request#queryParam(name, value)\n\n#### Request#unsetQuery(name)\n\n#### Request#persistQueryParams(query)\nAlias: `persistQuery`\n\n#### Request#persistQueryParam(name, value)\n\n#### Request#set(name, value)\nAlias: `header`\n\n#### Request#unset(name)\n\n#### Request#headers(headers)\n\n#### Request#setHeaders(headers)\n\n#### Request#persistHeader(name, value)\n\n#### Request#persistHeaders(headers)\n\n#### Request#type(name)\n\n#### Request#accepts(name)\n\n#### Request#format(type)\n\n#### Request#send(body)\nAlias: `body`\n\n#### Request#cookie(name, value)\n\n#### Request#unsetCookie(name)\n\n#### Request#auth(user, password)\n\n#### Request#plugin(plugin)\nAlias: `usePlugin`\n\n#### Request#getPlugin(pluginName|pluginFn)\n\n#### Request#use(middleware)\nAlias: `useRequest`\n\n#### Request#useEntity(middleware)\nAlias: `useEntityRequest`\n\nAttach a middleware restricted to the current entity scope.\n\n#### Request#useResponse(middleware)\n\n#### Request#useEntityResponse(middleware)\n\nAttach a response middleware restricted to the current entity scope.\n\n#### Request#before(middleware)\n\nAttach a middleware as observer hook in the before.\n\n#### Request#after(middleware)\n\nAttach a middleware as observer hook in the after phase.\n\n#### Request#observe(event, hook)\n\n#### Request#validator(validator)\nAlias: `requestValidator`\n\n#### Request#entityValidator(validator)\nAlias: `requestEntityValidator`\n\n#### Request#entityResponseValidator(validator)\n\n#### Request#interceptor(interceptor)\n\n#### Request#entityInterceptor(interceptor)\n\n#### Request#evaluator(fn)\n\nAttach a `before response` hook to evaluate the response and determine if it's valid or not.\nUseful to evaludate response status and force an error. E.g: `status` >= 400\n\n#### Request#entityEvaluator(fn)\n\n#### Request#map(fn)\nAlias: `bodyMap`\n\nAttach a body mapper to transform, normalize, filter... the response body.\nSimilar to `model` feature but operating overwriting the original `body`.\n\n#### Request#validate(cb)\n\n#### Request#model(model)\n\n#### Request#agent(agent)\n\n#### Request#agentOpts(opts)\n\n#### Request#setAgentOpts(opts)\n\n#### Request#persistAgentOpts(opts)\n\n#### Request#options(opts)\n\n#### Request#persistOptions(opts)\n\n#### Request#useParent(parent)\n\n#### Request#response(fn)\nAlias: `handle`\n\nAttach a function to handle the response object in case that the request success.\n\nFunction arguments are:\n\n- **theon.Response**\n- **theon.Request**\n\n#### Request#end(cb)\nAlias: `done`\n\nDispatch the request, sending it over the network.\n\n#### Request#then(onFullfilled, onRejected)\nReturn: `Promise`\n\nPromise based interface to handle the request resolution, dispatching the request over the network, if necessary.\n\n#### Request#catch(onRejected)\nReturn: `Promise`\n\nPromise based interface to handle the request error, dispatching the request over the network, if necessary.\n\n#### Request#pipe(stream)\n\nnode.js stream compatible interface to pipe writable streams with the response body.\n\nNote that the used HTTP agent must support streams too, if not, they are ignored.\n\n#### Request#stream(stream)\nAlias: `bodyStream`\n\n#### Request#raw() => [RawContext](#RawContext)\n\n#### Request#clone()\n\n#### Request#newRequest([ parent ])\n\n### Response(request)\n\n#### Response#headers = `object`\n\n#### Response#body = `mixed`\n\n#### Response#error = `mixed`\n\n#### Response#statusType = `number`\n\n#### Response#statusCode = `number`\n\n#### Response#statusText = `string`\n\n#### Response#orig = `object`\n\n#### Response#serverError = `boolean`\n\n#### Response#clientError = `boolean`\n\n#### Response#setOriginalResponse(orig)\n\n#### Response#setBody(body)\n\n#### Response#setHeaders(headers)\n\n#### Response#setType(contentType)\n\n#### Response#setStatus(status)\n\n#### Response#setStatusText(text)\n\n#### Response#toError() => `Error`\n\n#### Response#ok = `boolean`\n\n#### Response#info = `boolean`\n\n#### Response#accepted = `boolean`\n\n#### Response#noContent = `boolean`\n\n#### Response#badRequest = `boolean`\n\n#### Response#unauthorized = `boolean`\n\n#### Response#notAcceptable = `boolean`\n\n#### Response#notFound = `boolean`\n\n#### Response#forbidden = `boolean`\n\n### Context([ parent ])\n\n#### Context#store = `Store`\n\n#### Context#method = `string`\n\n#### Context#body = `mixed`\n\n#### Context#stream = `ReadableStream`\n\n#### Context#useParent(ctx)\n\n#### Context#raw()\n\n#### Context#clone()\n\n#### Context#buildPath()\n\n### RawContext\n\nSide-effect free raw HTTP context params.\nIt's passed to the middleware and validator call chain.\n\n#### RawContext#root = `Request`\n\nReference to the parent root `Request` instance.\n\n#### RawContext#api = `engine.Client`\n\nReference to the root public API client DSL generated via: `.render()`.\n\nUseful to make public calls from nested/child entities to parent entities via the public generated DSL.\n\n#### RawContext#client = `Request`\n\nReference to the current `Request` instance.\n\n#### RawContext#headers = `object`\n\n#### RawContext#query = `object`\n\n#### RawContext#params = `object`\n\n#### RawContext#body = `mixed`\n\n#### RawContext#method = `string`\n\n#### RawContext#stream = `ReadableStream`\n\n#### RawContext#opts = `object`\n\n#### RawContext#agent = `function`\n\n#### RawContext#agentOpts = `object`\n\n#### RawContext#ctx = `Context`\n\nCurrent original context instance.\n\n#### RawContext#req = `Request`\n\nCurrent original request instance.\n\n### Store([ parent ])\n\n#### Store#parent? = `Store`\n\n#### Store#get(key)\n\n#### Store#set(key, value)\n\n#### Store#setParent(key, value)\n\n#### Store#remove(key)\n\n#### Store#has(key)\n\n#### Store#useParent(store)\n\n## License\n\n[MIT](http://opensource.org/licenses/MIT) © Tomas Aparicio\n\n[travis]: http://travis-ci.org/h2non/theon\n","created":"2015-10-08T14:10:14.111Z","modified":"2016-02-09T11:32:24.592Z","lastPublisher":{"name":"h2non","email":"tomas@aparicio.me"},"owners":[{"name":"h2non","email":"tomas@aparicio.me"}],"other":{"_attachments":{},"_from":".","_id":"theon","_nodeVersion":"5.5.0","_npmOperationalInternal":{"host":"packages-9-west.internal.npmjs.com","tmp":"tmp/theon-0.1.28.tgz_1455017541472_0.8382368513848633"},"_npmUser":{"name":"h2non","email":"tomas@aparicio.me"},"_npmVersion":"3.3.12","_rev":"1-baabfb90fc578ffc1f3394245483ba88","_shasum":"727c8f5adcefe6bc7796dbb0e61f69d044402317","author":{"name":"Tomas Aparicio"},"bugs":{"url":"https://github.com/h2non/theon/issues"},"directories":{},"dist-tags":{"latest":"0.1.28"},"dist":{"shasum":"727c8f5adcefe6bc7796dbb0e61f69d044402317","tarball":"http://registry.npmjs.org/theon/-/theon-0.1.28.tgz"},"maintainers":[{"name":"h2non","email":"tomas@aparicio.me"}],"readmeFilename":"README.md","time":{"modified":"2016-02-09T11:32:24.592Z","created":"2015-10-08T14:10:14.111Z","0.1.0-beta.0":"2015-10-08T14:10:14.111Z","0.1.0-beta.1":"2015-10-13T22:00:36.148Z","0.1.0":"2015-10-18T13:31:02.395Z","0.1.1":"2015-10-18T22:35:59.207Z","0.1.2":"2015-10-19T22:31:02.138Z","0.1.3":"2015-10-21T17:09:40.086Z","0.1.4":"2015-10-23T17:40:25.217Z","0.1.5":"2015-10-26T12:27:03.780Z","0.1.6":"2015-10-29T14:05:44.214Z","0.1.7":"2015-12-08T00:31:56.844Z","0.1.8":"2015-12-09T19:49:21.170Z","0.1.9":"2015-12-09T22:20:50.926Z","0.1.10":"2015-12-10T00:25:46.489Z","0.1.11":"2015-12-10T00:33:02.591Z","0.1.12":"2015-12-11T13:46:57.388Z","0.1.13":"2015-12-12T00:48:37.793Z","0.1.14":"2015-12-12T16:27:54.916Z","0.1.15":"2015-12-12T18:33:12.058Z","0.1.16":"2015-12-14T10:33:00.288Z","0.1.17":"2015-12-14T17:08:33.154Z","0.1.18":"2015-12-15T21:43:31.434Z","0.1.19":"2015-12-21T09:57:42.056Z","0.1.20":"2015-12-28T20:04:59.736Z","0.1.21":"2015-12-30T13:22:14.474Z","0.1.22":"2015-12-30T13:49:09.967Z","0.1.23":"2015-12-30T14:31:49.941Z","0.1.24":"2016-01-01T12:04:08.570Z","0.1.25":"2016-01-01T20:13:04.546Z","0.1.26":"2016-01-04T15:47:31.678Z","0.1.27":"2016-02-01T12:50:48.603Z","0.1.28":"2016-02-09T11:32:24.592Z"}}}