{"name":"resorcery","description":"a library for creating 'resources' to respond to http requests in node.js","keywords":["api","rest","http","resource","resources"],"version":"1.0.3","scripts":{"test":"make test-coveralls"},"dependencies":{"underscore":""},"devDependencies":{"request":"2.27.0","jshint":"2.4.4","istanbul":"0.2.6","coveralls":"2.10.0","watch":"0.5.1","mocha":"1.3.2","should":"1.1.0","detour":"1.0.1"},"repository":"https://github.com/cainus/resorcery","main":"./resourcery","license":"MIT","homepage":"https://github.com/cainus/resorcery","versions":[{"number":"0.1.0","date":"2012-05-28T17:36:41.780Z"},{"number":"0.1.1","date":"2012-06-05T13:04:09.078Z"},{"number":"0.1.2","date":"2012-07-31T02:39:01.995Z"},{"number":"0.1.3","date":"2012-07-31T16:59:43.869Z"},{"number":"0.1.4","date":"2012-08-14T17:07:25.617Z"},{"number":"0.2.0","date":"2013-11-05T23:51:16.653Z"},{"number":"0.2.1","date":"2013-11-06T00:35:47.609Z"},{"number":"1.0.0","date":"2014-03-26T17:46:30.883Z"},{"number":"1.0.1","date":"2014-03-27T19:26:15.608Z"},{"number":"1.0.2","date":"2014-03-29T18:40:34.181Z"},{"number":"1.0.3","date":"2014-03-30T04:25:47.107Z"}],"readme":"# resorcery\n\n[![Build Status](https://secure.travis-ci.org/cainus/resorcery.png?branch=master)](http://travis-ci.org/cainus/resorcery)\n[![Coverage Status](https://coveralls.io/repos/cainus/resorcery/badge.png?branch=master)](https://coveralls.io/r/cainus/resorcery?branch=master)\n[![NPM version](https://badge.fury.io/js/resorcery.png)](http://badge.fury.io/js/resorcery)\n\n**resorcery** is a node.js library for use in http apis for dealing with a single url as a unified 'resource', rather than a collection of separate functions.  This is useful for a more consistent api, better code re-use, and simpler routing and error-handling.\n\nIt is meant primary for use with the [detour](https://github.com/cainus/detour) router, which can be used with [express](http://expressjs.com/) and [connect](http://www.senchalabs.org/connect/) applications, but it's got a simple enough interface that other routers could add support for it easily.\n\n## example usage:\n\n## resource(handler, [options])\nThe `resource()` function takes a handler object for your resource and gives you the ability to specify common authentication, authorization, and data access strategies that can be used for all methods.   \n\n### The `handler` argument:\nIn its most basic form, the `handler` argument should be a hash of all the HTTP methods you wish the resource to support and their implementations.  For example, if you want your resource to support GET and POST, your handler object might look like this:\n\n```javascript\n{\n    GET : function(req, res){\n        // implement this however you want, eg:\n        res.end(\"get works!\");\n    }, \n    \n    POST: function(req, res){\n        // implement this however you want, eg:\n        res.end(\"post works!\");\n    }\n}\n```\n\nAll of the methods available methods (GET, POST, DELETE, PUT, PATCH, HEAD, OPTIONS) are optional.  You can implement as many or as few as you wish, though logically you must implement at least one of GET, POST, DELETE, PUT, or PATCH, or there's nothing to route.\n\nHEAD and OPTIONS methods will be implemented for you automatically (by default -- though you can implement like any other method, or override them with the `resource()`'s second optional `options` argument, discussed later).  You probably don't need or want to implement HEAD or OPTIONS yourself unless you really know what you're doing.\n\n#### Extra Helpers:\nThese extra helpers are all optional, but can simplify and DRY up your code considerably in cases where you are implementing multiple HTTP methods for a single url.  The helper methods are `fetch()`, `authenticate()`, and `forbid()` and, if they are added to your resource, they will be run serially in that order, skipping any that aren't implemented, BEFORE the HTTP methods are executed.  \n\n##### fetch(req, res, cb)\nThis is useful when you need to do some asynchronous work (like a database query) to determine if the url should 404 or not.\n\nIf implemented, this is always the first method called for any request of this resource.\n\n###### Immediately responding with a 404\n```javascript\nreturn cb(true);\n```\n###### Immediately responding with a 500 \n(meaning there was an internal server error): \n```javascript\nreturn cb(someError);\n```\neg:\n```javascript\nreturn cb(new Error(\"database is not responding!\"));\n```\n###### When the resource at this url exists...\nYou can just `return cb()` to continue allowing their request, but if you've retrieved some data that represents this url in the process of determining if it exists, it might be even nicer to do this:\n\n```javascript\nreturn cb(null, someData);\n```\nIf you do that then `req.fetched` will be set to `someData` in all your method handlers (GET, POST, PUT, DELETE, PATCH, HEAD), and request processing will continue.  This can come in handy anytime you might later need that data for the resource (often you need it for GET at least, and this can save a redundant database call).\n\n###### Usage:\n```javascript\n{\n    fetch : function(req, res, cb){\n        getSomeDataForThisUrl(req.url, function(err, data){\n            if (err){\n                return cb(err);\n            }\n            if (!data){\n                return cb(true);\n            }\n            return cb(null, data);\n        });\n    },\n    \n    GET : function(req, res){\n        res.end(JSON.stringify(req.fetched));\n    }\n\n}\n```\n##### authenticate(req, res, cb)\nThis is useful when you want to do the authentication for all your methods in one place.  If you don't implement this, all users are authorized.\n\nIf implemented, this is always called after `fetch()` if `fetch()` is implemented, otherwise it's called first.\n\n###### Immediately responding with a 401\n(meaning the user isn't authenticated): \n```javascript\nreturn cb(true);\n```\n\n###### Immediately responding with a 500 \n(meaning there was an internal server error): \n```javascript\nreturn cb(someError);\n```\neg:\n```javascript\nreturn cb(new Error(\"database is not responding!\"));\n```\n\n###### When the user is authenticated (ie logged in)...\nYou can just `return cb()` to continue allowing their request, but if you've got a user object, it might be even nicer to do this:\n\n```javascript\nreturn cb(null, userObject);\n```\n\nIf you do that, then `req.authenticated` will be set to your `userObject` in all your method handlers (GET, POST, PUT, DELETE, PATCH, HEAD), and request processing will continue.  This can come in handy so you can access the user object as `req.authenticated`, and always know that the user is properly authenticated.\n\n###### Usage:\n```javascript\n{\n    authenticated : function(req, res, cb){\n        getUserFromSession(req, function(err, user){\n            if (err){\n                return cb(err);\n            }\n            if (!user){\n                return cb(true);\n            }\n            return cb(null, user);\n        });\n    },\n    \n    GET : function(req, res){\n        res.end(\"you're logged in!\");\n    }\n\n}\n```\n\n##### forbid(req, res, cb)\nThis is useful when you want to handle permissions for all your methods in one place.  If you don't implement this, all users are permitted.  Also: This probably only makes sense if the user is already authenticated, otherwise you probably don't have a criteria for deciding whether or not they're forbidden. \n\nIf implemented, this is always called after `fetch()` and/or `authenticate()` if those methods are implemented, otherwise it's called first.\n\n###### Immediately responding with a 403\n(meaning the user doesn't have the necessary permissions)\n\n###### To forbid all methods:\n```javascript\nreturn cb(null, true); \n```\n\n###### To specify particular methods that are forbidden: \n```javascript\nreturn cb(null, arrayOfHttpMethodNames);\n```\neg: \n```javascript\nreturn cb(null, ['PUT', 'DELETE']);\n```\n\n###### Immediately responding with a 500 \n(meaning there was an internal server error): \n```javascript\nreturn cb(someError);\n```\n###### When the user isn't forbidden at all...\n```javascript\nreturn cb();\n```\n###### Usage:\n```javascript\n{\n    authenticated : myAuthenticationFunction,\n    \n    forbidden : function(req, res, cb){\n        switch(req.authenticated.type){\n            case 'admin' : return cb();\n            case 'writer' : return cb(null, ['DELETE']);\n            case 'reader' : return cb(true);  // forbid all 'readers'!\n        }\n    },\n    \n    GET : function(req, res){\n        res.end(\"you could be any type!\");\n    },\n\n    DELETE : function(req, res){\n        res.end(\"you're an admin\");\n    }\n\n}\n```\n\n### The `options` object:\nThe `resource()` method automatically adds two things to your resource by default:\n\n#### optionsStrategy(req, res, arrayOfImplementedMethods)\nThe default implementation of OPTIONS sets the `Allow` response header to notify clients of all the methods that your resource supports.  You can override that default by specifying an `optionsStrategy` though.  The third argument, `arrayOfImplementedMethods` is an array of all the HTTP methods that are implemented on the resource, and can be used for setting the 'Allow' header yourself, or sending the list of allowed methods in the response body.\n\n#### notFoundStrategy(req, res)\nThis lets you change how 404s are handled by default in your resource.  Anytime `fetch()`'s callback is called with a first parameter that's `true`, a notFoundStrategy runs to handle it.  If you don't like the default one, you can override it here.\n\n#### methodNotAllowedStrategy(req, res, arrayOfImplementedMethods)\nBy default, `resource()` makes your resource properly respond with 405 \"Method not allowed\" errors (including the proper 'Allow' header) when a method doesn't exist for your resource, but you can change the details of how that works with the `methodNotAllowedStrategy()`.   The third argument, `arrayOfImplementedMethods` is an array of all the HTTP methods that are implemented on the resource, and can be used for setting the 'Allow' header yourself, or sending the list of allowed methods in the response body.\n\n#### internalServerErrorStrategy(req, res, error)\nThis lets you change how 500s ('Internal Server Error') are handled by default in your resource.  Anytime `fetch()`, `authenticate()`, or `forbid()`'s callback is called with a first parameter that's an error, an internalServerErrorStategy runs to handle it.  If you don't like the default one, you can override it here.  The third argument, `error` is the error object that got passed.  It can be used for logging or outputting via the response body.\n","starsCount":1,"created":"2012-05-28T17:36:40.342Z","modified":"2014-03-30T04:25:47.107Z","lastPublisher":{"name":"cainus","email":"gregg@caines.ca"},"owners":[{"name":"cainus","email":"gregg@caines.ca"}],"other":{"_attachments":{},"_from":".","_id":"resorcery","_npmUser":{"name":"cainus","email":"gregg@caines.ca"},"_npmVersion":"1.4.3","_rev":"1-75f1865ee1dead82de74ed9cd7afcc9b","bugs":{"url":"https://github.com/cainus/resorcery/issues"},"directories":{},"dist-tags":{"latest":"1.0.3"},"dist":{"shasum":"17d6e0e8e345733991af19f5a88ddb733409a6d8","tarball":"http://registry.npmjs.org/resorcery/-/resorcery-1.0.3.tgz"},"maintainers":[{"name":"cainus","email":"gregg@caines.ca"}],"readmeFilename":"README.md","time":{"modified":"2014-03-30T04:25:47.107Z","created":"2012-05-28T17:36:40.342Z","0.1.0":"2012-05-28T17:36:41.780Z","0.1.1":"2012-06-05T13:04:09.078Z","0.1.2":"2012-07-31T02:39:01.995Z","0.1.3":"2012-07-31T16:59:43.869Z","0.1.4":"2012-08-14T17:07:25.617Z","0.2.0":"2013-11-05T23:51:16.653Z","0.2.1":"2013-11-06T00:35:47.609Z","1.0.0":"2014-03-26T17:46:30.883Z","1.0.1":"2014-03-27T19:26:15.608Z","1.0.2":"2014-03-29T18:40:34.181Z","1.0.3":"2014-03-30T04:25:47.107Z"},"users":{"fgribreau":true}}}