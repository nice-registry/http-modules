{"name":"rpcify","private":false,"version":"0.0.2","description":"Express middleware to make any object function accesible over http","keywords":["rpc","object","functions","http"],"dependencies":{"lodash":"*"},"scripts":{},"main":"index.js","repository":"https://github.com/BrighTide/rpcify","license":"MIT","gitHead":"d8ed660c1516c4f8846c81062d806a3ccf4b0450","homepage":"https://github.com/BrighTide/rpcify","versions":[{"number":"0.0.1","date":"2015-08-28T05:28:32.985Z"},{"number":"0.0.2","date":"2015-08-28T06:39:42.453Z"}],"readme":"# Rpcify\r\nA niffty express middleware to make your object functions accessible over http.\r\n\r\n##Installation\r\n\r\n```\r\n    npm install rpcify\r\n```\r\n\r\n##Basic Usage\r\n\r\n```javascript\r\nvar express = require('express');\r\nvar rpcify = require('rpcify');   //Require the package\r\nvar fs = require('fs');\r\nvar app = express();\r\n\r\napp.use(rpcify.middleware);    //Tell express to use our middleware\r\n\r\nrpcify.wrap({id:\"fs\", obj:fs, whitelist:[\"mkdir\"]});   //Wrap the object\r\n//or\r\nrpcify.wrap(\"fs\", fs, [\"mkdir\"]);\r\n\r\nvar server = app.listen(3000, function () {\r\n  var host = server.address().address;\r\n  var port = server.address().port;\r\n\r\n  console.log('Example app listening at http://%s:%s', host, port);\r\n});\r\n```\r\n\r\n```javascript\r\n//Then, from anywhere, just pop off a request to {address}/rpc/{id}/{operation}\r\n//Make sure to include a list of arguments (minus the callback) as an array.\r\n$http.post(\"http://localhost:3000/rpc/fs/mkdir\", [\"/sweet!\"])\r\n.success(function(){\r\n    console.log(\"Directory creation success!\");\r\n}).error(function(err){\r\n    console.log(\"Oh no, and error occured!\", err);\r\n});\r\n```\r\n\r\n##Under the hood\r\n\r\nAny function called by the rpc relay will be called using the provided arguments array with the callback, request and response appended. The object with be set as the context\r\n\r\n```javascript\r\n    $http.post(address + \"/rpc/theid/say\", [\"Hello\", \"Bobby\"])\r\n    .success(console.log.bind(console)) //Everything went swimmingly!\r\n    .error(console.log.bind(console)); //{status:418, err:\"This api hates life and it wants me to hate it too.\"}\r\n```\r\nand then on the server side\r\n```javascript\r\nvar rpcify = require(\"rpcify\");\r\n\r\nvar obj = {\r\n    someData:\"Stuff\",\r\n    say:function(message, name, callback, req, res){\r\n        console.log(message, name) //\"Hello\" \"Bobby\"\r\n        console.log(this.someData) //\"Stuff\"\r\n        someAsyncFunction(function(err){\r\n            if(err){\r\n                callback({status:418, err:\"This api hates life and it wants me to hate it too.\"});\r\n            } else {\r\n                callback(null, \"Everything went swimmingly!\");\r\n            }\r\n        })\r\n    }\r\n}\r\n\r\nrpcify.wrap(\"theid\", obj, false); //If false is set as the whitelist, everything is allowed\r\n```\r\n\r\nAs per standard node convention, if the callback is invoked with a truthy value for the first element, it will treat it as the error. If you control what's getting passed back, then passing an object with {status:418, error:\"Flux overflow\"}, will set the http status code to 418. Otherwise, if there's an error and no status code provided, it wil default to 400.\r\n\r\n##Sync\r\nIf you're unusually lucky, and you only need to hit syncronous server side functions, you can use:\r\n\r\n```javascript\r\nrpcify.wrap({id:\"theid\", obj:obj, whitelist:false, async:false});\r\n//or\r\nrpcify.wrap(\"theid\", obj, false, false);\r\n\r\n//and our say function becomes:\r\nsay:function(message, name, req, res){\r\n    console.log(message, name) //\"Hello\" \"Bobby\"\r\n    console.log(this.someData) //\"Stuff\"\r\n    var result = someSyncFunction();\r\n\r\n    if(!result){\r\n        throw new Error({status:418, err:\"This api hates life and it wants me to hate it too.\"});\r\n    } else {\r\n        return \"Everything went swimmingly!\";\r\n    }\r\n}\r\n```\r\n\r\nThe function will be called with a standard try catch, and the callback won't be passed.\r\n\r\n##Data\r\nIf you also want to be able to hit the data on your objects (although at this point, I don't know why you wouldn't just have it client side. But hey, there's unexpected use cases for everything).\r\n\r\n```javascript\r\nrpcify.wrap({id:\"theid\", obj:obj, whitelist:false, async:true, data:true});\r\n//or\r\nrpcify.wrap(\"theid\", obj, true, true);\r\n\r\n$http.post(address + \"/rpc/theid/someData\")\r\n.success(console.log.bind(console))         //\"Stuff\"\r\n```","created":"2015-08-28T05:28:32.985Z","modified":"2015-08-28T06:39:42.453Z","lastPublisher":{"name":"brightide","email":"rilljit@gmail.com"},"owners":[{"name":"brightide","email":"rilljit@gmail.com"}],"other":{"_attachments":{},"_from":".","_id":"rpcify","_nodeVersion":"0.12.0","_npmUser":{"name":"brightide","email":"rilljit@gmail.com"},"_npmVersion":"2.5.1","_rev":"1-06c9d538d97c58396b26e2510fa167e6","_shasum":"b39b23d6dedf50bb36bfc823341845bf9aade8ae","author":{"name":"Jarred Filmer"},"bugs":{"url":"https://github.com/BrighTide/rpcify/issues"},"directories":{},"dist-tags":{"latest":"0.0.2"},"dist":{"shasum":"b39b23d6dedf50bb36bfc823341845bf9aade8ae","tarball":"http://registry.npmjs.org/rpcify/-/rpcify-0.0.2.tgz"},"maintainers":[{"name":"brightide","email":"rilljit@gmail.com"}],"readmeFilename":"README.md","time":{"modified":"2015-08-28T06:39:42.453Z","created":"2015-08-28T05:28:32.985Z","0.0.1":"2015-08-28T05:28:32.985Z","0.0.2":"2015-08-28T06:39:42.453Z"}}}