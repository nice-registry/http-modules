{"name":"jsonapitest","version":"0.0.37","repository":"https://github.com/peter/jsonapitest","description":"JSON driven testing of HTTP APIs","main":"index.js","bin":{"jsonapitest":"./index.js"},"scripts":{"test":"./bin/test","test-unit":"./bin/test-unit","test-integration":"./bin/test-integration"},"license":"ISC","dependencies":{"assert-duck-type":"^0.0.2","async":"^0.8.0","z-schema":"3.17.0","lodash":"^2.4.1","request":"^2.36.0","superagent":"^0.18.0"},"devDependencies":{"mocha":"^1.20.1","mocha-lcov-reporter":"^0.0.1","coveralls":"^2.11.2","istanbul":"^0.3.2"},"gitHead":"3fb81693ac43bb4b91bffe24965c845c891e2a95","homepage":"https://github.com/peter/jsonapitest#readme","versions":[{"number":"0.0.0","date":"2014-06-05T10:49:44.515Z"},{"number":"0.0.1","date":"2014-06-10T12:11:28.891Z"},{"number":"0.0.2","date":"2014-06-11T14:41:43.950Z"},{"number":"0.0.3","date":"2014-06-17T18:02:50.171Z"},{"number":"0.0.4","date":"2014-06-19T20:52:51.406Z"},{"number":"0.0.5","date":"2014-06-29T22:22:04.897Z"},{"number":"0.0.6","date":"2014-06-30T12:46:37.147Z"},{"number":"0.0.7","date":"2014-07-01T15:26:24.347Z"},{"number":"0.0.8","date":"2014-07-24T09:25:29.684Z"},{"number":"0.0.9","date":"2014-07-31T08:22:22.684Z"},{"number":"0.0.10","date":"2014-10-21T12:12:23.918Z"},{"number":"0.0.11","date":"2014-10-22T12:56:40.228Z"},{"number":"0.0.12","date":"2014-10-22T14:48:27.910Z"},{"number":"0.0.13","date":"2014-10-22T15:03:53.829Z"},{"number":"0.0.14","date":"2014-10-23T09:21:30.314Z"},{"number":"0.0.15","date":"2014-11-04T14:53:08.417Z"},{"number":"0.0.16","date":"2014-11-08T20:37:06.515Z"},{"number":"0.0.17","date":"2014-11-10T08:49:14.538Z"},{"number":"0.0.18","date":"2014-11-11T08:59:13.265Z"},{"number":"0.0.19","date":"2014-11-12T22:28:32.046Z"},{"number":"0.0.20","date":"2014-11-13T08:32:43.829Z"},{"number":"0.0.21","date":"2014-11-13T12:43:41.103Z"},{"number":"0.0.22","date":"2014-11-13T14:58:18.796Z"},{"number":"0.0.23","date":"2014-11-13T15:42:06.744Z"},{"number":"0.0.24","date":"2014-11-16T19:57:50.557Z"},{"number":"0.0.25","date":"2014-11-17T10:00:05.983Z"},{"number":"0.0.26","date":"2014-11-18T16:33:59.344Z"},{"number":"0.0.27","date":"2014-11-23T12:09:27.198Z"},{"number":"0.0.28","date":"2014-11-24T06:54:16.059Z"},{"number":"0.0.29","date":"2014-11-24T11:28:51.335Z"},{"number":"0.0.30","date":"2014-11-24T20:03:22.704Z"},{"number":"0.0.31","date":"2014-11-25T16:05:26.238Z"},{"number":"0.0.32","date":"2014-11-28T12:18:58.370Z"},{"number":"0.0.33","date":"2014-12-03T16:07:11.075Z"},{"number":"0.0.34","date":"2014-12-04T20:18:07.414Z"},{"number":"0.0.35","date":"2014-12-10T03:03:43.830Z"},{"number":"0.0.36","date":"2016-07-23T05:06:18.211Z"},{"number":"0.0.37","date":"2016-07-31T06:06:29.825Z"}],"readme":"[![Build Status](https://travis-ci.org/peter/jsonapitest.svg?branch=master)](https://travis-ci.org/peter/jsonapitest)\n[![Code Climate](https://codeclimate.com/github/peter/jsonapitest.png)](https://codeclimate.com/github/peter/jsonapitest)\n[![Badge](https://coveralls.io/repos/peter/jsonapitest/badge.png?branch=master)](https://coveralls.io/r/peter/jsonapitest)\n\n# JSON API Test\n\nJSON driven testing of REST APIs.\n\nThis is a test framework targeted at JSON REST APIs. It comes in the form of a Node.js package called `jsonapitest`\nthat is available on the command line to run your tests. Tests are specified in JSON or JavaScript files and grouped into\ntest suites. Each test contains a list of API calls with assertions. The framework supports using JSON Schema\nto validate the structure of responses. All HTTP traffic is logged extensively\nby the test runner to help debug test failures. Any data (database records, user credentials etc.) that the tests\nneed are specified in JSON format and is easily interpolated into API calls. You can extend and customize\nthe framework with your own assertion functions, HTTP client, or logger.\n\n## Table of Contents\n\n* [Motivation](#motivation)\n* [Installation](#installation)\n* [Usage](#usage)\n* [Test File Structure](#test-file-structure)\n* [JavaScript instead of JSON](#javascript-instead-of-json)\n* [The Anatomy of Test Files](#the-anatomy-of-test-files)\n* [Config](#config)\n* [Data](#data)\n* [Suite](#suite)\n* [API Call](#api-call)\n* [Pending Tests](#pending-tests)\n* [HTTP Clients](#http-clients)\n* [Request](#request)\n* [Response](#response)\n* [Select](#select)\n* [Assert](#assert)\n* [Custom Assert Functions](#custom-assert-functions)\n* [Status Assertions](#status-assertions)\n* [Assert: schema](#assert-schema)\n* [Assert: equal](#assert-equal)\n* [Assert: equal_keys](#assert-equal_keys)\n* [Assert: contains](#assert-contains)\n* [Assert: contains_keys](#assert-contains_keys)\n* [Assert: size](#assert-size)\n* [Assert: Inline JavaScript](#assert-inline-javascript)\n* [Assert: type](#assert-type)\n* [Saving Data](#saving-data)\n* [Data Interpolation](#data-interpolation)\n* [Merging Objects](#merging-objects)\n* [Logging](#logging)\n* [Callbacks](#callbacks)\n\n## Motivation\n\nI had a REST API implemented in Node.js and I started out writing my API tests with Mocha and Supertest. Although this approach worked\nI ended up with test code that was time consuming and complex. Also, I didn't like the fact that my\ntests were coupled to the implementation of the API. I tried doing some semi automated testing with curl and although I appreciate the simplicity\nof curl the approach wasn't sufficiently structured and automated. What I was looking for was a declarative and black-box\nway to do API testing. Here are a few selling points for `jsonapitest`:\n\n* Black box testing of APIs means the tests are not tied to the implementation behind the API (i.e. programming language, database etc.)\n* Black box testing will encourage you to design more complete and user friendly APIs (since you cannot easily get at the implementation behind the API)\n* By having test definitions be simple and pure data structures you are not tied to any particular test framework implementation. This means the test runner, the http client and the assertion engine could all be re-implemented and swapped out fairly easily.\n* The fact that you are constrainted to a simple JSON structure for tests will help keep your tests dumb and devoid of complicated logic. This makes test maintenance easier.\n* Since test specifications are pure data they lend themselves well to building for example a testing UI or API documentation.\n* Debugging is helped by the verbose logging of all HTTP requests and responses (this log is also in JSON format)\n* It's easy to point the test runner at different environments (i.e. a test, development or staging server)\n\n## Installation\n\n```\nnpm install jsonapitest -g\n```\n\n## Usage\n\nSpecify your test in a JSON file:\n\n```json\n{\n  \"config\": {\n    \"defaults\": {\n      \"api_call\": {\n        \"request\": {\n          \"base_url\": \"https://api.some-hostname.com\"\n        }\n      }\n    }\n  },\n  \"data\": {\n    \"schema\": {\n      \"user\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\"type\": \"integer\"},\n          \"name\": {\"type\": \"string\"},\n          \"email\": {\"type\": \"string\", \"format\": \"email\"}\n        }\n      }\n    },\n    \"users\": {\n      \"member\": {\n        \"id\":1,\n        \"email\":\"joe@example.com\"\n      }\n  \t}\n  },\n  \"suites\": [\n  \t{\n  \t\t\"name\": \"users\",\n    \t\"tests\": [\n\t      {\n\t        \"name\": \"get_user_success\",\n\t        \"description\": \"Fetch info about a user\",\n\t        \"api_calls\": [\n\t          {\n\t            \"request\": \"/v1/users/{{users.member.id}}\",\n              \"status\": 200,\n\t            \"assert\": {\n\t              \"select\": \"body\",\n\t              \"schema\": \"{{schema.user}}\",\n\t              \"equal_keys\": {\n\t                \"id\": \"{{users.member.id}}\",\n\t                \"email\": \"{{users.member.email}}\"\n\t              }\n\t            }\n\t          }\n\t        ]\n\t      },\n\t      {\n\t        \"name\": \"get_user_missing\",\n\t        \"description\": \"Trying to fetch info about a user that doesn't exist\",\n\t        \"api_calls\": [\n\t          {\n\t            \"request\": \"/v1/users/99999999\",\n\t            \"status\": 404\n\t          }\n\t        ]\n\t      }\n    \t]\n  \t}\n  ]\n}\n```\n\nRun it:\n\n```\njsonapitest path-to-your-test-file.json\n```\n\nCheck out the [Parse CRUD example](doc/examples/parse/README.md) for more sample code.\n\n## Test File Structure\n\nTests are written in one or more JSON or JavaScript files and you may choose any file structure you like.\nWith a small test case you may want to put all test code in a single file. A more typical\nstructure is to divide your test code into three sets of files: configuration, data, and test suites.\nHere is an example:\n\n```\ntest/api/config.json\ntest/api/data.json\ntest/api/users_test.json\ntest/api/articles_test.json\n```\n\nHere config.json will contain the configuration, data.json the data, users_test.json the\ntest suite for users, and articles_test.json the test suite for articles. To run the tests:\n\n```\njsonapitest test/api/config.json test/api/data.json test/api/users_test.json test/api/articles_test.json\n```\n\nOr more conveniently:\n\n```\njsonapitest test/api/*.json\n```\n\nThe order in which test files are given to the test runner determines the execution order of tests. Since test suites\nare supposed to be independent of eachother this typically won't affect the outcome. The order comes into play\nif you have files with overlapping config or data properties. In this case later files will take precedence over earlier ones through a deep merge of the config and data properties. An example of how this may be used is when you would like to override the\ndefault configuration or data. Suppose you usually run your tests against a local\ntest or development server but at times would like to run them against a remote staging server. You could then have\na configuration file at test/api/env/staging.json:\n\n```json\n{\n  \"config\": {\n    \"defaults\": {\n      \"api_call\": {\n        \"request\": {\n          \"base_url\": \"https://my.staging.api.example\"\n        }\n      }\n    }\n  }\n}\n```\n\nAnd run your tests against staging like so:\n\n```\njsonapitest test/api/*.json test/api/env/staging.json\n```\n\n## JavaScript instead of JSON\n\nAs a more flexible and powerful alternative to JSON you have the option of specifying your\ntest files in JavaScript intead of JSON. JavaScript files should be Node.js modules\nand `jsonapitest` will simply invoke `require` on them. Here is an example `config.js` file:\n\n```javascript\n'use strict';\n\nmodule.exports = {\n  config: {\n    defaults: {\n      api_call: {\n        request: {\n          base_url: \"https://my.staging.api.example\"\n        }\n      }\n    }\n  }\n};\n```\n\nIn addition to custom assert functions you can also write [inline javascript assertions](#assert-inline-javascript).\nWith JavaScript you also have the ability to use [regular expression equality matchers](#assert-equal).\n\n## The Anatomy of Test Files\n\nThe JSON in test files may contain one or more of the following top level properties:\n\n* [config](#configuration)\n* [data](#data)\n* [suite/suites](#suite)\n\n## Config\n\nThe config property is an optional property where you can point out the path to a log file where HTTP requests are logged,\nthe base_url of your server, and any default headers and response status of your API calls:\n\n```json\n\"config\": {\n  \"log_path\": \"log/jsonapitest-results.json\",\n  \"defaults\": {\n    \"api_call\": {\n      \"request\": {\n        \"base_url\": \"http://localhost:3001\",\n        \"headers\": {\n          \"X-API-CALL-ID\": \"{{$api_call_id}}\",\n          \"X-Token\": \"secret-api-token-goes-here\",\n          \"Accept\": \"application/json\",\n          \"Content-Type\": \"application/json\"\n        }\n      },\n      \"status\": 200\n    }\n  }\n}\n```\n\nFor the `X-API-CALL-ID` header above we are interpolating a built in variable called `$api_call_id` that will be set to a unique hex\ndigest for each API call (see more under [Data Interpolation](#data-interpolation)). This is a technique you can use to make it easier\nto find test request in your server logs.\n\n## Data\n\nThe data property is a free form custom container for any kind of data that you need for your tests, i.e. database data, user\ncredentials etc. Data is interpolated in api calls with the double curly syntax (i.e. {{my_data}}, see [Data Interpolation](#data-interpolation)).\n\nYou will most likely need to populate your database with test data before running your tests. If so any script that you write for this\nshould probably use the JSON data defined by the `data` property (i.e. database records or documents). In general its a good idea\nto write your API tests so that they make as few assumptions about the state of the system as possible. However,\nin some test scenarios you really need to know exactly what the state of the system is in order to be able to make assertions and achieve high test coverage.\nOne approach that works in some projects is to run tests against a copy of the production data with a small amount of known test data added to it. Data population is currently outside the scope of this framework.\n\n\n### Generating Unique/Random Test Data\n\nThere are two pre-defined variables that you can [interpolate](#data-interpolation) into your API calls to generate unique data:\n\n* `$run_id` - a 32 character long hex digest unique to the test run\n* `$api_call_id` - a 32 character long hex digest that is unique to each API call\n\nHere is an example request that creates a new user with a unique email address:\n\n```json\n{\n  \"request\": {\n    \"method\": \"POST\",\n    \"path\": \"/v1/users\",\n    \"params\": {\n      \"name\": \"Mr New User\",\n      \"email\": \"new-user-{{$run_id}}@example.com\"\n    }\n  }\n}\n```\n\n### Environment Variables\n\nYou can interpolate environment variables into your `config` and `data` by using `$env.SOME_ENVIRONMENT_VARIABLE`.\n\n## Suite\n\nUse the suite property to define a single test suite:\n\n```json\n{\n  \"suite\": {\n    \"name\": \"users\",\n    \"description\": \"CRUD operations on the user resource\",\n    \"tests\": [\n      {\n        \"name\": \"get_user_success\",\n        \"description\": \"Fetch info about a user\",\n        \"api_calls\": [\n          {\n            \"request\": \"GET /v1/users/{{users.member.id}}\",\n            \"assert\": [{\n              \"select\": \"body\",\n              \"schema\": \"{{schema.user}}\",\n              \"equal_keys\": {\n                \"id\": \"{{users.member.id}}\",\n                \"email\": \"{{users.member.email}}\"\n              }\n            }]\n          }\n        ]\n      }\n    ]\n  }\n}\n```\n\nA test suite is made up of a name, an optional description, and an array of tests. Each test in turn has a name and an optional\ndescription and an array of api calls. To define many test suites in a single file, use the suites (plural) property and have it\npoint to an array of suite objects.\n\nA test suite is identified by its name so it needs to be unique. If your test suite grows large then a good\ntechnique is to split your suite up into multiple files. When `jsonapitest` sees a test suite in a file with a name it has already seen it will merge the two suites (i.e. treat them as one).\n\n## API Call\n\nThe API call lies at the heart of API testing and it is made up of an HTTP request and one or more assertions against the response. An API call can also save data from the HTTP response for use in later API calls.\n\nTo make the intention of API calls more obvious and help readability of tests you can use the optional properties `it` (or the property `description`) like this:\n\n```json\n{\n  \"it\": \"can GET a user of type member\",\n  \"request\": \"/v1/users/{{users.member.id}}\",\n  \"status\": 200\n}\n```\n\n## Pending Tests\n\nSometimes you want to write down the skeletons of your tests but you are not ready to execute them yet.\nFor this reason both the test and API call objects accept a `pending` boolean property.\nIf this property is set to true then the test or API call won't execute.\nAny API calls that don't have a request property will be treated as pending and not execute. Here is an example:\n\n```javascript\n{\n  suite: \"articles\",\n  tests: [\n    {\n      name: \"CRUD\",\n      api_calls: [\n        {\n          it: \"can create an article\"\n        },\n        {\n          it: \"can verify that the article exists\"\n        },\n        {\n          it: \"can update the article\"\n        },\n        {\n          it: \"can verify that the article is updated\"\n        },\n        {\n          it: \"can delete the article\"\n        },\n        {\n          it: \"can verify that the article is deleted\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n## HTTP Clients\n\nThe framework ships with adapters for two popular HTTP clients - [superagent](https://github.com/visionmedia/superagent) (default) and [request](https://github.com/mikeal/request). Here is how to configure the `request` HTTP client:\n\n```json\n\"config\": {\n  \"modules\": {\n    \"http_client\": \"./http_clients/request\"\n  }\n}\n```\n\nIn order to support a different HTTP client, all you have to do is write a simple adapter for it, see the\n[superagent](https://github.com/peter/jsonapitest/blob/master/lib/http_clients/superagent.js) and\n[request](https://github.com/peter/jsonapitest/blob/master/lib/http_clients/request.js) adapters\nfor examples of how to do this. You can either install your adapter globally as an npm package or set `config.modules.http_client`\nto the absolute file path of your adapter.\n\n## Request\n\nThe `request` property of each API call is an object with the following properties:\n\n* `method` - the HTTP verb (i.e. GET, PUT, POST, DELETE etc.). Defaults to \"GET\".\n* `path` - the path to make the request to. If a `base_url` has been configured then the `url` property will be set to the base_url joined with the path\n* `url` - specify the full URL here instead of the path if you need a URL different from the base_url\n* `headers` - custom HTTP headers\n* `params` - query or post parameters\n* `files` - an array with paths to files that will be uploaded with content type \"multipart/form-data\".\n\nThe `request` property may also be given as a string with a method and a path (or url). The `headers` and\n`params` properties may be put at the top level of the API call for convenience:\n\n```json\n{\n  \"request\": \"POST /v1/users\",\n  \"headers\": {\"X-Token\": \"secret-api-token-goes-here\"},\n  \"params\": {\"name\": \"Joe\"}\n}\n```\n\nNotice that you can also append query parameters to the path instead of using the `params` property:\n\n```json\n{\n  \"request\": \"GET /v1/users?limit=10&offset=10\"\n}\n```\n\n## Response\n\nThe following properties are available in the HTTP response object:\n\n* `status` - the response status code (an integer)\n* `headers` - a hash with HTTP headers\n* `body` - the parsed JSON body\n* `response_time` - elapsed number of milliseconds from request to response (integer)\n\n## Select\n\nSelections on the response data are used to make assertions and to [save data](#saving-data). Selections can be made\non any property of [the response](#response). A selection is made up of a nested `key` and the following optional\nproperties:\n\n* `pattern` - a regular expression\n* `limit` - limit a selected array to a number of items\n* `sort` - sort a selected array either ascending (`asc`) or descending (`desc`)\n\nSelectors with just a key can be provided as just a string:\n\n```json\n\"api_calls\": [\n  {\n    \"request\": \"/v1/users/1\",\n    \"assert\": {\n      \"select\": \"body.user.name\",\n      \"equal\": \"Joe User\"\n    }\n  }\n]\n```\n\nThe above expands to:\n\n```json\n\"api_calls\": [\n  {\n    \"request\": \"/v1/users/1\",\n    \"assert\": {\n      \"select\": {\"key\": \"body.user.name\"},\n      \"equal\": \"Joe User\"\n    }\n  }\n]\n```\n\nHere is the example with a regexp `pattern` added to it:\n\n```json\n\"api_calls\": [\n  {\n    \"request\": \"/v1/users/1\",\n    \"assert\": {\n      \"select\": {\"key\": \"body.user.name\", \"pattern\": \"\\\\w+$\"},\n      \"equal\": \"User\"\n    }\n  }\n]\n```\n\nIf the regexp contains a capturing group then that group will be the selected value:\n\n```json\n\"api_calls\": [\n  {\n    \"request\": \"/v1/users/1\",\n    \"assert\": {\n      \"select\": {\"key\": \"body.user.name\", \"pattern\": \"^\\\\w+ (\\\\w+)$\"},\n      \"equal\": \"User\"\n    }\n  }\n]\n```\n\nA nested key also works on arrays:\n\n```json\n\"api_calls\": [\n  {\n    \"request\": \"/v1/users\",\n    \"assert\": {\n      \"select\": \"body.users.name\",\n      \"equal\": [\"First User\", \"Second User\"]\n    }\n  }\n]\n```\n\nYou can use an array index to select a single item from an array:\n\n```json\n\"api_calls\": [\n  {\n    \"request\": \"/v1/users\",\n    \"assert\": {\n      \"select\": \"body.users.name.1\",\n      \"equal\": \"Second User\"\n    }\n  }\n]\n```\n\nYou can apply sorting to an array:\n\n```json\n\"api_calls\": [\n  {\n    \"request\": \"/v1/users\",\n    \"assert\": {\n      \"select\": {\"key\": \"body.users.name\", \"sort\": \"desc\"},\n      \"equal\": [\"Second User\", \"First User\"]\n    }\n  }\n]\n```\n\nYou can sort an array of objects by a property:\n\n```json\n\"api_calls\": [\n  {\n    \"request\": \"/v1/users\",\n    \"assert\": {\n      \"select\": {\"key\": \"body.users\", \"sort\": {\"order\": \"desc\", \"by\": \"name\"}},\n      \"equal\": [{\"name\": \"Second User\"}, {\"name\": \"First User\"}]\n    }\n  }\n]\n```\n\nThe sort object also supports a `type` property that you can set to \"time\" to sort by a datetime property.\n\n## Assert\n\nAn `assert` object is made up of a selection on the the response object and one ore more assertions against that selection.\nIf no selection is specified then the assertion will be made against the response body. The following assert functions are built in:\n\n* [schema](#assert-schema)\n* [equal](#assert-equal)\n* [equal_keys](#assert-equal_keys)\n* [contains](#assert-contains)\n* [contains_keys](#assert-contains_keys)\n* [size](#assert-size)\n\nEach assertion type has a logically inverted counterpart with a `not_` prefix, i.e. `not_equal`, `not_contains` etc.\n\n## Custom Assert Functions\n\nYou can provide your own assert functions to fit the needs of your application. Take a look at the built in\n[assert functions](https://github.com/peter/jsonapitest/blob/master/lib/assert_functions.js) to see what the code\nshould look like. Each assert function takes two arguments - the selected response value and the value\ngiven to the assert function property. The assert function should return `true`, `false`, or an object with an\n`error_messages` property. Custom assert functions will take precedence over built in ones so that you can override them.\nPut your assert functions in a globally installed npm package or provide an absolute file path in the config:\n\n```json\n\"config\": {\n  \"modules\": {\n    \"assert_functions\": \"/absolute/path/to/your/assert/functions/file\"\n  }\n}\n```\n\n## Status Assertions\n\nSince making assertions about the response status code is so common some syntactic sugar is provided:\n\n```json\n\"api_calls\": [\n  {\n    \"request\": \"/v1/users\",\n    \"status\": 200\n  }\n]\n```\n\nThe above expands to:\n\n```json\n\"api_calls\": [\n  {\n    \"request\": \"/v1/users\",\n    \"assert\": {\n      \"select\": \"status\",\n      \"equal\": 200\n    }\n  }\n]\n```\n\n## Assert: schema\n\nUse the `schema` property of an assert object to validate the response against a JSON schema:\n\n```json\n\"api_calls\": [\n  {\n    \"request\": \"/v1/users/1\",\n    \"assert\": {\n      \"schema\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\"type\": \"integer\"},\n          \"name\": {\"type\": \"string\"},\n          \"email\": {\"type\": \"string\"}\n        },\n        \"required\": [\"id\", \"name\", \"email\"],\n        \"additionalProperties\": false\n      }\n    }\n  }\n]\n```\n\n## Assert: equal\n\nThe `equal` assertion does deep value equality check on arrays and objects. The values `null` and `undefined` are treated as equal. For other primitive values, i.e. numbers, strings and booleans, the types are not required to match and two values are regarded as equal if their string representation is equal. If you write your test files in JavaScript and provide a RegExp object then the JSON\nrepresentation of the select will be matched against the regular expression:\n\n```javascript\n{\n  it: \"Can get jsonapitest README\",\n  request: \"GET /peter/jsonapitest\",\n  assert: {\n    equal: /this regexp should match itself/\n  }\n}\n```\n\n## Assert: equal_keys\n\nIf you would like to make assertions against only a subset of keys in the response object you can use `equal_keys` instead of `equal`. Suppose your user\nrecord has a large number of columns but you would only like to make assertions about the id and the email:\n\n```json\n{\n  \"request\": \"/v1/users/{{users.member.id}}\",\n  \"assert\": {\n    \"equal_keys\": {\n      \"id\": \"{{users.member.id}}\",\n      \"email\": \"{{users.member.email}}\"\n    }\n  }\n}\n```\n\n## Assert: contains\n\nThe `contains` assertion checks if a value is included in an array or a string.\n\n## Assert: contains_keys\n\nThe `contains_keys` assertion checks if an array includes an object that matches the specified key-value pairs. It is thus the logical combination of `contains` and `equal_keys`.\n\n```json\n{\n  \"request\": \"/v1/users\",\n  \"assert\": {\n    \"select\": \"body.users\",\n    \"contains_keys\": {\n      \"name\": \"Peter\"\n    }\n  }\n}\n```\n\n## Assert: size\n\nThe `size` assertion checks the length of an array or a string:\n\n```json\n{\n  \"request\": \"/v1/users?limit=2\",\n  \"assert\": {\n    \"select\": \"body.users\",\n    \"size\": 2\n  }\n}\n```\n\n## Assert: Inline JavaScript\n\nIf you write your test suites in JavaScript you can use inline JavaScript assertions:\n\n```javascript\n{\n  it: \"should be possible to log in with correct credentials\",\n  request: \"POST /v1/login\",\n  params: {\n    user: {\n      email: \"{{user.editor.email}}\",\n      password: \"{{user.editor.password}}\"\n    }\n  },\n  assert: function(body, headers) {\n    assert.equal(body.user.email, this.user.editor.email);\n  }\n}\n```\n\nThe inline assertion is invoked with two arguments: `body` and `headers`. The `this` object of the function will be set\nto the `data` of the test. If the inline assertion does not throw an error (i.e. an assertion error) then it is considered a success.\nSee the [parse CRUD example](doc/examples/parse/crud_test.js) for more example code.\n\n## Assert: type\n\nAs complement/alternative to schema assertions you can use type assertions from the [assert-duck-type](https://github.com/peter/assert-duck-type) library like this:\n\n```javascript\n{\n  it: \"can fetch recipe ingredients\",\n  request: \"GET /v1/recipes/123\",\n  assert: [\n    {\n      select: \"body.recipe.ingredients\",\n      size: 4,\n      type: [{_id: 'number?', name: 'string', ingredient: 'boolean'}]\n    },\n    {\n      select: \"body.recipe.ingredients.0._id\",\n      not_equal: 999999,\n      type: \"Number\"\n    }\n  ]\n}\n```\n\nAdding a question mark to a type means missing value (null/undefined) will also match.\n\nHere are a few other type examples:\n\n* `string`\n* `boolean`\n* `number`\n* `null`\n* `{\"foo\": \"string\"}`\n\n## Saving Data\n\nSometimes its useful to save data from a response for user in later API calls. In this case you can use the `save` property which takes\nan object where the keys indicate where you would like to save the data and the values are [selectors](#selecting-response-data)\n(works the same as in assertions).\n\n```json\n{\n  \"request\": {\n    \"method\": \"PUT\",\n    \"path\": \"/v1/profile\",\n    \"params\": {\n      \"name\": \"Some new cool name {{$api_call_id}}\"\n    }\n  },\n  \"save\": {\n    \"saved.update_user.name\": \"body.name\"\n  }\n}\n```\n\n## Data Interpolation\n\nData interpolation is done by embedding nested data keys in double curly braces in strings. The interpolation happens right before an API call is executed. Example:\n\n```json\n{\n  \"request\": \"/v1/news?organization_id={{organizations.test.id}}\"\n}\n```\n\nIf the embedded variable encompasses the entire string then the string will be replaced by a value with same type as the data (any of the JSON datatypes, i.e. object, array, number, string, boolean, or null). Here is an example where a string with an interpolation is replaced with an object:\n\n```json\n{\n  \"request\": \"/v1/news?organization_id={{organizations.test.id}}\",\n  \"assert\": {\n    \"equal\": \"{{organizations.test}}\"\n  }\n}\n```\n\n## Merging Objects\n\nYou can use the `$merge` special object property to merge (extend) data objects. Here is an example where an authentication header is extended with a content type:\n\n```json\n\"request\": {\n  \"method\": \"PUT\",\n  \"path\": \"/v1/profile\",\n  \"headers\": {\"$merge\": [\"{{headers.member_auth}}\", {\"Content-Type\": \"multipart/form-data\"}]},\n  \"params\": {\n    \"name\": \"Some new cool name\"\n  },\n  \"files\": {\n    \"portrait_image\": \"./test/api/files/portrait_image.jpg\"\n  }\n}\n```\n\n## Logging\n\nThe default logger prints basic request info and test results to standard output. Details about all API calls are\nlogged in JSON format to a file configured by the `config.log_path` property.\n\nIf you don't like the default logger you can plug in your own. Take a look at the [callbacks/console.js](https://github.com/peter/jsonapitest/blob/master/lib/callbacks/console.js) to see what the interface looks like:\n\n```json\n\"config\": {\n  \"modules\": {\n    \"callbacks\": \"my_logger_module\"\n  }\n}\n```\n\nThere is an experimental logger that prints curl command line equivalents of all requests. You can enable it along side\nthe default logger like so:\n\n```json\n\"config\": {\n  \"modules\": {\n    \"callbacks\": [\"./loggers/console\", \"./loggers/curl\"]\n  }\n}\n```\n\n## Callbacks\n\nLogging is implemented via a generic callback mechanism that allows you to instrument `jsonapitest`\nwith the following events:\n\n```javascript\nmodule.exports = {\n  suite: {\n    start: function(suite) {},\n    end: function(suite) {}\n  },\n  test: {\n    start: function(suite, test) {},\n    end: function(suite, test) {}\n  },\n  api_call: {\n    start: function(suite, test, apiCall) {},\n    end: function(suite, test, apiCall, err, result) {}\n  },\n  all: {\n    start: function() {},\n    end: function(success, results) {}\n  }\n};\n```\n\nThe signatures of callback functions should match those above. All callback functions are invoked with `this`\nset to the context of the test run. This means you can access/modify\ntest data via `this.data` in a callback function (i.e. for setup/teardown).\n\nCallback functions are synchronous by default. To get asynchronous invocation - add a callback argument\nto the function signature.\n\nConfigure your custom callbacks module by putting its path in `config.modules.callbacks`. Either make sure your\nmodules are installed globally with npm and provide a relative path or use an absolute path via an environment variable\nlike this:\n\n```json\n\"config\": {\n  \"modules\": {\n    \"callbacks\": [\"$env.MODULES_PATH/my_first_callback\", \"$env.MODULES_PATH/my_second_callback\"]\n  }\n}\n```\n\nMake sure your module exports an object with some or all of the functions listed above (check out [callbacks/console.js](https://github.com/peter/jsonapitest/blob/master/lib/callbacks/console.js) for an example).\n\nNote that if you add custom callbacks then you need to explicitly add the default console logger or it will disappear:\n\n```javascript\nconfig: {\n  modules: {\n    callbacks: [\"./callbacks/console\", (__dirname + '/my_callback')]\n  }\n}\n```\n","created":"2014-06-05T10:49:44.515Z","modified":"2016-07-31T06:06:29.825Z","lastPublisher":{"name":"peter_marklund","email":"peter@marklunds.com"},"owners":[{"name":"peter_marklund","email":"peter@marklunds.com"}],"other":{"_attachments":{},"_from":".","_id":"jsonapitest","_nodeVersion":"6.1.0","_npmOperationalInternal":{"host":"packages-16-east.internal.npmjs.com","tmp":"tmp/jsonapitest-0.0.37.tgz_1469945186689_0.13140946836210787"},"_npmUser":{"name":"peter_marklund","email":"peter@marklunds.com"},"_npmVersion":"3.8.6","_rev":"1-e2a4f39183a4b79ef90c30a01c124a85","_shasum":"9d741da5576201725bad5454827a403e18fd7d3e","author":{"name":"Peter Marklund"},"bugs":{"url":"https://github.com/peter/jsonapitest/issues"},"directories":{},"dist-tags":{"latest":"0.0.37"},"dist":{"shasum":"9d741da5576201725bad5454827a403e18fd7d3e","tarball":"http://registry.npmjs.org/jsonapitest/-/jsonapitest-0.0.37.tgz"},"maintainers":[{"name":"peter_marklund","email":"peter@marklunds.com"}],"readmeFilename":"README.md","time":{"modified":"2016-07-31T06:06:29.825Z","created":"2014-06-05T10:49:44.515Z","0.0.0":"2014-06-05T10:49:44.515Z","0.0.1":"2014-06-10T12:11:28.891Z","0.0.2":"2014-06-11T14:41:43.950Z","0.0.3":"2014-06-17T18:02:50.171Z","0.0.4":"2014-06-19T20:52:51.406Z","0.0.5":"2014-06-29T22:22:04.897Z","0.0.6":"2014-06-30T12:46:37.147Z","0.0.7":"2014-07-01T15:26:24.347Z","0.0.8":"2014-07-24T09:25:29.684Z","0.0.9":"2014-07-31T08:22:22.684Z","0.0.10":"2014-10-21T12:12:23.918Z","0.0.11":"2014-10-22T12:56:40.228Z","0.0.12":"2014-10-22T14:48:27.910Z","0.0.13":"2014-10-22T15:03:53.829Z","0.0.14":"2014-10-23T09:21:30.314Z","0.0.15":"2014-11-04T14:53:08.417Z","0.0.16":"2014-11-08T20:37:06.515Z","0.0.17":"2014-11-10T08:49:14.538Z","0.0.18":"2014-11-11T08:59:13.265Z","0.0.19":"2014-11-12T22:28:32.046Z","0.0.20":"2014-11-13T08:32:43.829Z","0.0.21":"2014-11-13T12:43:41.103Z","0.0.22":"2014-11-13T14:58:18.796Z","0.0.23":"2014-11-13T15:42:06.744Z","0.0.24":"2014-11-16T19:57:50.557Z","0.0.25":"2014-11-17T10:00:05.983Z","0.0.26":"2014-11-18T16:33:59.344Z","0.0.27":"2014-11-23T12:09:27.198Z","0.0.28":"2014-11-24T06:54:16.059Z","0.0.29":"2014-11-24T11:28:51.335Z","0.0.30":"2014-11-24T20:03:22.704Z","0.0.31":"2014-11-25T16:05:26.238Z","0.0.32":"2014-11-28T12:18:58.370Z","0.0.33":"2014-12-03T16:07:11.075Z","0.0.34":"2014-12-04T20:18:07.414Z","0.0.35":"2014-12-10T03:03:43.830Z","0.0.36":"2016-07-23T05:06:18.211Z","0.0.37":"2016-07-31T06:06:29.825Z"}}}