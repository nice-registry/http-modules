{"name":"scxml-test-framework","version":"1.0.2","description":"A set of SCXML tests, and an HTTP client test runner for testing against SCXML HTTP test servers.","keywords":["scxml","statecharts","w3c","javascript"],"licenses":[{"type":"Apache-2.0","url":"https://github.com/jbeard4/scxml-test-framework/blob/master/LICENSE.txt"}],"repository":[{"type":"git","url":"git://github.com/jbeard4/scxml-test-framework.git"}],"engines":{"node":">=4.2.2"},"main":"./lib/test-client","dependencies":{"cli-table":"^0.3.1","github":"^2.4.1","grunt":"^1.0.1","grunt-release":"^0.14.0","load-grunt-tasks":"^3.5.2","node-static":"^0.7.8","nopt":"^3.0.6","request":"^2.74.0","underscore":"^1.8.3"},"gitHead":"32227b7e250d2b725011f575a08530078cae1d13","scripts":{},"versions":[{"number":"0.0.1","date":"2012-04-03T01:14:45.469Z"},{"number":"1.0.1","date":"2016-08-13T06:01:07.516Z"},{"number":"1.0.2","date":"2016-08-13T06:34:36.296Z"}],"readme":"Overview\n========\n\nThe SCXML Test Framework project has two main purposes:\n\n1. To collect test cases to run against SCXML implementations. \n2. To implement a generic test runner client for a client-server, HTTP- and JSON-based SCXML testing protocol. By separating out the client test runner from the SCXML interpreter on the server, it should be possible to test various SCXML implementations in a language-agnostic way. \n\n\nSCXML Test Cases\n===============\n\nEach SCXML test case comprises a pair of documents: \n\n- an SCXML document\n- a JSON \"test script\", which defines events to send into the state machine, and the expected basic state machine configuration after processing each event\n\n\nJSON Test Script\n----------------\n\nSee test [basic/basic1.json](scxml-test-framework/blob/master/test/basic/basic1.json) for an example of the JSON test script format:\n\n```json\n{\n\t\"initialConfiguration\" : [\"a\"],\n\t\"events\" : [\n\t\t{\n\t\t\t\"event\" : { \"name\" : \"t\" },\n\t\t\t\"nextConfiguration\" : [\"b\"]\n\t\t}\n\t]\n}\n```\n\nThis test script indicates that after SCXML document [basic/basic1.scxml](scxml-test-framework/blob/master/test/basic/basic1.scxml) is loaded into the SCXML interpreter, the expected initial configuration of the state machine will be a single state with id \"a\". Next, an event with name \"t\" and no data will be dispatched on the state machine, and the resulting state machine configuration will be a single state with id \"b\".\n\nNote that the \"initialConfiguration\" and \"nextConfiguration\" properties should only contain the ids of expected *basic* states, which is to say \"initialConfiguration\" and \"nextConfiguration\" specify a \"basic configuration\", or a configuration of basic states. As a \"full configuration\", or a configuration composed of both basic and non-basic states, can be derived from a basic configuration, specifying only basic configurations in the test script can be done without leading to a loss of safety or generality.\n\nAlso note that the format of the test script assumes that each event dispatched on the state machine will trigger a single macrostep which may update the state configuration. The state machine configuration at the end of the macrostep can then be compared to an expected configuration. The testing framework explicitly does not test the intermediate state changes resulting from individual microsteps. This implies that the SCXML implementation being tested must be able to report the state configuration at the end of a macrostep in order for this testing scheme to be applied.\n\n\nDelay\n-----\n\nThe JSON test script may also specify that an event should be sent after a delay. For example, from [delayedSend/send1.json](scxml-test-framework/blob/master/test/delayedSend/send1.json):\n\n```json\n{\n\t\"initialConfiguration\" : [\"a\"],\n\t\"events\" : [\n\t\t{\n\t\t\t\"event\" : { \"name\" : \"t1\" },\n\t\t\t\"nextConfiguration\" : [\"b\"]\n\t\t},\n\t\t{\n\t\t\t\"after\" : 100,\n\t\t\t\"event\" : { \"name\" : \"t2\" },\n\t\t\t\"nextConfiguration\" : [\"d\"]\n\t\t}\n\t]\n}\n```\n\nThis test says that after SCXML document [delayedSend/send1.scxml](scxml-test-framework/blob/master/test/delayedSend/send1.scxml) is loaded, the initial configuration will contain only the state with id \"a\". After dispatching event \"t1\" on the loaded SCXML session, the next configuration will contain only state with id \"b\". The test runner will then wait 100 milliseconds, and subsequently dispatch event \"t2\" on the loaded SCXML session. The expected next configuration will contain only the state with id \"d\".\n\n\nDependency on SCION Semantics\n-----------------------------\n\nThe JSON test scripts included in this project assume a particular Statecharts semantics will be implemented by the SCXML interpreter. These semantics are currently those of the SCION project, which are documented [here](https://github.com/jbeard4/SCION/wiki/Scion-Semantics), and are not the same as the semantics specified by the Step Algorithm in the SCXML specification. The reason for this is documented [here](https://github.com/jbeard4/SCION/wiki/SCION-vs.-SCXML-Comparison). A desirable feature for this project would be to allow the test scripts to be parameterizable for different Statecharts semantics. For now the best approach to allow for alternative semantics is to fork this project and rewrite the JSON test scripts as needed.\n\n\nTest Runner Client\n==================\n\nThe SCXML Test Framework project includes a test runner client, written in JavaScript for node.js, which implements the client side of an HTTP- and JSON-based SCXML testing protocol. The SCXML interpreter implementation to be tested runs on an HTTP server, which the SCXML interpreter project should provide. This should allow various SCXML implementations to be tested in a language-agnostic way.\n\nThe test runner client can run tests sequentially or in parallel. It will exit when all tests have completed, and its exit status will be the number of tests failed or errored; thus, if all tests pass, the return status will be 0.\n\n\nInstallation\n------------\n\nThe SCXML Test Framework can be installed through npm, which is bundled with node.js:\n\n    npm install scxml-test-framework\n\nOr:\n\n    npm install git://github.com/jbeard4/scxml-test-framework.git\n\n\nUsage\n-----\n\nTo run it:\n\n    node scxml-test-framework [--test-server-url url] [--parallel] [path/to/test1.scxml [path/to/test2.scxml ...]]\n\nFor example, to run the client on all tests included in this project in parallel against the SCXML test server running on localhost:9000 (in the bash shell):\n\n    node scxml-test-framework --test-server-url localhost:9000 --parallel test/*/*.scxml\n\nNote that each SCXML document specified should have a JSON test script in the same directory, with the same basename and a \".json\" extension. This is already done for the tests included with this project.\n\nAdditional properties:\n    \n    -v or --verbose\n    -r or --report, -r html or -r console\n\nTesting Protocol\n----------------\n\nA test case involves the following sequence of events:\n\n1. The client selects a test case, and sends the server a \"load\" event and a URL pointing to the associated SCXML document (the test client is also running a simple HTTP file server, and so is able to serve this document). \n2. The server receives request to load the SCXML document, downloads the document via an HTTP GET request, and creates a new SCXML session from the document. The server also generates a token that can be used to map subsequent client requests back to the newly-created SCXML session. The server then returns initial configuration of the SCXML session, and the generated token, to the client on the HTTP response.\n3. The client receives the server response, and compares the returned initial configuration to the expected initial configuration specified in the test script. \n4. For each event and expected configuration in JSON test script:\n    1. The client sends event to server. Each event is sent along with SCXML session token. \n    2. The server receives the event and token, and uses the token to retrieve SCXML session. The server then dispatches the received event on the SCXML session, and returns the new SCXML session configuration to the client on the HTTP response. \n    3. The client receives the new configuration on the HTTP response and compares it to the expected configuration. If the configuration from the server matches the expected configuration, then the client will continue sending events; otherwise, the test fails.\n\n\nThe use of tokens is needed because the client may run tests in parallel, rather than sequentially, which would require multiple SCXML sessions to be loaded on the server simultaneously, and the token is thus needed to distinguish them.\n\n\nHere is an example of the JSON sent over the wire when running test [basic/basic1.scxml](scxml-test-framework/blob/master/test/basic/basic1.scxml):\n\nClient request to load statechart.\n\n```json\n    {\n        \"load\":\"http://localhost:9999/test/basic/basic1.scxml\"\n    }\n```\n\nServer response with token and initial configuration\n\n```json\n    {\n        \"sessionToken\" : 1,\n        \"nextConfiguration\" : [\"a\"]\n    }\n```\n\nClient request to send event to statechart associated with token 1\n\n```json\n    {\n        \"event\" : { \"name\" : \"t\" },\n        \"sessionToken\" : 1 \n    }\n```\n\nServer response with next state configuration\n\n```json\n    {\n        \"nextConfiguration\" : [\"b\"]\n    }\n```\n\nServer Implementation\n--------------------\n\nThe following are examples of SCXML test server implementations:\n* [JavaScript (node.js)](https://github.com/jbeard4/SCION/blob/master/test/node-test-server.js)\n* [JavaScript (Rhino)](https://github.com/jbeard4/SCION/blob/master/test/rhino-test-server.js)\n* [Python](https://github.com/jbeard4/pySCION/blob/master/test/test-server.py)\n* [C#](https://github.com/jbeard4/SCION.NET/blob/master/test/TestServer.cs)\n\n\nNode.JS API\n===========\n\n```javascript\nfunction startTests(options, done){}\n```\n\noptions:\n\n  * file-server-port\n  * file-server-host\n  * test-server-url\n  * parallel\n  * verbose\n  * report\n  * issues\n  * scxmlTestFiles\n","created":"2012-04-03T01:14:43.957Z","modified":"2016-08-13T06:34:36.296Z","lastPublisher":{"name":"jbeard","email":"jbeard4@cs.mcgill.ca"},"owners":[{"name":"jbeard","email":"jbeard4@cs.mcgill.ca"}],"other":{"_attachments":{},"_from":".","_id":"scxml-test-framework","_nodeVersion":"4.2.2","_npmOperationalInternal":{"host":"packages-12-west.internal.npmjs.com","tmp":"tmp/scxml-test-framework-1.0.2.tgz_1471070073968_0.9797162860631943"},"_npmUser":{"name":"jbeard","email":"jbeard4@cs.mcgill.ca"},"_npmVersion":"2.14.7","_rev":"1-36df4715d39cd80afffeebc53a1e8a8c","_shasum":"7f0553c4bf666b9c9b9be8bbeade74cac26bd49c","bugs":{"url":"https://github.com/jbeard4/scxml-test-framework/issues","email":"jbeard4@cs.mcgill.ca"},"directories":{},"dist-tags":{"latest":"1.0.2"},"dist":{"shasum":"7f0553c4bf666b9c9b9be8bbeade74cac26bd49c","tarball":"http://registry.npmjs.org/scxml-test-framework/-/scxml-test-framework-1.0.2.tgz"},"maintainers":[{"name":"jbeard","email":"jbeard4@cs.mcgill.ca"}],"readmeFilename":"README.md","time":{"modified":"2016-08-13T06:34:36.296Z","created":"2012-04-03T01:14:43.957Z","0.0.1":"2012-04-03T01:14:45.469Z","1.0.1":"2016-08-13T06:01:07.516Z","1.0.2":"2016-08-13T06:34:36.296Z"}}}