{"name":"http-mitm-proxy","version":"0.5.2","description":"HTTP Man In The Middle (MITM) Proxy","main":"index.js","scripts":{"test":"mocha"},"repository":"https://github.com/joeferner/node-http-mitm-proxy","bin":{"http-mitm-proxy":"./bin/mitm-proxy.js"},"keywords":["mitm","http","https","ssl","websocket","proxy"],"license":"MIT","devDependencies":{"mocha":"^3.1.2","request":"^2.75.0","node-static":"^0.7.9"},"dependencies":{"async":"^2.1.5","mkdirp":"^0.5.1","node-forge":"^0.7.0","optimist":"^0.6.1","semaphore":"^1.0.5","ws":"^2.2.0"},"gitHead":"d2e32ec7dfa1314d3eee4553ff7d2efdc5de8820","homepage":"https://github.com/joeferner/node-http-mitm-proxy#readme","versions":[{"number":"0.0.1","date":"2015-11-10T16:11:53.071Z"},{"number":"0.0.2","date":"2015-11-18T19:16:59.054Z"},{"number":"0.1.0","date":"2015-11-23T15:11:50.916Z"},{"number":"0.2.0","date":"2015-12-02T13:11:41.867Z"},{"number":"0.3.0","date":"2016-02-03T13:11:42.986Z"},{"number":"0.4.0","date":"2016-03-07T13:34:03.594Z"},{"number":"0.5.0","date":"2016-05-21T10:46:44.783Z"},{"number":"0.5.1","date":"2016-06-25T15:57:55.035Z"},{"number":"0.5.2","date":"2017-03-16T00:56:51.817Z"}],"readme":"# HTTP MITM Proxy\n\nHTTP Man In The Middle (MITM) Proxy written in node.js. Supports capturing and modifying the request and response data.\n\n[![](https://david-dm.org/joeferner/node-http-mitm-proxy.svg)](https://david-dm.org/joeferner/node-http-mitm-proxy)\n[![Build Status](https://travis-ci.org/joeferner/node-http-mitm-proxy.svg?branch=master)](https://travis-ci.org/joeferner/node-http-mitm-proxy)\n\n\n# Install\n\n`npm install --save http-mitm-proxy`\n\n# Example\n\nThis example will modify any search results coming from google and replace all the result titles with \"Pwned!\".\n\n```javascript\nvar Proxy = require('http-mitm-proxy');\nvar proxy = Proxy();\n\nproxy.onError(function(ctx, err) {\n  console.error('proxy error:', err);\n});\n\nproxy.onRequest(function(ctx, callback) {\n  if (ctx.clientToProxyRequest.headers.host == 'www.google.com'\n    && ctx.clientToProxyRequest.url.indexOf('/search') == 0) {\n    ctx.use(Proxy.gunzip);\n\n    ctx.onResponseData(function(ctx, chunk, callback) {\n      chunk = new Buffer(chunk.toString().replace(/<h3.*?<\\/h3>/g, '<h3>Pwned!</h3>'));\n      return callback(null, chunk);\n    });\n  }\n  return callback();\n});\n\nproxy.listen({port: 8081});\n```\n\nYou can find more examples in the [examples directory](https://github.com/joeferner/node-http-mitm-proxy/tree/master/examples)\n\n# SSL\n\nUsing node-forge allows the automatic generation of SSL certificates within the proxy. After running your app you will find options.sslCaDir + '/certs/ca.pem' which can be imported to your browser, phone, etc.\n\n# API\n\n## Proxy\n * [listen(options)](#proxy_listen)\n * [close](#proxy_close)\n * [onError(fn)](#proxy_onError)\n * [onCertificateRequired](#proxy_onCertificateRequired)\n * [onCertificateMissing](#proxy_onCertificateMissing)\n * [onRequest(fn)](#proxy_onRequest)\n * [onRequestData(fn)](#proxy_onRequestData)\n * [onRequestEnd(fn)](#proxy_onRequestEnd)\n * [onResponse(fn)](#proxy_onResponse)\n * [onResponseData(fn)](#proxy_onResponseData)\n * [onResponseEnd(fn)](#proxy_onResponseEnd)\n * [onWebSocketConnection(fn)](#proxy_onWebSocketConnection)\n * [onWebSocketSend(fn)](#proxy_onWebSocketSend)\n * [onWebSocketMessage(fn)](#proxy_onWebSocketMessage)\n * [onWebSocketFrame(fn)](#proxy_onWebSocketFrame)\n * [onWebSocketError(fn)](#proxy_onWebSocketError)\n * [onWebSocketClose(fn)](#proxy_onWebSocketClose)\n * [use(fn)](#proxy_use)\n\n## Context\n\n Context functions only effect the current request/response. For example you may only want to gunzip requests\n made to a particular host.\n\n * isSSL: boolean,\n * clientToProxyRequest: [IncomingMessage](https://nodejs.org/api/http.html#http_http_incomingmessage),\n * proxyToClientResponse: [ServerResponse](https://nodejs.org/api/http.html#http_class_http_serverresponse),\n * proxyToServerRequest: [ClientRequest](https://nodejs.org/api/http.html#http_class_http_clientrequest),\n * serverToProxyResponse: [IncomingMessage](https://nodejs.org/api/http.html#http_http_incomingmessage),\n * [onError(fn)](#proxy_onError)\n * [onRequest(fn)](#proxy_onRequest)\n * [onRequestData(fn)](#proxy_onRequestData)\n * [onRequestEnd(fn)](#proxy_onRequestEnd)\n * [addRequestFilter(fn)](#context_addRequestFilter)\n * [onResponse(fn)](#proxy_onResponse)\n * [onResponseData(fn)](#proxy_onResponseData)\n * [onResponseEnd(fn)](#proxy_onResponseEnd)\n * [addResponseFilter(fn)](#context_addResponseFilter)\n * [use(mod)](#proxy_use)\n\n## WebSocket Context\n\nThe context available in websocket handlers is a bit different\n\n * isSSL: boolean,\n * clientToProxyWebSocket: [WebSocket](https://github.com/websockets/ws/blob/master/doc/ws.md#class-wswebsocket),\n * proxyToServerWebSocket: [WebSocket](https://github.com/websockets/ws/blob/master/doc/ws.md#class-wswebsocket),\n * [onWebSocketConnection(fn)](#proxy_onWebSocketConnection)\n * [onWebSocketSend(fn)](#proxy_onWebSocketSend)\n * [onWebSocketMessage(fn)](#proxy_onWebSocketMessage)\n * [onWebSocketFrame(fn)](#proxy_onWebSocketFrame)\n * [onWebSocketError(fn)](#proxy_onWebSocketError)\n * [onWebSocketClose(fn)](#proxy_onWebSocketClose)\n * [use(mod)](#proxy_use)\n\n<a name=\"proxy\"/>\n## Proxy\n\n<a name=\"proxy_listen\" />\n### proxy.listen\n\nStarts the proxy listening on the given port.\n\n__Arguments__\n\n * options - An object with the following options:\n  * port - The port or named socket to listen on (default: 8080).\n  * sslCaDir - Path to the certificates cache directory (default: process.cwd() + '/.http-mitm-proxy')\n  * silent - if set to true, nothing will be written to console (default: false)\n  * keepAlive - enable [HTTP persistent connection](https://en.wikipedia.org/wiki/HTTP_persistent_connection)\n  * timeout - The number of milliseconds of inactivity before a socket is presumed to have timed out. Defaults to no timeout.\n  * httpAgent - The [http.Agent](https://nodejs.org/api/http.html#http_class_http_agent) to use when making http requests. Useful for chaining proxys. (default: internal Agent)\n  * httpsAgent - The [https.Agent](https://nodejs.org/api/https.html#https_class_https_agent) to use when making https requests. Useful for chaining proxys. (default: internal Agent)\n  * forceSNI - force use of [SNI](https://en.wikipedia.org/wiki/Server_Name_Indication) by the client. Allow node-http-mitm-proxy to handle all HTTPS requests with a single internal server.\n  * httpsPort - The port or named socket for https server to listen on. _(forceSNI must be enabled)_\n\n__Example__\n\n    proxy.listen({ port: 80 });\n\n<a name=\"proxy_close\" />\n### proxy.close\n\nStops the proxy listening.\n\n__Example__\n\n    proxy.close();\n\n<a name=\"proxy_onError\" />\n### proxy.onError(fn) or ctx.onError(fn)\n\nAdds a function to the list of functions to get called if an error occures.\n\n__Arguments__\n\n * fn(ctx, err, errorKind) - The function to be called on an error.\n\n__Example__\n\n    proxy.onError(function(ctx, err, errorKind) {\n      // ctx may be null\n      var url = (ctx && ctx.clientToProxyRequest) ? ctx.clientToProxyRequest.url : \"\";\n      console.error(errorKind + ' on ' + url + ':', err);\n    });\n\n<a name=\"proxy_onCertificateRequired\" />\n### proxy.onCertificateRequired = function(hostname, callback)\n\nAllows the default certificate name/path computation to be overwritten.\n\nThe default behavior expects `keys/{hostname}.pem` and `certs/{hostname}.pem` files to be at `self.sslCaDir`.\n\n__Arguments__\n\n * hostname - Requested hostname.\n * callback - The function to be called when certificate files' path were already computed.\n\n__Example 1__\n\n    proxy.onCertificateRequired = function(hostname, callback) {\n      return callback(null, {\n        keyFile: path.resolve('/ca/certs/', hostname + '.key'),\n        certFile: path.resolve('/ca/certs/', hostname + '.crt')\n      });\n    };\n\n__Example 2: Wilcard certificates__\n\n    proxy.onCertificateRequired = function(hostname, callback) {\n      return callback(null, {\n        keyFile: path.resolve('/ca/certs/', hostname + '.key'),\n        certFile: path.resolve('/ca/certs/', hostname + '.crt'),\n        hosts: [\"*.mydomain.com\"]\n      });\n    };\n\n\n<a name=\"proxy_onCertificateMissing\" />\n### proxy.onCertificateMissing = function(ctx, files, callback)\n\nAllows you to handle missing certificate files for current request, for example, creating them on the fly.\n\n__Arguments__\n\n* ctx - Context with the following properties\n * hostname - The hostname which requires certificates\n * data.keyFileExists - Whether key file exists or not\n * data.certFileExists - Whether certificate file exists or not\n* files - missing files names (`files.keyFile`, `files.certFile` and optional `files.hosts`)\n* callback - The function to be called to pass certificate data back (`keyFileData` and `certFileData`)\n\n__Example 1__\n\n    proxy.onCertificateMissing = function(ctx, files, callback) {\n      console.log('Looking for \"%s\" certificates',   ctx.hostname);\n      console.log('\"%s\" missing', ctx.files.keyFile);\n      console.log('\"%s\" missing', ctx.files.certFile);\n\n      // Here you have the last chance to provide certificate files data\n      // A tipical use case would be creating them on the fly\n      //\n      // return callback(null, {\n      //   keyFileData: keyFileData,\n      //   certFileData: certFileData\n      // });\n      };\n\n__Example 2: Wilcard certificates__\n\n    proxy.onCertificateMissing = function(ctx, files, callback) {\n      return callback(null, {\n        keyFileData: keyFileData,\n        certFileData: certFileData,\n        hosts: [\"*.mydomain.com\"]\n      });\n    };\n\n\n<a name=\"proxy_onRequest\" />\n### proxy.onRequest(fn) or ctx.onRequest(fn)\n\nAdds a function to get called at the beginning of a request.\n\n__Arguments__\n\n * fn(ctx, callback) - The function that gets called on each request.\n\n__Example__\n\n    proxy.onRequest(function(ctx, callback) {\n      console.log('REQUEST:', ctx.clientToProxyRequest.url);\n      return callback();\n    });\n\n<a name=\"proxy_onRequestData\" />\n### proxy.onRequestData(fn) or ctx.onRequestData(fn)\n\nAdds a function to get called for each request data chunk (the body).\n\n__Arguments__\n\n * fn(ctx, chunk, callback) - The function that gets called for each data chunk.\n\n__Example__\n\n    proxy.onRequestData(function(ctx, chunk, callback) {\n      console.log('REQUEST DATA:', chunk.toString());\n      return callback(null, chunk);\n    });\n\n<a name=\"proxy_onRequestEnd\" />\n### proxy.onRequestEnd(fn) or ctx.onRequestEnd(fn)\n\nAdds a function to get called when all request data (the body) was sent.\n\n__Arguments__\n\n * fn(ctx, callback) - The function that gets called when all request data (the body) was sent.\n\n__Example__\n\n    var chunks = [];\n    \n    proxy.onRequestData(function(ctx, chunk, callback) {\n      chunks.push(chunk);\n      return callback(null, chunk);\n    });\n\n    proxy.onRequestEnd(function(ctx, callback) {\n      console.log('REQUEST END', (Buffer.concat(chunks)).toString());\n      return callback();\n    });\n\n<a name=\"proxy_onResponse\" />\n### proxy.onResponse(fn) or ctx.onResponse(fn)\n\nAdds a function to get called at the beginning of the response.\n\n__Arguments__\n\n * fn(ctx, callback) - The function that gets called on each response.\n\n__Example__\n\n    proxy.onResponse(function(ctx, callback) {\n      console.log('BEGIN RESPONSE');\n      return callback();\n    });\n\n<a name=\"proxy_onResponseData\" />\n### proxy.onResponseData(fn) or ctx.onResponseData(fn)\n\nAdds a function to get called for each response data chunk (the body).\n\n__Arguments__\n\n * fn(ctx, chunk, callback) - The function that gets called for each data chunk.\n\n__Example__\n\n    proxy.onResponseData(function(ctx, chunk, callback) {\n      console.log('RESPONSE DATA:', chunk.toString());\n      return callback(null, chunk);\n    });\n\n<a name=\"proxy_onResponseEnd\" />\n### proxy.onResponseEnd(fn) or ctx.onResponseEnd(fn)\n\nAdds a function to get called when the proxy request to server has ended.\n\n__Arguments__\n\n * fn(ctx, callback) - The function that gets called when the proxy request to server as ended.\n\n__Example__\n\n    proxy.onResponseEnd(function(ctx, callback) {\n      console.log('RESPONSE END', chunk.toString());\n      return callback();\n    });\n\n<a name=\"proxy_onWebSocketConnection\" />\n### proxy.onWebSocketConnection(fn) or ctx.onWebSocketConnection(fn)\n\nAdds a function to get called at the beginning of websocket connection\n\n__Arguments__\n\n * fn(ctx, callback) - The function that gets called for each data chunk.\n\n__Example__\n\n    proxy.onWebSocketConnection(function(ctx, callback) {\n      console.log('WEBSOCKET CONNECT:', ctx.clientToProxyWebSocket.upgradeReq.url);\n      return callback();\n    });\n\n<a name=\"proxy_onWebSocketSend\" />\n### proxy.onWebSocketSend(fn) or ctx.onWebSocketSend(fn)\n\nAdds a function to get called for each WebSocket message sent by the client.\n\n__Arguments__\n\n * fn(ctx, message, flags, callback) - The function that gets called  for each WebSocket message sent by the client.\n\n__Example__\n\n    proxy.onWebSocketSend(function(ctx, message, flags, callback) {\n      console.log('WEBSOCKET SEND:', ctx.clientToProxyWebSocket.upgradeReq.url, message);\n      return callback(null, message, flags);\n    });\n\n<a name=\"proxy_onWebSocketMessage\" />\n### proxy.onWebSocketMessage(fn) or ctx.onWebSocketMessage(fn)\n\nAdds a function to get called for each WebSocket message received from the server.\n\n__Arguments__\n\n * fn(ctx, message, flags, callback) - The function that gets called for each WebSocket message received from the server.\n\n__Example__\n\n    proxy.onWebSocketMessage(function(ctx, message, flags, callback) {\n      console.log('WEBSOCKET MESSAGE:', ctx.clientToProxyWebSocket.upgradeReq.url, message);\n      return callback(null, message, flags);\n    });\n\n<a name=\"proxy_onWebSocketFrame\" />\n### proxy.onWebSocketFrame(fn) or ctx.onWebSocketFrame(fn)\n\nAdds a function to get called for each WebSocket frame exchanged (`message`, `ping` or `pong`).\n\n__Arguments__\n\n * fn(ctx, type, fromServer, data, flags, callback) - The function that gets called for each WebSocket frame exchanged.\n\n__Example__\n\n    proxy.onWebSocketFrame(function(ctx, type, fromServer, data, flags, callback) {\n      console.log('WEBSOCKET FRAME ' + type + ' received from ' + (fromServer ? 'server' : 'client'), ctx.clientToProxyWebSocket.upgradeReq.url, message);\n      return callback(null, message, flags);\n    });\n\n<a name=\"proxy_onWebSocketError\" />\n### proxy.onWebSocketError(fn) or ctx.onWebSocketError(fn)\n\nAdds a function to the list of functions to get called if an error occures in WebSocket.\n\n__Arguments__\n\n * fn(ctx, err) - The function to be called on an error in WebSocket.\n\n__Example__\n\n    proxy.onWebSocketError(function(ctx, err) {\n      console.log('WEBSOCKET ERROR:', ctx.clientToProxyWebSocket.upgradeReq.url, err);\n    });\n \n<a name=\"proxy_onWebSocketClose\" />\n### proxy.onWebSocketClose(fn) or ctx.onWebSocketClose(fn)\n\nAdds a function to get called when a WebSocket connection is closed\n\n__Arguments__\n\n * fn(ctx, code, message, callback) - The function that gets when a WebSocket is closed.\n\n__Example__\n\n    proxy.onWebSocketClose(function(ctx, code, message, callback) {\n      console.log('WEBSOCKET CLOSED BY '+(ctx.closedByServer ? 'SERVER' : 'CLIENT'), ctx.clientToProxyWebSocket.upgradeReq.url, code, message);\n      callback(null, code, message);\n    });\n\n<a name=\"proxy_use\" />\n### proxy.use(module) or ctx.use(module)\n\nAdds a module into the proxy. Modules encapsulate multiple life cycle processing functions into one object.\n\n__Arguments__\n\n * module - The module to add. Modules contain a hash of functions to add.\n\n__Example__\n\n    proxy.use({\n      onError: function(ctx, err) { },\n      onCertificateRequired: function(hostname, callback) { return callback(); },\n      onCertificateMissing: function(ctx, files, callback) { return callback(); },\n      onRequest: function(ctx, callback) { return callback(); },\n      onRequestData: function(ctx, chunk, callback) { return callback(null, chunk); },\n      onResponse: function(ctx, callback) { return callback(); },\n      onResponseData: function(ctx, chunk, callback) { return callback(null, chunk); },\n      onWebSocketConnection: function(ctx, callback) { return callback(); },\n      onWebSocketSend: function(ctx, message, flags, callback) { return callback(null, message, flags); },\n      onWebSocketMessage: function(ctx, message, flags, callback) { return callback(null, message, flags); },\n      onWebSocketError: function(ctx, err) {  },\n      onWebSocketClose: function(ctx, code, message, callback) {  },\n    });\n\nnode-http-mitm-proxy provide some ready to use modules:\n- `Proxy.gunzip` Gunzip response filter (uncompress gzipped content before onResponseData and compress back after)\n- `Proxy.wildcard` Generates wilcard certificates by default (so less certificates are generated)\n\n<a name=\"context\"/>\n## Context\n\n<a name=\"context_addRequestFilter\" />\n### ctx.addRequestFilter(stream)\n\nAdds a stream into the request body stream.\n\n__Arguments__\n\n * stream - The read/write stream to add in the request body stream.\n\n__Example__\n\n    ctx.addRequestFilter(zlib.createGunzip());\n\n<a name=\"context_addRequestFilter\" />\n### ctx.addResponseFilter(stream)\n\nAdds a stream into the response body stream.\n\n__Arguments__\n\n * stream - The read/write stream to add in the response body stream.\n\n__Example__\n\n    ctx.addResponseFilter(zlib.createGunzip());\n\n# License\n\n```\nCopyright (c) 2015 Joe Ferner\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\n\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\n\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n```\n\n","starsCount":2,"created":"2015-11-10T16:11:53.071Z","modified":"2017-04-12T21:28:01.600Z","lastPublisher":{"name":"joeferner","email":"joe@fernsroth.com"},"owners":[{"name":"joeferner","email":"joe@fernsroth.com"}],"other":{"_attachments":{},"_from":".","_id":"http-mitm-proxy","_nodeVersion":"7.2.0","_npmOperationalInternal":{"host":"packages-18-east.internal.npmjs.com","tmp":"tmp/http-mitm-proxy-0.5.2.tgz_1489625811016_0.24843292753212154"},"_npmUser":{"name":"joeferner","email":"joe@fernsroth.com"},"_npmVersion":"3.10.9","_rev":"4-da98fd22afe35c0847a77b0dba6437aa","_shasum":"16805f674a4fbe339c701c944258766fc970711d","author":{"name":"Joe Ferner","email":"joe@fernsroth.com"},"bugs":{"url":"https://github.com/joeferner/node-http-mitm-proxy/issues"},"contributors":[{"name":"Félicien François","email":"felicien@tweakstyle.com"},{"name":"Simon Pratt","email":"simon@pr4tt.com"}],"directories":{},"dist-tags":{"latest":"0.5.2"},"dist":{"shasum":"16805f674a4fbe339c701c944258766fc970711d","tarball":"https://registry.npmjs.org/http-mitm-proxy/-/http-mitm-proxy-0.5.2.tgz"},"maintainers":[{"name":"joeferner","email":"joe@fernsroth.com"}],"readmeFilename":"README.md","time":{"modified":"2017-04-12T21:28:01.600Z","created":"2015-11-10T16:11:53.071Z","0.0.1":"2015-11-10T16:11:53.071Z","0.0.2":"2015-11-18T19:16:59.054Z","0.1.0":"2015-11-23T15:11:50.916Z","0.2.0":"2015-12-02T13:11:41.867Z","0.3.0":"2016-02-03T13:11:42.986Z","0.4.0":"2016-03-07T13:34:03.594Z","0.5.0":"2016-05-21T10:46:44.783Z","0.5.1":"2016-06-25T15:57:55.035Z","0.5.2":"2017-03-16T00:56:51.817Z"},"users":{"crewmoss":true,"dankle":true}}}