{"name":"bhttp","version":"1.2.4","description":"A sane HTTP client library for Node.js with Streams2 support.","main":"index.js","scripts":{"test":"echo \"Error: no test specified\" && exit 1"},"repository":"https://github.com/joepie91/node-bhttp","keywords":["http","client","multipart","stream","hyperquest","request","needle"],"license":"WTFPL","dependencies":{"bluebird":"^2.8.2","concat-stream":"^1.4.7","debug":"^2.1.1","dev-null":"^0.1.1","errors":"^0.2.0","extend":"^2.0.0","form-data2":"^1.0.0","form-fix-array":"^1.0.0","lodash":"^2.4.1","stream-length":"^1.0.2","string":"^3.0.0","through2-sink":"^1.0.0","through2-spy":"^1.2.0","tough-cookie":"^2.3.1"},"devDependencies":{"gulp":"~3.8.0","gulp-cached":"~0.0.3","gulp-coffee":"~2.0.1","gulp-concat":"~2.2.0","gulp-livereload":"~2.1.0","gulp-nodemon":"~1.0.4","gulp-plumber":"~0.6.3","gulp-remember":"~0.2.0","gulp-rename":"~1.2.0","gulp-util":"~2.2.17"},"gitHead":"6b485859b7782554d867b45748bf9ac70d086979","homepage":"https://github.com/joepie91/node-bhttp#readme","versions":[{"number":"1.0.0","date":"2015-01-23T17:27:38.179Z"},{"number":"1.0.1","date":"2015-01-23T17:42:06.806Z"},{"number":"1.0.2","date":"2015-01-24T07:15:50.533Z"},{"number":"1.0.3","date":"2015-02-22T21:18:35.837Z"},{"number":"1.0.4","date":"2015-03-17T12:10:00.474Z"},{"number":"1.1.0","date":"2015-04-08T17:48:02.578Z"},{"number":"1.1.1","date":"2015-04-09T10:11:39.885Z"},{"number":"1.1.2","date":"2015-04-09T12:00:08.280Z"},{"number":"1.1.3","date":"2015-04-27T03:32:59.087Z"},{"number":"1.2.0","date":"2015-04-27T15:07:16.565Z"},{"number":"1.2.1","date":"2015-04-27T15:33:53.907Z"},{"number":"1.2.3","date":"2016-08-16T18:23:41.702Z"},{"number":"1.2.4","date":"2016-08-16T18:44:36.021Z"}],"readme":"# bhttp\n\nA sane HTTP client library for Node.js with Streams2 support.\n\n[![](//img.shields.io/gratipay/joepie91.svg)](https://gratipay.com/joepie91)\n\n## Why bhttp?\n\nThere are already a few commonly used HTTP client libraries for Node.js, but all of them have issues:\n\n* The core `http` module is rather low-level, and even relatively simple requests take a lot of work to make correctly. It also automatically uses a limited amount of agents for HTTP requests (in Node.js 0.10), which slows down concurrent HTTP requests when you're streaming the responses somewhere.\n* `request` is buggy, only supports old-style streams, has the same 'agent' problem as `http`, the documentation is poor, and the API is not very intuitive.\n* `needle` is a lot simpler, but suffers from the same 'agent' problem, and the API can be a bit annoying in some ways. It also doesn't have a proper session API.\n* `hyperquest` (mostly) solves the 'agent' problem correctly, but has a very spartan API. Making non-GET requests is more complex than it should be.\n\nAll these issues (and more) are solved in `bhttp`. It offers the following:\n\n* A simple, well-documented API.\n* Sane default behaviour.\n* Minimal behind-the-scenes 'magic', meaning less opportunities for bugs to be introduced. No 'gotchas' in dealing with response streams either.\n* Support for `multipart/form-data` (eg. file uploads), __with support for Streams2__, and support for legacy streams.\n* Fully automatic detection of desired payload type - URL-encoded, multipart/form-data, or even a stream or Buffer directly. Just give it the data you want to send, and it will make sure it arrives correctly. Optionally, you can also specify JSON encoding (for JSON APIs).\n* Easy-to-use session mechanics - a new session will automatically give you a new cookie jar, cookies are kept track of automatically, and 'default options' are deep-merged.\n* Streaming requests are kept out of the agent pool - ie. no blocking of other requests.\n* Optionally, a Promises API (you can also use nodebacks).\n* Progress events! For both uploading and downloading.\n\n## Caveats\n\n`bhttp` does not yet use a HTTPS-capable agent. This means that all SSL-related options are currently ignored by default (per Node.js `http` documentation).\n\n__This does *not* mean that you cannot use `bhttp` for HTTPS requests!__ If you need secure HTTPS requests, just make sure to specify a [custom `https` agent](https://nodejs.org/api/https.html#https_class_https_agent).\n\n## License\n\n[WTFPL](http://www.wtfpl.net/txt/copying/) or [CC0](https://creativecommons.org/publicdomain/zero/1.0/), whichever you prefer. A donation and/or attribution are appreciated, but not required.\n\n## Donate\n\nMy income consists entirely of donations for my projects. If this module is useful to you, consider [making a donation](http://cryto.net/~joepie91/donate.html)!\n\nYou can donate using Bitcoin, PayPal, Gratipay, Flattr, cash-in-mail, SEPA transfers, and pretty much anything else.\n\n## Contributing\n\nPull requests welcome. Please make sure your modifications are in line with the overall code style, and ensure that you're editing the `.coffee` files, not the `.js` files.\n\nBuild tool of choice is `gulp`; simply run `gulp` while developing, and it will watch for changes.\n\nBe aware that by making a pull request, you agree to release your modifications under the licenses stated above.\n\n## Usage\n\nA simple example:\n\n```javascript\nvar Promise = require(\"bluebird\");\nvar bhttp = require(\"bhttp\");\n\nPromise.try(function() {\n\treturn bhttp.get(\"http://icanhazip.com/\");\n}).then(function(response) {\n\tconsole.log(\"Your IP is:\", response.body.toString());\n});\n```\n\n... or, using nodebacks:\n\n```javascript\nvar bhttp = require(\"bhttp\");\n\nbhttp.get(\"http://icanhazip.com/\", {}, function(err, response) {\n\tconsole.log(\"Your IP is:\", response.body.toString());\n});\n```\n\n### Streaming\n\nDemonstrating both streaming responses and using a stream in form data for a request:\n\n```javascript\nvar Promise = require(\"bluebird\");\nvar bhttp = require(\"bhttp\");\n\nPromise.try(function() {\n\treturn bhttp.get(\"http://somesite.com/bigfile.mp4\", {stream: true});\n}).then(function(response) {\n\treturn bhttp.post(\"http://somehostingservice.com/upload\", {\n\t\tfileOne: response,\n\t\tfileTwo: fs.createReadStream(\"./otherbigfile.mkv\")\n\t});\n}).then(function(response) {\n\tconsole.log(\"Response from hosting service:\", response.body.toString());\n});\n```\n\n... or, using nodebacks:\n\n```javascript\nvar bhttp = require(\"bhttp\");\n\nbhttp.get(\"http://somesite.com/bigfile.mp4\", {stream: true}, function(err, responseOne) {\n\tvar payload = {\n\t\tfileOne: responseOne,\n\t\tfileTwo: fs.createReadStream(\"./otherbigfile.mkv\")\n\t};\n\n\tbhttp.post(\"http://somehostingservice.com/upload\", payload, {}, function(err, responseTwo) {\n\t\tconsole.log(\"Response from hosting service:\", responseTwo.body.toString());\n\t})\n})\n```\n\n### Progress events\n\nUpload progress events:\n\n```javascript\nvar Promise = require(\"bluebird\");\nvar bhttp = require(\"bhttp\");\n\nPromise.try(function() {\n\treturn bhttp.post(\"http://somehostingservice.com/upload\", {\n\t\tfile: fs.createReadStream(\"./bigfile.mkv\")\n\t}, {\n\t\tonUploadProgress: function(completedBytes, totalBytes) {\n\t\t\tconsole.log(\"Upload progress:\", (completedBytes / totalBytes * 100), \"%\");\n\t\t}\n\t});\n}).then(function(response) {\n\tconsole.log(\"Response from hosting service:\", response.body.toString());\n});\n```\n\nDownload progress events:\n\n```javascript\nvar Promise = require(\"bluebird\");\nvar bhttp = require(\"bhttp\");\n\nPromise.try(function() {\n\treturn bhttp.get(\"http://somehostingservice.com/bigfile.mkv\", {stream: true});\n}).then(function(response) {\n\tresponse.on(\"progress\", function(completedBytes, totalBytes) {\n\t\tconsole.log(\"Download progress:\", (completedBytes / totalBytes * 100), \"%\");\n\t});\n\n\tresponse.pipe(fs.createWriteStream(\"./bigfile.mkv\"));\n});\n```\n\n### Sessions\n\n```javascript\nvar Promise = require(\"bluebird\");\nvar bhttp = require(\"bhttp\");\n\nvar session = bhttp.session({ headers: {\"user-agent\": \"MyCustomUserAgent/2.0\"} });\n\n// Our new session now automatically has a cookie jar, and also uses our preset option(s).\n\nPromise.try(function(){\n\treturn session.get(\"http://hypotheticalsite.com/cookietest\"); // Assume that this site now sets a cookie\n}).then(function(response){\n\treturn session.get(\"http://hypotheticalsite.com/other-endpoint\"); // This now sends along the cookie!\n});\n```\n\n## API\n\nThe various error types are documented at the bottom of this README.\n\n### bhttp.head(url, [options, [callback]])\n### bhttp.get(url, [options, [callback]])\n### bhttp.delete(url, [options, [callback]])\n### bhttp.post(url, [data, [options, [callback]]])\n### bhttp.put(url, [data, [options, [callback]]])\n### bhttp.patch(url, [data, [options, [callback]]])\n\nConvenience methods that pre-set the request method, and automatically send along the payload using the correct options for `bhttp.request`.\n\n* __url__: The URL to request, with protocol. When using HTTPS, please be sure to read the 'Caveats' section.\n* __data__: *Optional, only for POST/PUT/PATCH.* The payload to send along.\n* __options__: *Optional.* Extra options for the request. More details under the documentation for the `bhttp.request` method below.\n* __callback__: *Optional.* When using the nodeback API, the callback to use. If not specified, a Promise will be returned.\n\nThe `data` payload can be one of the following things:\n\n* __String / Buffer__: The contents will be written to the request as-is.\n* __A stream__: The entire stream will be written to the request as-is.\n* __An object__: Will be encoded as form data, and can contain any combination of Strings, Buffers, streams, and arrays of any of those. When only strings are used, the form data is querystring-encoded - if Buffers or streams are used, it will be encoded as multipart/form-data.\n\nFurther documentation for these methods, such as the response attributes, can be found in the below section for `bhttp.request`.\n\n### bhttp.request(url, [options, [callback]])\n\nMakes a request, and returns the response object asynchronously. The response object is a standard `http.IncomingMessages` with a few additional properties (documented below the argument list).\n\nNote that (progress) event handlers must be specified in the `options` or (in the case of download progress events) as an event listener on the response object - as `bhttp` uses Promises, it is not technically possible to return an EventEmitter.\n\n* __url__: The URL to request, with protocol. When using HTTPS, please be sure to read the 'Caveats' section.\n* __options__: *Optional.* Extra options for the request. Any other options not listed here will be passed on directly to the `http` or `https` module.\n\t* __Basic options__\n\t\t* __stream__: *Defaults to `false`.* Whether the response is meant to be streamed. If `true`, the response body won't be parsed, an unread response stream is returned, and the request is kept out of the 'agent' pool.\n\t\t* __headers__: Any extra request headers to set. (Non-custom) header names must be lowercase.\n\t\t* __followRedirects__: *Defaults to `true`.* Whether to automatically follow redirects or not (the redirect history is available as the `redirectHistory` property on the response).\n\t\t* __redirectLimit__: *Defaults to `10`.* The maximum amount of redirects to follow before erroring out, to prevent redirect loops.\n\t* __Encoding and decoding__\n\t\t* __forceMultipart__: *Defaults to `false`.* Ensures that `mulipart/form-data` encoding is used, no matter what the payload contents are.\n\t\t* __encodeJSON__: *Defaults to `false`.* When set to `true`, the request payload will be encoded as JSON. This cannot be used if you are using any streams in your payload.\n\t\t* __decodeJSON__: *Defaults to `false`.* When set to `true`, the response will always be decoded as JSON, no matter what the `Content-Type` says. You'll probably want to keep this set to `false` - most APIs send the correct `Content-Type` headers, and in those cases `bhttp` will automatically decode the response as JSON.\n\t\t* __noDecode__: *Defaults to `false`.* Never decode the response, even if the `Content-Type` says that it's JSON.\n\t* __Request payloads__ (you won't need these when using the shorthand methods)\n\t\t* __inputBuffer__: A Buffer or String to send as the entire payload.\n\t\t* __inputStream__: A stream to send as the entire payload.\n\t\t* __formFields__: Form data to encode. This can also include files to upload.\n\t\t* __files__: Form data to send explicitly as a file. This will automatically enable `multipart/form-data` encoding.\n\t* __Advanced options__\n\t\t* __method__: The request method to use. You don't need this when using the shorthand methods.\n\t\t* __cookieJar__: A custom cookie jar to use. You'll probably want to use `bhttp.session()` instead.\n\t\t* __responseTimeout__: The timeout, in milliseconds, after which the request should be considered to have failed if no response is received yet. Note that this measures from the start of the request to the start of the response, and is *not* a connection timeout. If a timeout occurs, a ResponseTimeoutError will be thrown asynchronously (see error documentation below).\n\t\t* __allowChunkedMultipart__: *Defaults to `false`.* Many servers don't support `multipart/form-data` when it is transmitted with chunked transfer encoding (eg. when the stream length is unknown), and silently fail with an empty request payload - this is why `bhttp` disallows it by default. If you are *absolutely certain* that the endpoint supports this functionality, you can override the behaviour by setting this to `true`.\n\t\t* __discardResponse__: *Defaults to `false`.* Whether to throw away the response without reading it. Only really useful for fire-and-forget calls. This is almost never what you want.\n\t\t* __keepRedirectResponses__: *Defaults to `false`.* Whether to keep the response streams of redirects. You probably don't need this. __When enabling this, you must *explicitly* read out every single redirect response, or you will experience memory leaks!__\n\t\t* __justPrepare__: *Defaults to `false`.* When set to `true`, bhttp just prepares the request, and doesn't actually carry it out; useful if you want to make some manual modifications. Instead of a response, the method will asynchronously return an array with the signature `[request, response, requestState]` that you will need to pass into the `bhttp.makeRequest()` method.\n\t* __Event handlers__\n\t\t* __onUploadProgress__: A callback to call for upload progress events (this covers both input streams and form data). The callback signature is `(completedBytes, totalBytes, request)`. If the total size is not known, `totalBytes` will be `undefined`. The `request` variable will hold the request object that the progress event applies to - this is relevant when dealing with automatic redirect following, where multiple requests may occur.\n\t\t* __onDownloadProgress__: A callback to call for download progress events. The callback signature is `(completedBytes, totalBytes, response)`. If the total size is not known, `totalBytes` will be `undefined`. The `response` variable will hold the response object that the progress event applies to - this is relevant when dealing with automatic redirect following, where multiple responses may occur. *Note that using the `progress` event on a response object is usually a more practical option!*\n\n* __callback__: *Optional.* When using the nodeback API, the callback to use. If not specified, a Promise will be returned.\n\nA few extra properties are set on the response object (which is a `http.IncomingMessage`):\n\n* __body__: When `stream` is set to `false` (the default), this will contain the response body. This can be either a Buffer or, in the case of a JSON response, a decoded JSON object.\n* __redirectHistory__: An array containing the redirect responses, if any, in chronological order. Response bodies are discarded by default; if you do not want this, use the `keepRedirectResponses` option.\n* __request__: The request configuration that was generated by `bhttp`. You probably don't need this.\n* __requestState__: The request state that was accumulated by `bhttp`. You probably don't need this.\n\nAdditionally, there's an extra event on the `response` object:\n\n* __'progress' (completedBytes, totalBytes)__: The 'download progress' for the response body. This works the same as the `onDownloadProgress` option, except the event will be specific to this response, and it allows for somewhat nicer syntax. Make sure to attach this handler *before* you start reading the response stream!\n\n`bhttp` can automatically parse the metadata for the following types of streams:\n\n* `fs` streams\n* `http` and `bhttp` responses\n* `request` requests\n* `combined-stream` streams (assuming all the underlying streams are of one of the types listed here)\n\nIf you are using a different type of stream, you can wrap the stream using `bhttp.wrapStream` to manually specify the needed metadata.\n\n### bhttp.session([defaultOptions])\n\nThis will create a new session. The `defaultOptions` will be deep-merged with the options specified for each request (where the request-specific options have priority).\n\nA new cookie jar is automatically created, unless you either specify a custom `cookieJar` option or set the `cookieJar` option to `false` (in which case no cookie jar is used).\n\n### bhttp.wrapStream(stream, options)\n\nThis will return a 'stream wrapper' containing explicit metadata for a stream. You'll need to use it when passing an unsupported type of stream to a `data` parameter or `formFields`/`files` option.\n\n* __stream__: The stream to wrap.\n* __options__: The options for this stream. All options are optional, but recommended to specify.\n\t* __contentLength__: The length of the stream in bytes.\n\t* __contentType__: The MIME type of the stream.\n\t* __filename__: The filename of the stream.\n\nThe resulting wrapper can be passed on to the `bhttp` methods as if it were a regular stream.\n\n### bhttp.makeRequest(request, response, requestState)\n\nWhen using the `justPrepare` option, you can use this method to proceed with the request after manual modifications. The function signature is identical to the signature of the array returned when using `justPrepare`. `response` will usually be `null`, but must be passed on as is, to account for future API changes.\n\n## Error types\n\nAll these correctly extend the `Error` class - this means that you can use them as a `.catch` predicate when using Promises, and that you can use `instanceof` on them when using the nodeback API.\n\n### bhttp.bhttpError\n\nThe base class for all errors generated by `bhttp`. You usually don't need this.\n\n### bhttp.ConflictingOptionsError\n\nYou have specified two or more request options that cannot be used together.\n\nThe error message will contain more details.\n\n### bhttp.UnsupportedProtocolError\n\nYou tried to load a URL that isn't using either the HTTP or HTTPS protocol. Only HTTP and HTTPS are currently supported.\n\n### bhttp.RedirectError\n\nA redirect was encountered that could not be followed.\n\nThis could be because the redirect limit was reached, or because the HTTP specification doesn't allow automatic following of the redirect that was encountered.\n\nThe error message will contain more details.\n\n### bhttp.MultipartError\n\nSomething went wrong while generating the multipart/form-data stream.\n\nCurrently, this will only be thrown if you try to use chunked transfer encoding for a multipart stream - a common situation where this can occur, is when you pass in streams with an unknown length.\n\nTo resolve this error, you must either explicitly specify the length of the streams using `bhttp.wrapStream` or, if the target server supports it, enable the `allowChunkedMultipart` option.\n\n### bhttp.ConnectionTimeoutError\n\nThe connection timed out.\n\nThe connection timeout is defined by the operating system, and cannot currently be overridden.\n\n### bhttp.ResponseTimeoutError\n\nThe response timed out.\n\nThe response timeout can be specified using the `responseTimeout` option, and it is measured from the start of the request to the start of the response. If no response is received within the `responseTimeout`, a `ResponseTimeoutError` will be thrown asynchronously, and the request will be aborted.\n\n__You should not set a `responseTimeout` for requests that involve large file uploads!__ Because a response can only be received *after* the request has completed, any file/stream upload that takes longer than the `responseTimeout`, will result in a `ResponseTimeoutError`.\n","starsCount":6,"created":"2015-01-23T17:27:38.179Z","modified":"2017-04-09T03:28:08.100Z","lastPublisher":{"name":"joepie91","email":"admin@cryto.net"},"owners":[{"name":"joepie91","email":"admin@cryto.net"}],"other":{"_attachments":{},"_from":".","_id":"bhttp","_nodeVersion":"5.1.0","_npmOperationalInternal":{"host":"packages-16-east.internal.npmjs.com","tmp":"tmp/bhttp-1.2.4.tgz_1471373073317_0.5849238086957484"},"_npmUser":{"name":"joepie91","email":"admin@cryto.net"},"_npmVersion":"3.10.5","_rev":"4-b8443b2c39935047ad19db5a87be34b9","_shasum":"fed0c24f765b35afc4940b08ab3214813e38f38f","author":{"name":"Sven Slootweg"},"bugs":{"url":"https://github.com/joepie91/node-bhttp/issues"},"directories":{},"dist-tags":{"latest":"1.2.4"},"dist":{"shasum":"fed0c24f765b35afc4940b08ab3214813e38f38f","tarball":"http://registry.npmjs.org/bhttp/-/bhttp-1.2.4.tgz"},"maintainers":[{"name":"joepie91","email":"admin@cryto.net"}],"readmeFilename":"README.md","time":{"modified":"2017-04-09T03:28:08.100Z","created":"2015-01-23T17:27:38.179Z","1.0.0":"2015-01-23T17:27:38.179Z","1.0.1":"2015-01-23T17:42:06.806Z","1.0.2":"2015-01-24T07:15:50.533Z","1.0.3":"2015-02-22T21:18:35.837Z","1.0.4":"2015-03-17T12:10:00.474Z","1.1.0":"2015-04-08T17:48:02.578Z","1.1.1":"2015-04-09T10:11:39.885Z","1.1.2":"2015-04-09T12:00:08.280Z","1.1.3":"2015-04-27T03:32:59.087Z","1.2.0":"2015-04-27T15:07:16.565Z","1.2.1":"2015-04-27T15:33:53.907Z","1.2.3":"2016-08-16T18:23:41.702Z","1.2.4":"2016-08-16T18:44:36.021Z"},"users":{"phishy":true,"dmarr":true,"ceejbot":true,"rassad":true,"oceanic":true,"usingthesystem":true}}}