{"name":"mod-proxy","version":"0.1.0","description":"A node.js HTTP proxy with configurable requests and responses.","main":"mod-proxy.js","scripts":{"test":"mocha test","pretest":"echo '-> linting' && npm run -s lint","lint":"jshint --exclude test,hookIt,node_modules,examples ."},"repository":"https://github.com/lucasmez/mod-proxy","keywords":["http","proxy","cheerio","middleware"],"license":"MIT","homepage":"https://github.com/lucasmez/mod-proxy#readme","gitHead":"ea90519afd39a5063be65f333b5e3e8d379ce238","versions":[{"number":"0.1.0","date":"2017-01-02T01:31:24.350Z"}],"readme":"# mod-proxy\n\n`mod-proxy` is an HTTPS tunnel proxy and an HTTP proxy that can programmed through `express`-style middlewares to act as a simple transparent proxy, log and/or modify client requests and server responses.\n\n## Table of Contents\n* [General Concept](#general-concept)\n* [Usage Examples](#usage-examples)\n  * [Basic transparent proxy](#basic-transparent-proxy)\n  * [Logging requests and responses](#logging-requests-and-responses)\n  * [Writing and re-writing request headers](#writing-and-re-writing-request-headers)\n  * [Sending custom documents or statuses to specific requests](#sending-custom-documents-or-statuses-to-specific-requests)\n  * [Modifying server responses using jQuery-style selectors](#modifying-server-responses-using-jquery-style-selectors)\n* [Strategies](#strategies)\n  * [Using Strategies](#using-strategies)\n  * [mod-proxy's Native Strategies](#mod-proxys-native-strategies)\n    * [Default](#default)\n    * [Compressor](#compressor)\n    * [Custom Response](#custom-response)\n    * [Modifier](#modifier)\n  * [Writing Strategies](#writing-strategies)\n* [Middlewares](#middlewares)\n  * [Request Object](#request-object)\n  * [Response Object](#response-object)\n* [Clients](#clients)\n* [Test](#test)\n\n## General Concept\n\nTo create a new proxy call `createProxy` with an optional [strategy](#strategies) argument.\nTo start the proxy, call `listen`.\n\n```javascript\nconst modProxy = require('mod-proxy');\n\nvar proxyServer = modProxy.createProxy(strategy);\n\nproxyServer.listen(port);\n```\n\nThe object returned, in the above example `proxyServer`, inherited from node's `http.Server` and will contain six additional methods:\n\n* `req(parallel, cb)`: The cb callback have access to the client's incoming request, of type `http.IncomingMessage`.\n* `res(parallel, cb)`: The cb callback have access to the server's response, of type `http.ServerResponse`. \n* `addClient(address_port, strategy)`: Add a [client](#clients) with a custom strategy.\n* `getClient(address_port)`: Get a client's strategy\n* `changeDefaultMode(strategy)`: Change the default strategy.\n* `configure()`: Wrapper to the current default mode's (strategy's) configuration function. \n\n\nTo work on the clients' requests and servers' responses call `req` and `res` in a middleware-style fashion. They can be chained if desired:\n\n```javascript\nproxyServer\n\t.req( (request, next) => {\t//request is of type http.IncomingMessage\n\t\tconsole.log(\"New request incoming...\");\n\t\tnext();\n\t})\n\t.res( (response, next) => {\t//response is of type http.ServerResponse\n\t\tconsole.log(\"Sending server response...\");\n\t\tnext();\n\t});\n```\n\nYou can also use ready-made [strategies](#strategies):\n\n```javascript\nconst customResponse = require('mod-proxy/strategies/customResponse');\nconst configJSON = require('./responseConfig');\n\nproxyServer.changeDefaultMode(customResponse(JSON.parse(configJSON)));\n```\n\n## Usage Examples\n\n### Basic transparent proxy\n\n```javascript\nconst modProxy = require('mod-proxy');\n\nvar server = modProxy.createProxy().listen(8080);\n```\n### Logging requests and responses\n\n```javascript\nconst modProxy = require('mod-proxy');\n\nvar server = modProxy.createProxy();\n\nserver\n\t.req( (req, next) => {\n\t\tconsole.log(\"\\nRequest from: \", req.socket.remoteAddress);\n\t\tconsole.log(\"requires resource from host: \", req.headers.host);\n\t\tnext();\n\t})\n\n\t.res( (res, next) => {\n\t\tconsole.log(\"Sending server response with the headers: \", res.headers );\n\t\tnext();\n\t})\n\n\t.listen(8080);\n```\n\n### Writing and re-writing request headers\n```javascript\nconst modProxy = require('mod-proxy');\n\nvar server = modProxy.createProxy();\n\nserver\n\t.req( (req, next) => {\n\t\treq.headers['Cookie'] = 'name=myName';\n\t\treq.headers['X-proxy'] = 'modProxy';\n\t\tnext();\n\t})\n\t\n\t.listen(8080);\n```\n\n### Sending custom documents or statuses to specific requests\n\nUse the [strategy](#strategies) `customResponse` to send back custom resources and/or statuses to specific requests:\n\n```javascript\nconst modProxy = require('mod-proxy');\nconst customResponse = require('mod-proxy/strategies/customResponse');\n\nvar config = {\n\t'www.somewebsite.com': [401, 'youShallNotPass.html'],\t//Send back custom local file with 401 status code\n\n\t'www.anotherwebsite.com': {\n\t\t'/noEnter': [404, 'www.externalSite.com/nothingHere.html'] //Request and send resource from another domain\n\t}\n};\n\nvar server = modProxy.createProxy(customResponse(config));\n\n// OR (change default strategy after server has been created)\n//var server = modProxy.createProxy();\n//server.changeDefaultMode(customResponse(config));\n\n// OR (use strategy with middleware-style functionality)\n//var server = modProxy.createProxy();\n//var customRes = customResponse(config);\n//server.req( customRes.clientRequest );\n\nserver.listen(8080);\n```\n\n### Modifying server responses using jQuery-style selectors\n\nUse the [strategy](#strategies) `modifier` to modify server responses using jQuery-style selectors before sending them back to the client. The `compressor` strategy is also used to decompress gzipped resources to make them readable to `modifier` and then re-compress them before they are sent back to the client.\n\n```javascript\nconst modProxy = require('mod-proxy');\nconst modifier = require('mod-proxy/strategies/modifier');\nconst compressor = require('mod-proxy/strategies/compressor');\n\n\n//Configure compressor to only decompress html files\nvar decompress = compressor.decompress({\n    'content-type' : /.*text\\/html.*/\n});\n \n//Configure compressor to only compress html files\nvar compress = compressor.compress({\n    'content-type' : /.*text\\/html.*/\n});\n\nvar mod = modifier(); //Create modifier\nvar $ = mod.$;\t//Get access to its selector function\n\n//jQuery-style modifications applied to every html server response\n$('title').prepend('My Title - ');\n$('.class1').replaceWith(\"<h1>Replaced</h1>\");\n$('#id1').after(\"<h1>After id1</h1>\").before(\"<h1>Before id1</h1>\");\n\nvar server = modProxy.createProxy();\n\nserver\n\t.res(decompress.serverResponse)\t\t//Decompress response if needed\n\t.res(mod.serverResponse)\t\t//Make modifications \n\t.res(compress.serverResponse)\t\t//Re-compress responses that were decompressed earlier\n\n\tlisten(8080);\n```\n\n## Strategies\nA Strategy is a method that returns an object containing a `req` and/or a `res` [middlewares](#middlewares). It was inspired by `express`'s `app.use` although relatively limited in flexibility and functionality.\n\n### Using Strategies\nTo create a strategy call its exported method with any required arguments:\n\n```javascript\nconst strat = require('./myStrategy');\n\nvar strategy = strat(options);\n```\n\nThere are three ways to use a strategy:\n\n- **When creating the proxy using `createProxy`**: This will set the default proxy mode (another word for strategy) to the argument passed to `createProxy`. Any `req` and  `res` middlewares the strategy contains will be used automatically.\n- **Changing the default strategy**: Call the server's `changeDefaultMode` method with a strategy argument to change its default mode after the server has been created with `createProxy`.\n- **Use strategy methods as middlewares**: This provides the greater flexibility. Every strategy will contain two methods: `clientRequest` and `serverResponse`. These are used as the callbacks to  `req` and `res` (See [middlewares](#middlewares)) respectively. Some strategies have and must use both middlewares to function correctly, so be careful when using this method and check the strategy's documentation.\n\n```javascript\nconst modProxy = require('mod-proxy');\nconst strat = require('./myStrategy');\n\n//First way\nvar server = modProxy.createProxy(strat(options));\n\n//Second way\nvar server = modProxy.createProxy();\nserver.changeDefaultMode(strat(options));\n\n//Third way\nvar server = modProxy.createProxy();\nvar strategy = strat(options);\nserver\n\t.req( strategy.clientRequest );\t\t//If present\n\t.res( strategy.serverResponse );\t//If present\n```\n\n### Mod-proxy's Native Strategies\nMod-proxy's native strategies are inside the *strategies* folder.\n\n#### Default\nThis is an empty strategy that is used internally when `createProxy` is called without an argument. It also serves as a skeleton to follow if you wish to create your own.\n\n#### Compressor\nMost resources are compressed using gzip before they are sent from server to client. If you wish to modify or parse those files before fowarding them to the client, decompressing them into a readable format would be useful. This strategy uses node's `zlib` module to decompress and compress files.\n`compressor` exports an object containing two strategies:\n\n```javascript\nconst modProxy = require('mod-proxy');\nconst compressor = require('mod-proxy/strategies/compressor');\n\nvar decompress = compressor.decompress(options);\t//Create decompress strategy\nvar compress = compressor.compress(options);\t\t//Create compress strategy\n\nvar server = modProxy.createProxy();\n\nserver\n\t.res(decompress.serverResponse)\t//Decompress response\n\t.res(compress.serverResponse);\t//Re-compress responses that were decompressed earlier\n```\n\nBoth strategies (`decompress` and `compress`) accept an optional options object argument which must contain the property `content-type` with a RegExp value. This value will be matched with the server responses' *content-type* header. If it is a match, the resource will only me compressed or decompressed if the header *content-encoding=gzip* is also present:\n\n```javascript\n//Configure compressor to only decompress html files\nvar decompress = compressor.decompress({\n    'content-type' : /.*text\\/html.*/\n});\n \n//Configure compressor to only compress html files\nvar compress = compressor.compress({\n    'content-type' : /.*text\\/html.*/\n});\n```\n\n#### Custom Response\nThis strategy can be used if you wish to block access to certain pages, resources or a whole website by sending custom HTTP status code to the client, replace a webpage or resource with another custom resource stored in the local machine or any other web server and more.\nTo create this strategy you must pass to it an object argument containing the desired configuration:\n\n```javascript\nconst modProxy = require('mod-proxy');\nconst customResponse = require('mod-proxy/strategies/customResponse');\n\nvar server = modProxy.createProxy(customResponse(config));\n```\n\nThe *config* object must follow the rules:\n\n- Each property name must be the name of a domain. e.g.: 'http://www.website.com' or 'www.website.com'.\n- The value of each domain property can be either an array, a string or an object:\n  - **Array**: This configuration will be applied to the entire domain, regardless of path. The first element of the array contains the HTTP Status Code returned to the client. The next element is a string containing either the name of a local file or another resource (can be from another domain) to be sent to the client, or an object containing properties and values that will be added as or replace HTTP headers and its values respectively. e.g.: \nwww.somesite.com: [404, '404Error.html'].\nwww.anothersite.com: [301, {Location: 'http://www.newlocation.com'}].\n  -  **String**: This configuration will be applied to the entire domain, regardless of path. The string contains either the name of a local file or another resource (can be from another domain) to be sent to the client. An HTTP status code of 200 is sent by default.\ne.g.: www.somesite.com: 'http://www.anothersite.com/page.html'.\n  - **Object**: Each property of this object is a string containing the specific url path to which the configuration is to be applied. '*' is used to match any path. The value for each property can again be an array, a string or an object. The first two cases are exactly the same as described above. If the value is an object each of its properties must be a string containing an HTTP header ('accept', 'user-agent', etc). The value for each property will also be an object and its properties must be a string that will later be converted into a RegExp. This regular expression will hold the value of the HTTP header and will be matched against every client request. See below for examples.\n\nExamples will make things clearer:\n```javascript\nvar config = {\n\n\t// For somesite.com domain \n\t'www.somesite.com': [401, 'forbidden.html'], // For any path and any headers, send 401 status code with a custom local page\n\n\t// For oldsite.com domain\n\t'http://www.oldsite.com': {\n\t\t'/redirection': [301, {Location: 'http://www.newlocation.com'}] // For the path /redirection and any headers, send back 301 status code with custom Location header, no body.\n\t},\n\n\t// For newsite.com domain\n\t'www.newsite.com': 'http://www.someotherdomain.com/index.html', // For any path and headers, send back a resource from another domain\n\n\t// For anothersite.com domain\n\t'www.anothersite.com': {\n\t\t'*': {\t// For any path\n\t\t\taccept: {\t// If the request contains an 'accept' header that matches the following RegExp\n\t\t\t\t'image/webp,image/.*': 'http://www.someotherdomain/image.png', // Send back an image from another domain \n\t\t\t}\n\t\t}\n\t}\t\n\n}\n\ncustomResponse(config);\n```\n\n#### Modifier\nIf you want to modify the server's response HTML before sending it to the client using a jQuery-style selector, use this strategy. It makes use of the module `html-injector` which is a stream implementation of a subset of `cheerio`. You must decompress the HTML file before using the modifier. The Compressor strategy is suitable for this.\n\nTo create the strategy, call the exported method without any arguments. The returned object contains a method `$`, which is used similarly to the jQuery selector, although with limited functionality (See [html-injector](https://github.com/lucasmez/html-injector)).\n\n[Go up to example](#modifying-server-responses-using-jquery-style-selectors).\n\n### Writing Strategies\nA strategy is an object that must contain four methods:\n- **clientRequest**: Callback for the `req` method of the proxy server. See [middlewares](#middlewares).\n- **serverResponse**: Callback for the `res` method of the proxy server. See [middlewares](#middlewares).\n- **configure**: Configure the strategy.\n- **getConfig**: Get strategy's current configuration. \n\nThe *default.js* file inside the *strategies* folder serves as a template.\n`clientRequest` and  `serverResponse` must use those names because when the strategy is used, either with `createProxy` or `changeDefaultMode`, those methods will be called internally.\nYou can use a strategy's methods directly as middlewares (see [Using Strategies](#using-strategies) above) or simply write [middlewares](#middlewares) instead of creating a whole strategy.\n\n## Middlewares\nThere are two types of middlewares, `req` and `res` middlewares, which are callback methods passed to those two functions. `req` middlewares have access to the [request object](#request-object). `res` middlewares have access to the [response object](#response-object). Both have access to a function (commonly called **next**) which when called continues the request-response cycle. Like in the `express` module, middlewares can perform the following tasks:\n- Execute any code.\n- Make changes to the request and the response objects.\n- End the request-response cycle.\n- Call the next middleware in the stack.\n\nBy calling **next()** the middleware passes control to the next middleware or function in the request-response cycle. If **next()** is not called the client will be left without a response.\n\n```javascript\nserver\n\t.req( function(req, next) {\t\t// req middleware\n\t\t//Execute any code...\n\t\t//Pass control to next function\n\t\tnext();\n\t})\n\n\t.res( function(res, next) {\t\t// res middleware\n\t\t//Execute any code...\n\t\t//Pass control to next function\n\t\tnext();\n\t});\n```\n\nThe following diagram shows the request-response cycle:\n\n![request-response-cycle](https://cloud.githubusercontent.com/assets/20986580/21575363/d752829c-ced7-11e6-865b-b666223caa37.png)\n\nIt is possible to bypass step 3 (Sending client request to the web server) and send back to the client a custom response (See [Request Object](#request-object) below).\n\n### Request Object\nThe request object is internally passed to the `req` middleware as the first argument. It is node's *http.IncomingMessage* object with the following added properties:\n- `bypassOriginRequest`: Of type Boolean. If set to *true*, step 3 in the request-response cycle will be skipped and the proxy will not contact the web server for the current request.\n- `customResponse`: Used only when bypassOriginRequest is set to true. Since no request was made to the web server, no *http.ServerResponse* stream will be present to be piped to the client. This object will serve that role and it must be a readable stream. This stream must contain two additional properties described below:\n  - `customResponse.statusCode`: A Number holding the HTTP Status Code to be sent to the client.\n  - `customResponse.headers`: An Object holding the HTTP headers and its values to be sent to the client.\n- `clientResponse`: If you wish to skip steps 3, 4, 5 and 6 of the request-response cycle, effectively ending it (see image above), and manually send the response to the client, write to this stream. This is the response object created internally by node's HTTP server and passed to its *request* event as the second argument. mod-proxy writes to this stream on step 6 of the request-response cycle.\n\nFor an example of these properties in use, see the file *customResponse.js* inside the *strategies* folder.\n\n### Response Object\nThe response object is internally passed to the `res` middleware as the first argument. It is node's *http.ServerResponse* object with the following added method:\n- `plumb`: If you wish to modify the web server's response or a custom response (see Request Object above) before sending it to the client by passing it through a stream, use this method. Its argument must be a stream that is both readable and writable (think node's transform streams).\n\nFor an example of this method in use, see the file *modifier.js* inside the *strategies* folder.\n\n## Clients\nIf you wish to add middlewares and/or strategies that will affect only specific web clients, call `addClient`. Clients are identified by ip address and port number.\n\n```javascript\nconst modProxy = require('mod-proxy');\n\nvar server = modProxy.createProxy();\n\n// Add first client\nserver.addClient(client1)\n\t.req( middleware1 )\n\t.req( middleware2 )\n\t.res( middleware3 );\n\n// Add second client\nserver.addClient(client2, someStrategy);\n```\n\nThe arguments, *client1* and *client2* in the example above, must be of type RegExp. The RegExp pattern will be matched against every request's ip address and port number joined by a colon: *ip_address:port_number*. If a matching client is found, that client's middleware stack is used. A strategy can be passed as the second argument, *someStrategy* in the example above, and it will be used for the client. \n\n`getClient` is passed a string argument of the form *ip_address:port_number* and if a previously added client is matched, it is returned, otherwise it returns *null*.\n\nBoth `addClient` and `getClient` return a the client's strategy (default strategy if none was added) with the methods `req` and  `res` added to it.\n\nExample:\n\n```javascript\nconst modProxy = require('mod-proxy');\n\nvar server = modProxy.createProxy();\n\n// middleware1 will be used for every request coming from any host on the local network.\nserver.addClient(/127.0.0.\\.*/)\n\t.req( middleware1 );\n\n// someStrategy will be used for every request coming from any host using port 25486.\nserver.addClient(/:25486/, someStrategy);\n\n//Adding middleware2 to the second client\nserver.getClient('1.1.1.1:25486')\n\t.res(middleware2);\n```\n\n## Test\n\nTests are not yet complete.\n\n```\n$ npm test\n```\n","created":"2017-01-02T01:31:24.350Z","modified":"2017-01-02T01:31:24.350Z","lastPublisher":{"name":"lucasmez","email":"lucasmezalira@hotmail.com"},"owners":[{"name":"lucasmez","email":"lucasmezalira@hotmail.com"}],"other":{"_attachments":{},"_from":".","_id":"mod-proxy","_nodeVersion":"6.9.1","_npmOperationalInternal":{"host":"packages-12-west.internal.npmjs.com","tmp":"tmp/mod-proxy-0.1.0.tgz_1483320682170_0.8360269193071872"},"_npmUser":{"name":"lucasmez","email":"lucasmezalira@hotmail.com"},"_npmVersion":"3.10.8","_rev":"1-4d21069d47c3209598ed1aa25f96b0f7","_shasum":"b0fca047079fcafacbea7177e3c3b27c7e28338b","author":{"name":"Lucas Mezalira","email":"lucasmezalira@hotmail.com"},"bugs":{"url":"https://github.com/lucasmez/mod-proxy/issues"},"directories":{"example":"examples","test":"test"},"dist-tags":{"latest":"0.1.0"},"dist":{"shasum":"b0fca047079fcafacbea7177e3c3b27c7e28338b","tarball":"http://registry.npmjs.org/mod-proxy/-/mod-proxy-0.1.0.tgz"},"maintainers":[{"name":"lucasmez","email":"lucasmezalira@hotmail.com"}],"readmeFilename":"README.md","time":{"modified":"2017-01-02T01:31:24.350Z","created":"2017-01-02T01:31:24.350Z","0.1.0":"2017-01-02T01:31:24.350Z"}}}