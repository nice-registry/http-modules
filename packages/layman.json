{"name":"layman","description":"A simple manager for HTTP request <--> response layers in node.js","version":"0.1.7","main":"layman.js","license":"MIT","repository":"https://github.com/ujc/Layman.js","keywords":["layman","layman.js","connect","express","middleware","http","https","web","server","web server","request"],"gitHead":"daed1bbb522c7aa7db15b778b26bb7fc62c57385","homepage":"https://github.com/ujc/Layman.js","scripts":{},"versions":[{"number":"0.0.1","date":"2014-10-29T17:31:29.670Z"},{"number":"0.0.2","date":"2014-10-30T20:36:59.493Z"},{"number":"0.0.3","date":"2014-10-30T21:04:59.251Z"},{"number":"0.0.4","date":"2014-10-30T21:05:52.385Z"},{"number":"0.0.5","date":"2014-10-30T22:20:39.982Z"},{"number":"0.0.7","date":"2014-11-01T15:32:50.313Z"},{"number":"0.0.8","date":"2014-11-01T15:35:47.910Z"},{"number":"0.0.9","date":"2014-11-02T03:29:49.598Z"},{"number":"0.0.10","date":"2014-11-02T03:39:09.054Z"},{"number":"0.0.11","date":"2014-11-02T03:40:15.020Z"},{"number":"0.1.0","date":"2014-11-02T03:46:05.146Z"},{"number":"0.1.1","date":"2014-11-02T03:54:58.854Z"},{"number":"0.1.2","date":"2014-11-02T06:00:18.877Z"},{"number":"0.1.3","date":"2014-11-02T06:44:32.328Z"},{"number":"0.1.4","date":"2014-11-02T16:03:54.260Z"},{"number":"0.1.5","date":"2014-11-02T17:02:07.183Z"},{"number":"0.1.6","date":"2014-11-10T19:52:14.171Z"},{"number":"0.1.7","date":"2014-11-11T14:36:22.065Z"}],"readme":"Layman.js\n=========\nA simple, lightweight manager for HTTP Request <--> Response layers for node.js\n\nLayman.js is a simplified version of Senchalabs's Connect.  \nIt allows you to easily manage multiple layers of Request <--> Response handlers (aka middleware) for your node.js web server.\n\n### Contents\n- <a href='#hello'>Hello Layman</a>\n- <a href='#routes'>Using Routes</a>\n- <a href='#layers'>Multiple Layers</a>\n- <a href='#async'>Asynchronous Layers</a>\n- <a href='#flowcontrol'>Flow Control</a>\n- <a href='#postget'>POST & GET</a>\n- <a href='#nested'>Nested Layers</a>\n- <a href='#hosts'>Multiple Hosts</a>\n- <a href='#files'>Organizing Files</a>\n- <a href='#server'>Built-In Web Server</a>\n- <a href='#configs'>Layman Configs</a>\n- <a href='#connect'>Connect Middleware</a>\n- <a href='#roadmap'>Roadmap</a>\n- <a href='#changelog'>Change Log</a>\n- <a href='#feedback'>Feedback</a>  \n\n\n\n\n***\n\n\n<a name='hello'></a>\nHello Layman\n------------\nThe following is the 'layman' version for 'hello world'. Layman uses the popular syntax of `use(middleware)`, where `middleware` is a callback function that will get the `request` and `response` as it's only arguments:  \n\n```javascript\n// Init\nvar layman = require('layman'),\n\thttp = require('http'),\n\tsite = layman();\n\t\n// Add a middleware layer to handle request <--> response\nsite.use(function(req,res){\n\t\n\t// Write some data to the response\n\tres.write('layman is awesome!');\n});\n\n// Start a new server, passing in 'site' as the main request <--> response manager\nhttp.createServer(site).listen(80);\n```\n**Note:** `site` is just a callback function which is used as the main request handler for your server. Learn more about how layman works on the [Wiki pages on GitHub](https://github.com/ujc/Layman.js/wiki) (work in progress).\n\n\n\n***\n\n\n\n<a name='routes'></a>\nUsing Routes\n------------\nIf you want to use a certain middleware only for a specific route, you can do so by specifying the route as the first parameter to the `use(...)` function:  \n\n```javascript\n// Init\nvar layman = require('layman'),\n\thttp = require('http'),\n\tsite = layman();\n\t\n// This layer handles requests to /some/route/\nsite.use('/some/route/', function(req,res){\n\t\n\t// This layer will only be used for /some/route/\n\tres.write('you are now on /some/route/');\n});\n\n// Start a new server, passing in 'site' as the main request <--> response manager\nhttp.createServer(site).listen(80);\n```\n**Note:** The leading forward-slash `/` for the specified route is optional. Using `/foo` is the same as using `foo`.\n\n\n\n***\n\n\n\n<a name='layers'></a>\nMultiple Layers\n---------------\nMultiple request handler layers are added by calling the `use(...)` function more than once, each time passing in a new layer that will handle the Request <--> Response pair.  \nLayers are triggered in order of FIFO - the first layer that was registered is the first layer that will handle the incoming request:  \n\n```javascript\n// Init\nvar layman = require('layman'),\n\thttp = require('http'),\n\tsite = layman();\n\t\n// Add the first layer\nsite.use(function(req,res){\n\t\n\t// First layer that gets the request\n\tres.write('hello ');\n});\n\n// Add the second layer\nsite.use(function(req,res){\n\t\n\t// Second layer that gets the request\n\tres.write('world!');\n});\n\n// Start a new server, passing in 'site' as the main request <--> response manager\nhttp.createServer(site).listen(80);\n```\n\n\n\n***\n\n\n\n<a name='async'></a>\nAsynchronous Layers\n-------------------\nThere are many ways in which a layer can be used asynchronously.  \nTo start with, let's build a most simplistic static-files layer for Layman.  \nWe'll use node's asynchronous `fs.readFile(...)` method to serve `index.html`: \n\n#####Example 1: Show casing `return true` to indicate an async layer\n\n\n```javascript\n// Init\nvar layman = require('layman'),\n\thttp = require('http'),\n\tfiles = require('fs'),\n\tsite = layman();\n\t\n// This layer is async because it returns 'true'\nsite.use(function(req,res){\n\t\n\t// Use node's `readFile(...)` method to server `index.html`\n\tfiles.readFile('index.html', function(err, data){\n\t\t\n\t\t// If anything went wrong, write a very sad message to the user\n\t\tif (err) {\n\t\t\n\t\t\t// End the response, and indicate that we have issues\n\t\t\tres.end('Booo...the server broke );');\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// All good! End the response, sending the contents of 'index.html' as the response data\n\t\tres.end(data);\n\t});\n\t\n\t// A layer can indicate that it is async by returning true\n\treturn true;\n});\n\n// Start a new server, passing in 'site' as the main request <--> response manager\nhttp.createServer(site).listen(80);\n```\n**Note:** Because this layer is asynchronous, we `res.end(...)` the response within the callback function that is passed into `fs.readFile(...)`  \n\n\n#####Example 2: Show casing `next()` to use with multiple layers\nThe example above showed a single layer handling both success and failure of reading a file. \nIt's common to separate this logic by using multiple layers, where the `next` layer would only be used if an async operation failed:\n\n```javascript\n// Init\nvar layman = require('layman'),\n\thttp = require('http'),\n\tfiles = require('fs'),\n\tsite = layman();\n\t\n// This layer is async because it returns 'true'\nsite.use(function(req, res, next){\n\t\n\t// Use node's `readFile(...)` method to server `index.html`\n\tfiles.readFile('index.html', function(err, data){\n\t\t\n\t\t// We'll let the 'next' layer handle any errors\n\t\tif (err) { next(); return }\n\t\t\n\t\t// All good! End the response in this layer (the next layer will not be triggered, and the response will end)\n\t\tres.end(data);\n\t});\n\t\n\t// A layer can indicate that it is async by returning true\n\treturn true;\n});\n\n\n// This layer will be used only if the previous layer was unable to read 'index.html'\nsite.use(function(req,res){\n\n\tres.write('Booo...the server broke );');\n});\n\n\n// Start a new server, passing in 'site' as the main request <--> response manager\nhttp.createServer(site).listen(80);\n```\n**Note:** We used `next` as the 3rd argument for our async layer. If for any reason we weren't able to read `index.html`, the `next` layer will be triggered.  \n**Note:** Unlike [Connect](https://github.com/senchalabs/connect), the `next` layer will not receive any data regarding the error that occured. Asynchronous error handling is still work in progress, this behavior might be supported in the future.\n\n\n\n#####Example 3: Show casing `autoAsync=true` for run-time based asynchronous control\nIn certain cases, you may need to determine if the `next` layer should be asynchronous or not based on some data that is only available at runtime (when a request is sent to the server \\ when a database operation is complete \\ when a 3rd party proxy is ready for communication \\ ...):\n\n```javascript\n// Init\nvar layman = require('layman'),\n\thttp = require('http'),\n\tfiles = require('fs'),\n\tsite = layman();\n\t\n\n// Tell Layman to always be in async mode\nsite.configs.autoAsync = true;\n\t\n\t\n// This layer is asynchronous because 'autoAsync' is turned on\nsite.use(function(req, res){\n\t\n\t// Read a 'index.html'\n\tfs.readFile('index.html', function(err, data){\n\t\t\n\t\t// Boo...something went asynchronously wrong );\n\t\tif (err) {\n\t\t\tres.end('oh no!');\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// We're good to go!\n\t\tres.end(data);\n\t});\n});\n\n\n// Start a new server, passing in 'site' as the main request <--> response manager\nhttp.createServer(site).listen(80);\n```\n**Note:** No need for the layer to `return true`, since `autoAsync` is turned on.  \n**Note:** Also, we're not using a`next` layer here, since the layer handles both success and failure.  \n**Note:** Read more about the available configs <a href='#configs'>here</a>\n\n\n\n***\n\n\n\n<a name='flowcontrol'></a>\nFlow Control\n------------\nA very common scenario is that one layer needs to end the response without passing control to any of the next layers that were registered.  This is done by having that layer `return false`.  \nWhen a layer (aka callback, aka middleware) returns `false`, the response is ended and sent out, and excecution of any following layers stops (internally, layman calls `res.end()`):  \n\n```javascript\n// Init\nvar layman = require('layman'),\n\thttp = require('http'),\n\tsite = layman();\n\t\n// This layer returns false, so the next layer will never get called\nsite.use(function(req,res){\n\t\n\t// A lone wolf\n\tres.write('El Solo Lobo');\n\t\n\t// Return false to send out the response, skipping any following layers\n\treturn false;\n});\n\n// Why doesn't anyone call me ?\nsite.use(function(req,res){\n\t\n\t// Second layer that gets called\n\tres.write('This text will never be seen. By anyone. Forever. Forever-ever!');\n});\n\n// Start a new server, passing in 'site' as the main request <--> response manager\nhttp.createServer(site).listen(80);\n```\n**Note:** Make sure to read about <a href='#async'>Asynchronous Layers</a> for more info on how to control layers\n\n\n\n***\n\n\n\n<a name='postget'></a>\nPOST & GET\n----------\nLayman also supports registering layers that will only handle GET or POST requests (PUT and DELETE are coming soon).  \nYou can also define routes for each of these:\n\n```javascript\n// Init\nvar layman = require('layman'),\n\thttp = require('http'),\n\tsite = layman();\n\t\n// Only triggered for a GET request\nsite.get(function(req,res){\n\t\n\t// GET it ?\n\tres.write('You are GETting this page');\n});\n\n// Only triggered for a POST request\nsite.post(function(req,res){\n\t\n\t// POST only\n\tres.write('This is a direct result of a POST request');\n});\n\n// Using routes\nsite.get('/bla', function(req,res){\n    \n    // You're really GETting the hang of it!\n    res.write('All you GET is bla bla bla...');\n});\n\n// Start a new server, passing in 'site' as the main request <--> response manager\nhttp.createServer(site).listen(80);\n```\n\n\n\n***\n\n\n\n\n<a name='nested'></a>\nNested Layers\n-------------\nIn some cases, you're team might need to separate the layers that handle your 'sales' department from those that handle your 'blog'. Using layman, this is a really easy to accomplish:\n\n```javascript\n// Init\nvar layman = require('layman'),\n\thttp = require('http'),\n\tsite = layman(),\n\tsales = layman(),\n\tblog = layman();\n\n// Setup our blog\nblog.use(function(req,res){\n    res.write('welcome to my awesome blog!!');\n});\n\n\n// Setup the sales department\nsales.use(function(req, res){\n    res.write('buy now!');\n});\n\nsales.post(function(req,res){\n    res.write('thanks you for your purchase!');\n});\n\n\n// Setup the site to use the correct layman based on the route\nsite.use('/sales', sales);\nsite.use('/blog', blog);\n\n// Start a new server, passing in 'site' as the main request <--> response manager\nhttp.createServer(site).listen(80);\n```\n\n\n***\n\n\n\n<a name='hosts'></a>\nMultiple Hosts\n--------------\nThe example below is similar to the code above - only this time instead of registering `sales` and `blog` with routes, we register each to it's respective sub-domain:\n\n```javascript\n// Init\nvar layman = require('layman'),\n\thttp = require('http'),\n\tsite = layman(),\n\tblog = layman(),\n\tsales = layman();\n\n\n// Setup our blog\nblog.use(function(req,res){\n    res.write('welcome to my awesome blog!!');\n});\n\n\n// Setup the sales department\nsales.use(function(req, res){\n    res.write('buy now!');\n});\n\nsales.post(function(req,res){\n    res.write('thanks you for your purchase!');\n});\n\n\n// Setup our site to use the correct layman based on the path\nsite.host('sales.site.com', sales);\nsite.host('blog.site.com', blog);\n\n// Start a new server, passing in 'site' as the main request <--> response manager\nhttp.createServer(site).listen(80);\n```\n* use `host` when you need to mount a specifc domain \\ subdomain\n\n\n\n***\n\n\n\n<a name='files'></a>\nOrganizing Files\n----------------\nIn real world applications, you'll want to organize files in a way that is meaningful to your team.  \nHave a look below at the code below - it's the same 'Multiple Hosts' example from above - just split into 3 different files:\n\n`main.js`\n\n```javascript\n// FILE: main.js\n// Init\nvar http = require('http'),\n    layman = require('layman'),\n    blog = require('./blog'),\n    sales = require('./sales'),\n    site = layman();\n    \n// Setup our site's sub-domains to use the dedicated layman\nsite.host('sales.site.com', sales);\nsite.host('blog.site.com', blog);\n\n// Start a new server, passing in 'site' as the main request <--> response manager\nhttp.createServer(site).listen(80);\n```  \n  \n`blog.js`\n\n```javascript\n// FILE: blog.js\n// Init\nvar layman = require('layman'),\n    blog = layman();\n\n// Welcome message\nblog.use(function(req,res){\n    res.write('welcome to my blog!!\\n');\n});\n\n// Some article\nblog.use('/article', function(req,res){\n    res.write('bla bla bla bla bla...');\n});\n\nmodule.exports = blog;\n```\n\n`sales.js`\n\n```javascript\n// FILE: sales.js\n// Init\nvar layman = require('layman'),\n    sales = layman();\n\n// Product page\nsales.use('/product', function(req,res){\n    res.write('Buy now!');\n});\n\n// After purchase\nsales.use('/thankyou', function(req,res){\n    res.write('ACME thanks you for your purchase!');\n});\n\nmodule.exports = sales;\n```\n* Notice that since we setup different hosts for `sales` and `blog` in `main.js` - the routes that are used in each file will be relative to the specified sub-domain\n\n\n\n***\n\n\n\n<a name='server'></a>\nBuilt-In Web Server\n-------------------\nLayman also provides a convenience method to start a new web server, making it even easier to implement in your next project:\n\n```javascript\n// Init\nvar layman = require('layman'),\n    site = layman();\n\n// Setup our request handler(s)\nsite.use(function(req,res){\n\tres.write('it\\'s a brave new world!');\n});\n\n// Site is up and running!\nsite.listen(80);\n\n```\n**Note:** When using `listen()`, the port number is optional, and if omitted, the port number defaults to 80. The above is identical to `site.listen()`.\n\n\n\n\n***\n\n\n\n<a name='configs'></a>\nLayman Configs\n--------------\nThe following options are currently available for configuration, all of which can also be changed at run-time (using middleware layers) for fine tuning Layman:\n\n```javascript\n// Init\nvar layman = require('layman'),\n\tsite = layman();\n\t\n\t\n// +---------------------------------------------------------------+\n// | All configs are available directly on layman, under 'configs' |\n// +---------------------------------------------------------------+\n\n// Should Layman automatically `res.end()` the request after all layers were triggered (default: true)\nsite.configs.autoEnd = true;\n\n\n// Should Layman consider all layers to be asynchronous by default ? (default: false)\nsite.configs.autoAsync = false;\n\n\n// When matching the 'hostname' of a request, Layman will use this regex, and compare against the first matching group (default: /(\\w+[^:,]*)\\:?/)\nsite.configs.hostRegex\t= /(\\w+[^:,]*)\\:?/;  \n```\n**Note:** `autoEnd` has no effect on asynchronous layers  \n\n\n\n***\n\n\n\n<a name='connect'></a>\nConnect Middleware\n------------------\nLayman now includes built-in support for Connect middleware.  \nTo use such middleware, pass in a boolean `true` as the first argument when registering a layer to use with your site:\n\n```javascript\n// Init\nvar layman = require('layman'),\n\thttp = require('http'),\n\tmiddleware = require('some-connect-middleware'),\n\tsite = layman();\n\t\n\t\n// This layer is just a standard Layman layer\nsite.use(function(req, res){\n\t\n\t// Just console that we got a new request\n\tconsole.log('Incoming!');\n});\n\n\n// Using a Connect middleware on '/blog'\nsite.use(true, middleware());\n\n\n// And finish up with another Layman layer\nsite.use(function(req,res){\n\t\n\tres.write('The previous layer was a Connect middleware');\n});\n\n\n\n// Start a new server, passing in 'site' as the main request <--> response manager\nhttp.createServer(site).listen(80);\n\n\n\n```\n**Note:** At the moment, Layman does not support Connect error middleware (might be added in the future)  \n**Note:** You can use any of Layman's API such as `get(...)` \\ `post(...)` \\ `host(...)` and routing (using `use(true, '/some/route', middleware)`  \n**Note:** There are more Connect middleware than we can test against. If you find any bugs, please get in touch @ [layman@isnice.me](mailto:layman@isnice.me) \\ open an issue on github\n\n***\n\n\n\n<a name='roadmap'></a>\nRoadmap\n-------\n- Create layman middleware and middleware bundles\n- <s>Play nice with [Connect](https://github.com/senchalabs/connect) middleware</s> <a href='#connect'>Complete, Woohoo!</a>\n- Built-in support for HTTP PUT and HTTP DELETE\n\n**Note:** Got any ideas on how to make Layman better ?  \nlet us know @ [layman@isnice.me](mailto:layman@isnice.me)\n\n\n***\n\n\n\n<a name='changelog'></a>\nChange Log\n----------\n#####v0.1.7\n- Fix: Leading slash in route would casue URL parsing error in some URI formats\n\n#####v0.1.6\n- New: Built-in support for Layman ASYNC layers (<a href='#async'>more info</a>)  \n- New: Layman is now compatible with [Connect](https://github.com/senchalabs/connect) middleware (<a hfre='#connect'>more info</a>)  \n- Update: Documentation now includes info Layman's `configs` object (<a hfre='#configs'>more info</a>) \n\n\n\n\n\n***\n\n\n\n\n<a name='feedback'></a>\nFeedback ?\n----------\nLayman is still in development, and all feedback is welcome.  \nPlease do get in touch @ [layman@isnice.me](mailto:layman@isnice.me)\n  \n  \n  \n\n\n\n","starsCount":2,"created":"2014-10-29T17:31:29.670Z","modified":"2014-11-11T14:36:22.065Z","lastPublisher":{"name":"ujc","email":"code@isnice.me"},"owners":[{"name":"ujc","email":"code@isnice.me"}],"other":{"_attachments":{},"_from":".","_id":"layman","_npmUser":{"name":"ujc","email":"code@isnice.me"},"_npmVersion":"1.4.25","_rev":"1-731747f8b1e06b355f1d2d487f424374","_shasum":"a3b91766326d0d11321737461e38b4d59fc889d6","author":{"name":"UJC","email":"code@isnice.me"},"bugs":{"url":"https://github.com/ujc/Layman.js/issues"},"directories":{},"dist-tags":{"latest":"0.1.7"},"dist":{"shasum":"a3b91766326d0d11321737461e38b4d59fc889d6","tarball":"http://registry.npmjs.org/layman/-/layman-0.1.7.tgz"},"maintainers":[{"name":"ujc","email":"code@isnice.me"}],"readmeFilename":"README.md","time":{"modified":"2014-11-11T14:36:22.065Z","created":"2014-10-29T17:31:29.670Z","0.0.1":"2014-10-29T17:31:29.670Z","0.0.2":"2014-10-30T20:36:59.493Z","0.0.3":"2014-10-30T21:04:59.251Z","0.0.4":"2014-10-30T21:05:52.385Z","0.0.5":"2014-10-30T22:20:39.982Z","0.0.7":"2014-11-01T15:32:50.313Z","0.0.8":"2014-11-01T15:35:47.910Z","0.0.9":"2014-11-02T03:29:49.598Z","0.0.10":"2014-11-02T03:39:09.054Z","0.0.11":"2014-11-02T03:40:15.020Z","0.1.0":"2014-11-02T03:46:05.146Z","0.1.1":"2014-11-02T03:54:58.854Z","0.1.2":"2014-11-02T06:00:18.877Z","0.1.3":"2014-11-02T06:44:32.328Z","0.1.4":"2014-11-02T16:03:54.260Z","0.1.5":"2014-11-02T17:02:07.183Z","0.1.6":"2014-11-10T19:52:14.171Z","0.1.7":"2014-11-11T14:36:22.065Z"},"users":{"goliatone":true,"tetotechy":true}}}