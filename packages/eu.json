{"name":"eu","version":"1.3.2","description":"Caching HTTP client","main":"index.js","scripts":{"test":"mocha","postpublish":"git push && git push --tags"},"repository":"https://github.com/cucumber-ltd/eu","publishConfig":{"registry":"https://registry.npmjs.org"},"keywords":["redis","request","cache","client","http"],"license":"MIT/X11","dependencies":{"debug":"^2.1.2","request":"^2.53.0","request-debug":"^0.1.1"},"devDependencies":{"mocha":"^2.1.0","lru-cache":"^2.5.0","redis":"^0.12.1","hiredis":"^0.2.0"},"gitHead":"6431b3139a0cf4027d938c9f9cc3ea87c403aa0e","homepage":"https://github.com/cucumber-ltd/eu","versions":[{"number":"1.1.1","date":"2014-05-30T12:52:55.783Z"},{"number":"1.2.0","date":"2014-07-08T11:53:19.564Z"},{"number":"1.2.1","date":"2014-07-08T13:24:56.024Z"},{"number":"1.1.0","date":"2014-07-08T13:35:28.703Z"},{"number":"1.2.2","date":"2014-07-08T13:48:16.322Z"},{"number":"1.2.3","date":"2014-08-20T19:48:16.187Z"},{"number":"1.3.0","date":"2014-10-10T09:21:57.292Z"},{"number":"1.3.1","date":"2015-02-03T12:32:13.826Z"},{"number":"1.3.2","date":"2015-03-05T07:08:03.957Z"}],"readme":"Eu is a wrapper around [request](https://github.com/mikeal/request) which can cache\n`HTTP GET` requests based on response headers - just like a browser does.\n\nIt is used to lower latency when consuming data from HTTP/REST APIs that have proper caching\nheaders.\n\n\"Eu\" means \"gotten\" in French.\n\nThis library is heavily inspired from Kevin Swiber's [request-caching](https://github.com/kevinswiber/request-caching).\n\n## Features\n\n* Multiple cache stores:\n  * Redis (built-in)\n  * In-memory based on [LRU](https://github.com/isaacs/node-lru-cache) (built-in)\n  * Medea (3rd party [eu-medea-store](https://github.com/medea/eu-medea-store) plugin by Kevin Swiber)\n* Supports both [public and private caching](http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9.1).\n* Takes advantage of the `ETag` response header by using the `If-None-Match` request header.\n* Takes advantage of the `Last-Modified` response header by using the `If-Modified-Since` request header.\n* Cache TTL is based on the `Expires` response header or `max-age` value in `Cache-Control`, but can be overridden.\n* Highly customisable with sensible defaults.\n\n## Usage\n\nUsage is similar to `request.get`. The main difference is that you have\nto create an `Eu` instance:\n\n```javascript\nvar Eu = require('eu');\nvar eu = new Eu(cache); // See below for details about how to create a cache\n\neu.get('http://some.url', function(err, res, body) {\n});\n\n// Or pass in request options:\neu.get('http://some.url', {json: true}, function(err, res, body) {\n});\n\n```\n\nA cache uses a _store_ to store cached responses:\n\n### In-memory store\n\n```javascript\nvar LRU = require('lru-cache');\nvar store = new Eu.MemoryStore(new LRU());\nvar cache = new Eu.Cache(store);\n```\n\n### Redis store\n\n```javascript\nvar redis = require('redis').createClient();\nvar store = new Eu.RedisStore(redis);\nvar cache = new Eu.Cache(store);\n```\n\nYou can also create a `NullCache`, which does nothing and doesn't require a store:\n\n### Null cache\n\n```javascript\nvar cache = new Eu.NullCache();\n```\n\n### Cache key name spacing\n\nYou should always provide a `prefix` which prefixes the key with the name of\nyour app (or API). When you invoke `Cache.flush`, it will *only* flush the keys\nstarting with that prefix. If you don't specify a prefix, you'll flush the *entire* cache.\n\n```javascript\nvar prefix = 'yourapp:';\nvar cache = new Eu.Cache(store, prefix);\n\ncache.flush(cb); // only the 'yourapp:*' keys get flushed\n```\n\n### Private caching\n\nSome HTTP responses should be cached privately - i.e. they shouldn't be available for other users.\nThis is the case when the server responds with `Cache-Control: private`.\n\nTo handle this you should construct the `Cache` with a `privateSuffix` String argument.\nThis suffix will be appended to the key when caching a private response.\n\n```javascript\nvar prefix = 'yourapp:';\nvar unique = req.user.id; // or req.cookies['connect.sid']\nvar privateSuffix = ':private:' + unique;\nvar cache = new Eu.Cache(store, prefix, privateSuffix);\n```\n\nYou will get an error if no `privateSuffix` was provided when caching a private response.\n\nFor servers that don't reply with a `Cache-Control: private` header, you can force the request to be cached privately:\n\n```javascript\ncache.get(url, { private: true }, function (err, val) {\n  ...\n});\n```\n\nEu will always look in the public cache first, and then in the private cache if there was no\nhit in the public cache.\n\n### Cache entry expiry time\n\nEvery time a response is cached, it is cached with an expiry time. This is a timestamp indicating\nhow long the cache entry is valid for. (This is not the same as TTL - Time to Live. See next section).\n\nWhen Eu finds an entry in the cache it will consult this timestamp to decide whether the\nentry is still valid - i.e. is the expiry time in the future.\n\nIf it's valid, the response is returned immediately. If not, a HTTP request will be issued,\nsetting the `If-None-Match` request header to the value of the cached `ETag` value,\nand the `If-Modified-Since` request header to the value of the cached `Last-Modified` value.\n\nIf the server responds with `304 Not Modified` the cached response will be returned even\nthough it is expired (the server has confirmed that even though it is expired, it hasn't changed).\n\nBy default the expiry time is determined by either the `Cache-Control max-age` or `Expires` response\nheader. If neither of these headers are set, or if you want to cache more aggressively than\nwhat they indicate, you can override this in the options passed to `eu.get`:\n\n```javascript\nfunction expiryTimeMillis() {\n  return 8640000000000000; // cache forever\n}\ncache.get(url, { expiryTimeMillis: expiryTimeMillis }, function (err, val) {\n  ...\n});\n```\n\n### TTL\n\nBy default, Eu will store entries in the cache with the TTL (Time to Live) equal to the cache\nexpiry time (see above).\n\nIf the expiry time is undefined, the response will be cached forever, or until the cache discards it, using\nwhatever expiry algorithm it uses, such as LIFO or FIFO.\n\nYou can override the default TTL by supplying your own `ttl` function:\n\n```javascript\nfunction myTtl(ttl) {\n  return ttl * 1000; // cache it longer than the server told us to.\n}\n\nvar cache = new Eu.Cache(store, null, null, myTtl);\n```\n\n## Debugging\n\nJust set `DEBUG=eu` in your shell to see debug info.\n\nFor extra verbose output (print request and response headers) set `DEBUG=eu,eu:*`\n","created":"2014-05-30T12:52:55.783Z","modified":"2015-03-05T07:08:03.957Z","lastPublisher":{"name":"aslakhellesoy","email":"aslak.hellesoy@gmail.com"},"owners":[{"name":"aslakhellesoy","email":"aslak.hellesoy@gmail.com"},{"name":"mattwynne","email":"matt@mattwynne.net"},{"name":"jbpros","email":"jb@jbpros.com"}],"other":{"_attachments":{},"_from":".","_id":"eu","_nodeVersion":"0.12.0","_npmUser":{"name":"aslakhellesoy","email":"aslak.hellesoy@gmail.com"},"_npmVersion":"2.5.1","_rev":"1-df0b78488477768cb0134e6762509f09","_shasum":"7ac7313bb1c9f513f214104ac381a14296caa392","author":{"name":"Cucumber Limited"},"bugs":{"url":"https://github.com/cucumber-ltd/eu/issues"},"directories":{},"dist-tags":{"latest":"1.3.2"},"dist":{"shasum":"7ac7313bb1c9f513f214104ac381a14296caa392","tarball":"http://registry.npmjs.org/eu/-/eu-1.3.2.tgz"},"maintainers":[{"name":"aslakhellesoy","email":"aslak.hellesoy@gmail.com"},{"name":"mattwynne","email":"matt@mattwynne.net"},{"name":"jbpros","email":"jb@jbpros.com"}],"readmeFilename":"README.md","time":{"modified":"2015-03-05T07:08:03.957Z","created":"2014-05-30T12:52:55.783Z","1.1.1":"2014-05-30T12:52:55.783Z","1.2.0":"2014-07-08T11:53:19.564Z","1.2.1":"2014-07-08T13:24:56.024Z","1.1.0":"2014-07-08T13:35:28.703Z","1.2.2":"2014-07-08T13:48:16.322Z","1.2.3":"2014-08-20T19:48:16.187Z","1.3.0":"2014-10-10T09:21:57.292Z","1.3.1":"2015-02-03T12:32:13.826Z","1.3.2":"2015-03-05T07:08:03.957Z"}}}