{"name":"filternet","version":"0.0.2","description":"A proxy library that provides easy hooks to manipulate http and https traffic consistently.","repository":"https://github.com/axiak/filternet","homepage":"https://github.com/axiak/filternet","dependencies":{"bufferjs":">= 1.0.0"},"main":"index","license":"BSD","engines":{"node":">= 0.6.0"},"devDependencies":{},"optionalDependencies":{},"_engineSupported":true,"_defaultsLoaded":true,"versions":[{"number":"0.0.1","date":"2012-02-05T14:50:26.693Z"},{"number":"0.0.2","date":"2012-02-05T18:28:59.030Z"}],"readme":"# filternet - A simple way to filter http in node.js\n\nfilternet implements a feature-packed proxy server that allows the coder to intercept and manipulate requests and responses in a consistent manner. filternet is designed to behave consistently with:\n\n- standard HTTP proxy\n- transparent HTTP proxy\n- standard HTTPS proxy (with specified certificates)\n- transparent HTTPS proxy (with specified certificates and SNI)\n- compression for both directions (deflate and gzip, no sdch)\n\n## Quick Examples\n\nSimplest example, everything is blinking!\n\n```js\nvar filternet = require('filternet');\n\nvar myProxy = filternet.createProxyServer();\n\nmyProxy.on(\"interceptResponseContent\", function (buffer, response_object, is_ssl, charset, callback) {\n  var content = buffer.toString('utf8');\n  var css = \"<\"+\"link rel='stylesheet' href='http://axiak.github.com/filternet/blink.css'>\";\n  callback(content.replace(/<\\/head>/i, css + \"</head>\"));\n});\n```\nRun this and it will automatically listen at port 8128.\n\n\nSimple https example:\n\n```js\nvar filternet = require('filternet');\n\nvar sslCerts = {\n   '*.github.com': ['stargithub.key', 'stargithub.crt']\n};\n\nvar myProxy = filternet.createProxyServer({\n   sslCerts: sslCerts,\n   transSslPort: 8129 // enable transparent ssl proxy\n});\n\nmyProxy.on(\"interceptResponseContent\", function (buffer, response_object, is_ssl, charset, callback) {\n   console.log(buffer.toString('utf8'));\n   callback(buffer);\n});\n```\nThis example will work as both a regular HTTPS proxy (via CONNECT) as well as a transparent HTTPS proxy (via SNI). The proxy will log bodies for _all_ HTTP responses, and _only_ HTTPS responses that fit '*.github.com' (note that the asterisk only works one level deep, see the SSL Certificates section).\n\nSee https://github.com/axiak/filternet/blob/master/example/skeletontest.js for a simple showing of available hooks,\nand https://github.com/axiak/filternet/blob/master/example/skeletontest_ssl.js for the same file with SSL intercept support.\n\n## Options\n\nThe main function available is <tt>createProxyServer(opts)</tt> where the options available are:\n\n- port - The port to listen on. Default: 8128\n- hostname - The hostname to listen on. Default: server will accept any\n- via - Either the name to give to the VIA header, or false to squelch the VIA header. Default: filternet/0.0.1\n- enableCompression - Whether or not to enable HTTP compression. If false, the accept-encoding header will tell the remote server to not compress. Default: true\n- recompress - If the response from the server was compressed, this will determine if the proxy will recompress the decompressed content for the client. Default: equal to <tt>enableCompression</tt>\n- sslCerts - The mapping of host description to ssl keys/certificates (see SSL Certificates). Default: {}\n- sslSockDir - If there are sslCerts, this will determine where to put the sockets for the https servers to listen on. Default: '.'\n- transSslPort - If provided, this will be the port to enable the transparent HTTPS proxy. Default: undefined\n\n## Events\n\n### Event: shouldReject <tt>function (request, callback){}</tt>\n\nThis gets called first on every http request or intercepted https request.\nIf you call <tt>callback(true)</tt>, the proxy server will return a 407 response and complete.\n\n\n### Event: enabledCheck <tt>function (callback){}</tt>\n\nThis is used to disable intercepting. If you run callback(false), the proxy server will run as a normal proxy server would. callback(true) will enable your other listeners.\n\nThe default behavior is callback(true)\n\n### Event: interceptRequest <tt>function (request_options, callback)</tt>\n\nrequest_options is a map of data to be sent to http.request. callback expects request_options to continue the request.\n\nThe default behavior is callback(request_options);\n\n### Event: interceptResponseHeaders: <tt>function (request_info, response_status_code, response_headers, callback)</tt>\n\ncallback expects (response_status_code, response_headers). You can use this method if you want to manipulate the response headers before they get sent.\n\nThe default behavior is callback(response_status_code, response_headers);\n\n### Event: shouldInterceptResponse <tt>function (response, callback)</tt>\n\nGiven the response from the remote server, this listener enabled you to decide if the interception should happen or not. Run callback(true) if you intend on intercepting the response content.\n\nThe default behavior is callback(isHtml), where isHtml is true if the content-type is something like text/html.\n\n(The use of the method prevents the proxy server from having to buffer images, etc.)\n\n### Event: interceptResponseContent <tt>function (buffer, proxy_response, is_ssl, charset, callback)</tt>\n\ncallback expects the content buffer or string to send to the client.\n\nis_ssl is true if this interception was performed on an https request.\n\ncharset is a convenience string which is either the charset from the Content-Type header, or null if none was defined. \n\nGenerally, if charset is not null it's safer to run buffer.toString('utf8') to get a string. Otherwise you're probably dealing with binary data.\n\nThe default behavior is callback(buffer);\n\n### Event: error <tt>function (error)</tt>\n\nCalled on any error that is not a clientError\n\nIf not defined errors actually break the proxy server.\n\n### Event: clientError <tt>function (error)</tt>\n\nCalled on any clientError\n\nIf not defined errors actually break the proxy server.\n\n## Compression\n\nHTTP defines compression with the Accept-Encoding header. Intercepting and analysing responses are somewhat incompatible with compression, so this library tries to get around this limitation in two ways:\n\n1. Disable compression entirely\n2. On-the-fly decompression and recompression\n\nIf <tt>enableCompression</tt> is false, then the client's Accept-Encoding header will be rewritten to 'identity' if interception is enabled (see the enabledCheck event). Note that you can't turn off compression for _just_ HTML, as we don't know until the response from the remote server whether or not the document is HTML.\n\nIf <tt>enabledCompression</tt> is true, then the Accept-Encoding is mangled to ensure it contains nothing more than 'gzip','deflate', or 'identity'. Then the remote response headers will indicate if the response is compressed. The response is then decompressed before they are sent to any listeners.\n\nIf <tt>recompress</tt> is enabled, then the potentially manipulated response content is then compressed again, using whatever method (gzip or deflate) was used to decompress from the server. Note that the <tt>recompress</tt> flag determines if the Content-Encoding header is mangled before it's sent to the client.\n\n## HTTPS\n\n### SSL Certificates\n\nThis module doesn't break SSL, and as such can't be used maliciously in conjunction with https.\nBy default, the proxy server will serve https documents transparently without eavesdropping or calling the\nprovided hooks to manipulate requests/responses. To alter this behavior, you need to specify the sslCerts\nmapping:\n\n```js\nfilternet.createProxyServer({sslCerts:\n   { hostDescription: [keyFileName, certificateFileName]}\n   });\n```\n\nThe keyFileName and the certificateFileName are the paths to the SSL key file and certificate file. The hostDescription is one of three things:\n\n- The complete hostname (e.g. 'www.example.com')\n- A wild-card host (e.g. '*.example.com')\n- The default host: '*'\n\nIt's important to note that <tt>'*.example.com'</tt> will match neither <tt>'example.com'</tt> nor <tt>'b.a.example.com'</tt>.\n\nTo create your own certificate authority and sign your own certificates for anything, I found Zach Miller's HOW-TO easy to follow: http://pages.cs.wisc.edu/~zmiller/ca-howto/\n\n### How it works\n\nFor each distinct key file provided, the proxy server will launch a separate node HTTPS server bound to a socket file named based on the key file. (The directory is determined by the <tt>sslSockDir</tt> option.)\n\n#### Standard HTTPS proxy\n\nFor a standard, non-transparent HTTPS proxy the server intercepts a CONNECT statement (with node's upgrade support) and get's the desired host name. If the host name matches one of the <tt>sslCerts</tt>, the proxy server will tunnel the client with the local HTTPS server using that certificate. Otherwise, the proxy server will tunnel with the desired remote server.\n\n#### Transparent HTTPS proxy (SNI)\n\nTransparent HTTPS proxy gets a little bit tricky. When the client sends a TLS handshake (the first packet), the client can specify extensions which are allows to contain the server name field. This is referred to as Server Name Indication or SNI. There's a very simple TLS handshake parser (https://github.com/axiak/filternet/blob/master/lib/sniparse.js) that tries to get the server name from the TLS handshake packet. If successful, the proxy server uses the same rules as it does for the CONNECT promotion: look for a certificate matching the host name pattern and intercept if it matches. \n\nNote that not every HTTPS client supports SNI: notably absent from the list of support is any IE on Windows XP (see http://en.wikipedia.org/wiki/Server_Name_Indication for more information). \n\n## Bugs\n\nI'm sure there are some at the moment. If you encounter any, or if you have any improvements, feel free to file an issue or send a merge request my way.\n\n## Author, License, etc\n\nThe module is licensed under BSD 3-clause and is authored by mike@axiak.net\n","starsCount":1,"created":"2012-02-05T14:50:25.787Z","modified":"2012-02-05T18:28:59.030Z","lastPublisher":{"name":"axiak","email":"mike@axiak.net"},"owners":[{"name":"axiak","email":"mike@axiak.net"}],"other":{"_attachments":{},"_id":"filternet","_nodeVersion":"v0.6.10","_npmUser":{"name":"axiak","email":"mike@axiak.net"},"_npmVersion":"1.1.0-3","_rev":"1-840ed960f60e4dcd228bd99336bd16a6","author":{"name":"Mike Axiak","email":"mike@axiak.net"},"bugs":{"name":"https://github.com/axiak/filternet/issues"},"directories":{},"dist-tags":{"latest":"0.0.2"},"dist":{"shasum":"3790e331edc73142cc3f6c2df19f30945dc31539","tarball":"http://registry.npmjs.org/filternet/-/filternet-0.0.2.tgz"},"maintainers":[{"name":"axiak","email":"mike@axiak.net"}],"time":{"modified":"2012-02-05T18:28:59.030Z","created":"2012-02-05T14:50:25.787Z","0.0.1":"2012-02-05T14:50:26.693Z","0.0.2":"2012-02-05T18:28:59.030Z"},"users":{"sohil":true}}}