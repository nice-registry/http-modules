{"name":"rpc-multiauth","version":"0.0.2","dependencies":{"clone":"^1.0.2","cookie":"^0.2.3","cookie-cutter":"^0.1.1","detect-node":"^2.0.3","extend":"^3.0.0","jsonwebtoken":"^5.4.0","store":"^1.3.17","xhr":"^2.1.0"},"license":"AGPL-1.0","gitHead":"df9203fda7b1144e97241530fac825a398446323","description":"rpc-multiauth is simple token-based authentication and access control for both RPC over http sockets and traditional http queries.","scripts":{},"versions":[{"number":"0.0.1","date":"2015-11-14T09:46:54.847Z"},{"number":"0.0.2","date":"2017-02-10T00:21:24.282Z"}],"readme":"\nrpc-multiauth is simple token-based authentication and access control for both RPC over http sockets and traditional http queries.\n\nrpc-multiauth provides optional cookie-based authentication, still using tokens, to support authenticated traditional queries when client side control over headers isn't possible (e.g. automatic loading of images for <img> tags)..\n\nrpc-multiauth also provides client-side helper methods for authenticated XMLHTTPRequests without cookies by wrapping the [xhr](https://www.npmjs.com/package/xhr) module.\n\nrpc-multiauth works especially well with the npm modules [routes](https://www.npmjs.com/package/routes) and [rpc-multistream](https://www.npmjs.com/package/rpc-multistream), but can be used alone or with other modules.\n\n# RPC authentication\n\n## Server side\n\n```\nvar auth = require('rpc-multiauth');\n\nvar rpcServer = rpc(auth(\n  { // the following options _must_ be set\n    secret: 'my_unique_secret_string',\n    login: function(data, cb) {\n      if(!isValidUserAndPassword(data)) return cb(\"Invalid username or passsword\");      cb();\n    }\n\n  }, { // RPC functions\n    // no namespace\n    foo: function(cb) {\n      console.log(\"foo called\");\n      cb(null, \"foo says hi\");\n    },\n\n    // namespaced functions\n    user: {\n      bar: function(cb) {\n\n      }\n    }, \n\n    // more namespaced functions\n    admin: {\n      baz: function(cb) {\n\n      }\n    }\n\n\n  // can be either:\n  // * undefined: In which case all namespaced functions just require login\n  // * string: In which case user[string] must match the namespace name (which can be a regex)\n  // * function: receives (userData, namespace, functionName, cb) and calls back with an error if access is denied or nothing/null/undefined if access is granted\n  }, function(userData, namespace, functionName, callback) {\n\n  });\n```\n\nWhen auth fails for async functions, if the last argument is a function, it is assumed to be a callback with the first argument being an optional error and is called with an \"Unauthorized\" error.\n\nNote: Currently there is no real error reporting when auth fails for a sync function. The server will spit out a console.error and null will be returned. We need to solve [this issue](https://github.com/Juul/rpc-multistream/issues/2) so we can throw exceptions that propagate to the client.\n\n## Client side\n\nSimlpe usage:\n\n```\nvar auth = require('rpc-multiauth');\n\nfunction rpcConnected(remote) {\n\n  auth.authenticate(remote, function(err, userData) {\n    if(err) {\n      console.log(\"Not logged in\");\n    } else {\n      console.log(\"Logged in as: \" + userData.name);\n    }\n  });\n\n  loginBtn.addEventListener('click', function() {\n\n    auth.login(remote.login, {\n      user: 'marc@juul.io',\n      password: 'foo'\n    }, function(err, token, userData) {\n       // do stuff \n    });\n\n  });\n}\n```\n\nWith opts:\n\n```\nvar auth = require('rpc-multiauth');\n\nfunction rpcConnected(remote) {\n\n  auth.authenticate(remote, {\n      // These are the default options:\n      // Assuming token is not set\n      // auth.authenticate will check LocalStorage and cookies for the auth token\n      token: undefined, // optionally explicitly pass a token\n      setCookie: false, // whether to save token in cookie on client side\n      tokenName: 'AuthToken', // cookie name and/or localstorage key to use\n      useLocalStorage: true, // true to save token using LocalStorage\n      httpMethod: 'POST', // which method to use if using http requests\n      tokenHeader: 'authorization' // header to use for token, set\n    }, function(err, userData) {\n    if(err) {\n      console.log(\"Not logged in\");\n    } else {\n      console.log(\"Logged in as: \" + userData.name);\n    }\n  });\n\n  loginBtn.addEventListener('click', function() {\n\n    auth.login(remote.login, {'marc@juul.io', 'foo'}, { \n      // optional opts argument with defaults shown\n      setCookie: false, // save the cookie on the client side\n      useLocalStorage: true, // whether to save token in LocalStorage\n      tokenName: 'Token', // cookie name and/or localstorage key to use\n      tokenHeader: 'authorization' // header to use for token, set\n    }, function(err, token, userData) {\n       // do stuff \n    });\n\n  });\n}\n```\n\nSee examples/ for more info.\n\n# HTTP request authentication\n\n## Server side\n\nBasic usage:\n\n```\nvar myAuth = auth(settings.secret);\n\nhttp.createServer(function(req, res) {\n\n    if(req.url == '/login') {\n        res.setHeader(\"Content-Type\", \"text/plain\");\n\n        // Your own function to check if the login info is valid\n        checkLogin(req, function(err, userData) {\n            if(err) {\n                res.statusCode = 400;\n                res.end(\"Login error: \" + err);\n                return;\n            }\n\n            // log the user in\n            myAuth.login(res, userData.id, userData, function(err, token) {\n                if(err) {\n                    res.statusCode = 400;\n                    res.end(\"Login error: \" + err);\n                    return;\n                }\n                res.end(token);\n            });\n        })    \n    } else if(req.url == '/private') {\n        res.setHeader(\"Content-Type\", \"text/plain\");\n\n        myAuth(req, function(err, tokenData) {\n            if(err) {\n                res.statusCode = 401;\n                res.end(\"Unauthorized: \" + err);\n                return;\n            }\n            res.end(\"Yay you are authorized!\");\n        });\n    }\n});\n```\n\nInitializing auth for HTTP with options:\n\n```\nvar myAuth = auth({\n  secret: null, // must be set to your unique secret\n  tokenExpiration: 336, // how long from creation does token expire (hours)\n  cookie: {\n    setCookie: true, // set cookie on server side\n    httpOnly: false, // use httpOnly cookies\n    secure: false, // use secure cookies (https only)\n    // additional opts:\n    // domain: restrict auth cookies to this domain\n    // path: restrict auth cookies to this path\n    // firstPartyOnly: see RFC6265\n    // maxAge: relative max age of the cookie from when the client receives it\n  },\n  allowCookieToken: 'AuthToken', // name of the cookie or false\n  allowHeaderToken: 'authorization' // name of header or false\n});\n```\n\nUse as middleware with the routes package:\n\n```\nvar myAuth = auth('MY_TOKEN_SECRET');\n\n// Assume that login is implemented similarly to previous examples\n\n// Routes \nmyrouter.addRoute('/users-only/*?', myAuth);\n\nmyrouter.addRoute('/users-only/profile', function(req, res, match, userData) {\n  res.end(\"Profile page for user: \" + userData.name);\n});\n```\n\nOr with multiple auth levels:\n\n```\nvar userAuth = auth('MY_TOKEN_SECRET');\n\n// inherit options from userAuth but add a check\nvar adminAuth = userAuth.inherit({\n  check: function(req, res, match, userData, callback) {\n    if(userData.group != 'admin') {\n      return callback(\"You are not an admin\");\n    }\n    callback();\n  }\n});\n\nmyrouter.addRoute('/', function(req, res, match) {\n  res.end(\"Welcome to the main page!\");\n});\n\n// Verify that user is logged in\nmyrouter.addRoute('/users-only/*?', userAuth);\nmyrouter.addRoute('/users-only/profile', function(req, res, match, userData) {\n  res.end(\"Profile page for user: \" + userData.name);\n});\n\n// Verify that user is logged in and is an admin\nmyrouter.addRoute('/admins-only/*?', adminAuth);\nmyrouter.addRoute('/admins-only/settings', function(req, res, match, userData) {\n  res.end(\"Insert admin settings page here\");\n});\n\n// Default route\nmyrouter.addRoute('/*', function(req, res, match) {\n  res.statusCode = 404;\n  res.end(\"Page not found\");\n});\n\n```\n\n## Client side\n\nIf you haven't disabled cookies, then after logging in you will simply be able to access protected URLs with normal HTTP requests.\n\nIf you have disabled cookies (or simply prefer not to use it), then you can instantiate an http requester that will automatically send the token in a custom authentication header with each request:\n\n```\nvar req = auth.requester();\n```\n\nThe simple usage above will automatically find any auth tokens saves as Cookies or in LocalStorage.\n\n\nor with options:\n\n```\nvar req = auth.requester({ \n  tokenHeader: 'Authorization', // name of header field to use for auth token. if false, disable sending of auth token using its own header field (rely on cookies only)\n  tokenName: 'AuthToken', // name of cookie and/or localstorage field to look for\n  token: undefined // explicitly set an auth token to use. if not set then requester will look for token in cookie and LocalStorage\n});\n```\n\nThe result req function is simply a wrapped version of (xhr)[https://www.npmjs.com/package/xhr] that sends along the auth token in a header (unless tokenHeader was set to false) and optionally takes the additional option:\n\n```\n  {\n    token: 'my_token'\n  }\n```\n\nin case you want to explicitly define a per-request token.\n\nExample usage: \n\n```\nvar auth = require('rpc-multiauth');\n\nvar req = auth.requester({json: true});\n\nreq.post({\n  uri: '/intergalactic',\n  body: {\n    cookie: 'cat'\n  }\n}, function(err, resp, body) {\n   if(err) return console.error(\"Request failed:\", err);\n   console.log(\"Got response:\", body);\n});\n```\n\n# Examples\n\nThere are a bunch of complete examples in the `examples/` dir. \n\nTo try an example do s:\n\n```\ncd examples/rpc_simple/\nnpm install\nnpm run build\nnpm start\n```\n\nThen open `http://localhost:3000/` in your browser.","created":"2015-11-14T09:46:54.847Z","modified":"2017-02-10T00:21:24.282Z","lastPublisher":{"name":"juul","email":"juul@sudomesh.org"},"owners":[{"name":"juul","email":"juul@sudomesh.org"}],"other":{"_attachments":{},"_from":".","_id":"rpc-multiauth","_nodeVersion":"4.4.2","_npmOperationalInternal":{"host":"packages-12-west.internal.npmjs.com","tmp":"tmp/rpc-multiauth-0.0.2.tgz_1486686084036_0.27946226950734854"},"_npmUser":{"name":"juul","email":"juul@sudomesh.org"},"_npmVersion":"2.15.0","_rev":"2-e031951717fcb375673a916186ce6ae1","_shasum":"e98e924c5e733e83f367cca5a3154193bd844c07","directories":{},"dist-tags":{"latest":"0.0.2"},"dist":{"shasum":"e98e924c5e733e83f367cca5a3154193bd844c07","tarball":"https://registry.npmjs.org/rpc-multiauth/-/rpc-multiauth-0.0.2.tgz"},"maintainers":[{"name":"juul","email":"juul@sudomesh.org"}],"readmeFilename":"README.md","time":{"modified":"2017-02-10T00:21:24.282Z","created":"2015-11-14T09:46:54.847Z","0.0.1":"2015-11-14T09:46:54.847Z","0.0.2":"2017-02-10T00:21:24.282Z"}}}