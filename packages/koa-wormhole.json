{"name":"koa-wormhole","version":"0.5.0","description":"A http request router for Koa","main":"src/index.js","scripts":{"test":"NODE_ENV=test mocha --reporter spec","autotest":"NODE_ENV=test mocha --watch --reporter spec"},"repository":"https://github.com/danneu/koa-wormhole","keywords":["routing","koa"],"license":"MIT","homepage":"https://github.com/danneu/koa-wormhole","dependencies":{"better-assert":"1.0.2","debug":"2.2.0","is-generator-function":"^1.0.3","koa-compose":"2.3.0","lodash":"3.10.1","methods":"1.1.1","path-to-regexp":"1.2.1"},"devDependencies":{"async":"^1.5.0","chai":"^3.4.0","eslint":"^1.8.0","eslint-config-volox":"^1.0.2","koa":"^1.1.1","koa-bodyparser":"^2.0.1","koa-bouncer":"^4.2.0","mocha":"^2.3.3","supertest":"^1.1.0"},"gitHead":"250bb05af435d326cd94dfeabffe7c8a8fbddf47","versions":[{"number":"0.0.1","date":"2015-11-05T08:45:38.229Z"},{"number":"0.1.0","date":"2015-11-05T09:31:36.062Z"},{"number":"0.2.0","date":"2015-11-05T10:04:43.800Z"},{"number":"0.3.0","date":"2015-11-05T11:50:48.865Z"},{"number":"0.4.0","date":"2015-11-06T00:28:56.788Z"},{"number":"0.5.0","date":"2015-11-06T09:08:35.459Z"}],"readme":"\n# koa-wormhole\n\n[![Build Status](https://travis-ci.org/danneu/koa-wormhole.svg?branch=master)](https://travis-ci.org/danneu/koa-wormhole)\n[![NPM version](https://badge.fury.io/js/koa-wormhole.svg)](http://badge.fury.io/js/koa-wormhole)\n[![Dependency Status](https://david-dm.org/danneu/koa-wormhole.svg)](https://david-dm.org/danneu/koa-wormhole)\n\nA simple, predictable, low-performance router for\n[Koa](http://koajs.com/) similar to koa-router and Express 4's built-in router.\n\n    npm install --save koa-wormhole\n\n## Quickstart\n\n``` javascript\nconst Router = require('koa-wormhole');\nconst app = require('koa')();\n\nconst router1 = new Router();\nrouter1.use(function*(next) { console.log('inside router1'); yield* next; });\nrouter1.get('/', ...);\n\nconst router2 = new Router();\nrouter2.get('/users', ...);\nrouter2.post('/users', ...);\nrouter2.get('/users/:username', ...);\n\napp.use(router1.middleware());\napp.use(router2.middleware());\napp.listen(3000, () => console.log('listening on 3000'));\n```\n\nRouter middleware (middleware mounted via `router.use(...)`) are only run\nif the request matches any of the router's routes. Else, the router is\nskipped.\n\n## Usage\n\nYou can find a lot of examples in koa-wormhole's tests:\nhttps://github.com/danneu/koa-wormhole/blob/master/test/index.js\n\n### Basics\n\nJust like a koa instance, a router instance has `router.use(...middleware)`\nthat takes one or more middleware generator functions.\n\n``` javascript\nconst mw1 = function*(next) {\n  console.log('executing mw1');\n  yield* next;\n};\n\nconst mw2 = function*(next) {\n  console.log('executing mw2');\n  yield* next;\n};\n\nrouter.use(mw1, mw2);\n\napp.use(router.middleware());\n```\n\nHowever, a router's top-level middleware will not run unless the request\nmatches one of the router's routes.\n\nLet's define a route for the above example.\n\n``` javascript\nrouter.use(mw1, mw2);\n\nrouter.get('/test', function*() {\n  console.log('executing GET /test');\n  this.body = 'hello world';\n});\n\napp.use(router.middleware());\n```\n\nSince the two middleware were mounted before the route, they will run \nbefore the route:\n\n```\n$ curl http://localhost:3000/test\n// executing mw1\n// executing mw2\n// executing GET /foo\n//=> 'hello world'\n```\n\nAnd, unlike in koa-router, mount order matters in koa-wormhole. \n\nIf we mount the route before the middleware, then the middleware will not\nget to execute unless the route `yield* next`. \n\nThis is just predictable middleware behavior.\n\n``` javascript\nrouter.get('/test', function*() {\n  console.log('executing GET /test');\n  this.body = 'hello world';\n});\n\nrouter.use(mw1, mw2);\n\napp.use(router.middleware());\n```\n\n```\n$ curl http://localhost:3000/test\n// executing GET /foo\n//=> 'hello world'\n```\n\nAnd here's an example of what that behavior looks like when we yield next\nfrom a route handler. The request will continue down the stack, possibly\nmatching downstream handlers.\n\n``` javascript\nrouter.get('/test', function*(next) {\n  console.log('executing handler1 and yielding next');\n  yield* next;\n});\n\nrouter.get('/test', function*(next) {\n  console.log('executing handler2 and responding');\n  this.body = 'ok';\n});\n\napp.use(router.middleware());\n```\n\n```\n$ curl http://localhost:3000/test\n// executing handler1 and yielding next\n// executing handler2 and responding\n//=> 'ok'\n```\n\nYou can also mount middleware to a specific route to be run before the\nhandler:\n\n``` javascript\nrouter.get('/test', mw1, mw2, function*() {\n  console.log('executing handler');\n  this.body = 'ok';\n});\n```\n\n```\n$ curl http://localhost:3000/test\n// executing mw1\n// executing mw2\n// executing handler\n//=> 'ok'\n```\n\nAnd it handles flattens out arrays. These are all the same:\n\n``` javascript\nrouter.get('/test', mw1, mw2, mw3, mw4, mw5);\nrouter.get('/test', [mw1, mw2, mw3, mw4], mw5);\nrouter.get('/test', mw1, [mw2], mw3, [mw4, mw5]);\nrouter.get('/test', [mw1, mw2, mw3, mw4, mw5]);\n```\n\n### URL params\n\nkoa-wormhole uses [path-to-regexp][path-to-regexp] to turn route paths\ninto regular expressions, so it has the same syntax as Express4's router\nand koa-router.\n\nRead its docs for more examples.\n\nkoa-wormhole exposes URL params via the `this.params` object. \n\n[path-to-regexp]: https://github.com/pillarjs/path-to-regexp\n\n``` javascript\nrouter.get('/users/:id', function*() {\n  const user = yield database.findUserById(this.params.id);\n  this.assert(user, 404);\n\n  yield this.render('show_user.html', {\n    ctx: this,\n    user: user\n  });\n});\n```\n\n### URL param middleware\n\nYou can DRY up repetitive logic with `Router#param(key, middleware)`.\n\nFor example, it's useful for auto-loading resources.\n\n``` javascript\nrouter.param('user_id', function*(val, next) {\n  this.resource = yield db.findUserById(val);\n  this.assert(this.resource, 404);\n  yield* next;\n});\n\n// `this.resource` is now guaranteed to exist in these handlers\nrouter.get('/users/:user_id', ...);\nrouter.get('/users/:user_id/edit', ...);\nrouter.del('/users/:user_id', ...);\nrouter.put('/users/:user_id', ...);\n\n// and the param middleware will not be called for these\nrouter.get('/users', ...);\nrouter.post('/users', ...);\n```\n\n### Method chaining\n\n`Router#use` and all of the `Router#{verb}`s return the router instance,\nso you can chain them if you'd like.\n\n``` javascript\nrouter\n  .get('/users', listUsers)\n  .get('/users/:id', showUser)\n  .use(ensureAdmin)  // <-- only applies to downstream routes\n  .del('/users/:id', deleteUser);\n  .get('/users/:id/admin-panel', administrateUser);\n\napp.use(router.middleware());\n```\n\n### Nested Routers\n\n3-layers deep:\n\n``` javascript\nconst app = koa();\nconst r1 = new Router(), r2 = new Router(), r3 = new Router();\n\nr3.get('/', function*(next) {\n  this.body = 'hello, world!';\n});\nr2.use(r3.middleware());\nr1.use(r2.middleware());\napp.use(r1.middleware());\n\napp.listen(3000, () => console.log('listening on 3000'));\n```\n\n```\ncurl http://localhost:3000\n// hello, world!\n```\n\n## General idea\n\nI thought it'd be fun to implement a router with\n[koa-compose](https://github.com/koajs/compose), composing one long chain\nof generator middleware for each router.\n\nGoals:\n\n- Predictable behavior\n- Simple implementation\n\n## koa-wormhole vs Express 4's built-in router\n\n- Express 4's routing docs: http://expressjs.com/guide/routing.html\n\nThe key difference is that koa-wormhole only pipes a request through a mounted\nrouter if the request actually matches one of the router's routes.\n\nConsider this Express example:\n\n``` javascript\n// ------------------------------------------------------------\n// router.js\n// ------------------------------------------------------------\nconst router = require('express').Router();\n\nrouter.use((req, res, next) {\n  console.log('inside router middleware');\n  next();\n});\n\nrouter.get('/router', (req, res, next) => {\n  res.send('inside router route');\n});\n\nmodule.exports = router;\n\n// ------------------------------------------------------------\n// server.js\n// ------------------------------------------------------------\nconst app = require('express')();\nconst router = require('./router');\n\napp.use(router);\napp.get('/', (req, res) => {\n   res.send('homepage');\n});\napp.listen(3000, () => console.log('express listening on 3000'));\n```\n\nIn Express, requests are always piped through routers, so top-level\nrouter middleware will always execute:\n\n```\n$ curl http://localhost:3000\n// inside router middleware\n//=> 'homepage'\n\n$ curl http://localhost:3000/router\n// inside router middleware\n//=> 'inside router route'\n```\n\nNotice that the route's top-level middleware is always run.\n\nNow let's look at the exact same example in koa-wormhole:\n\n``` javascript\n// ------------------------------------------------------------\n// router.js\n// ------------------------------------------------------------\nconst router = require('koa-wormhole')();\n\nrouter.use(function*(next) {\n  console.log('inside router middleware');\n  yield* next;\n});\n\nrouter.get('/router', function*(next) {\n  this.body = 'inside route route';\n});\n\nmodule.exports = router;\n\n// ------------------------------------------------------------\n// server.js\n// ------------------------------------------------------------\nconst app = require('koa')();\nconst router = require('./router');\n\napp.use(router.middleware());\napp.get('/', function*() {\n   this.body = 'homepage';\n});\napp.listen(3000, () => console.log('koa listening on 3000'));\n```\n\n```\n$ curl http://localhost:3000\n//=> 'homepage'\n\n$ curl http://localhost:3000/router\n// inside router middleware\n//=> 'inside router route'\n```\n\nkoa-wormhole skips over the router when requesting the homepage since\nthe router had no matching route.\n\nWhy?\n\nI just find this behavior more useful, and it's what I'm used to\nwith koa-router.\n\nI initially considered solutions that let you distinguish between\nrouter middleware that always runs and router middleware that only runs\non router match, but I couldn't think of a use-case for that behavior.\n\n## koa-wormhole vs koa-router\n\nkoa-router has some undefined behavior and unexpected idiosyncrasies.\n\nOne example is that top-level koa-router middleware are always run\nbefore the matched handler. Consider this koa-router example:\n\n``` javascript\nrouter.get('/', function*() {\n  console.log('executing router GET / handler');\n  this.body = 'ok';\n});\n\nrouter.use(function*(next) {\n  console.log('executing router middleware 1');\n  yield* next;\n});\n\nrouter.use(function*(next) {\n  console.log('executing router middleware 2');\n  yield* next;\n});\n\nrouter.use(function*(next) {\n  console.log('executing router middleware 3');\n  yield* next;\n});\n```\n\n```\n$ curl http://localhost:3000\n// executing router middleware 1\n// executing router middleware 2\n// executing router middleware 3\n// executing router GET / handler\n//=> 'ok'\n```\n\nI find this behavior unexpected and counter-intuitive. I'd expect the 'GET /'\nhandler to execute first and only call the downstream middleware if\nit yields next, which is what koa-wormhole will do.\n\nThis may be a bug: https://github.com/alexmingoia/koa-router/issues/194\n\nI tried to improve upon koa-router by following standard middleware\nintuition like declaration-order sensitivity.\n\n## License\n\nMIT\n","created":"2015-11-05T08:45:38.229Z","modified":"2015-11-06T09:08:35.459Z","lastPublisher":{"name":"danneu","email":"danrodneu@gmail.com"},"owners":[{"name":"danneu","email":"danrodneu@gmail.com"}],"other":{"_attachments":{},"_from":".","_id":"koa-wormhole","_nodeVersion":"5.0.0","_npmUser":{"name":"danneu","email":"danrodneu@gmail.com"},"_npmVersion":"3.3.6","_rev":"1-6d2121e03ec37f8670de64d68af7d5d3","_shasum":"46bdfbabc105283d1a62637722257b22503a2683","author":{"name":"Dan Neumann","email":"danrodneu@gmail.com","url":"https://github.com/danneu"},"bugs":{"url":"https://github.com/danneu/koa-wormhole/issues"},"directories":{},"dist-tags":{"latest":"0.5.0"},"dist":{"shasum":"46bdfbabc105283d1a62637722257b22503a2683","tarball":"http://registry.npmjs.org/koa-wormhole/-/koa-wormhole-0.5.0.tgz"},"maintainers":[{"name":"danneu","email":"danrodneu@gmail.com"}],"readmeFilename":"README.md","time":{"modified":"2015-11-06T09:08:35.459Z","created":"2015-11-05T08:45:38.229Z","0.0.1":"2015-11-05T08:45:38.229Z","0.1.0":"2015-11-05T09:31:36.062Z","0.2.0":"2015-11-05T10:04:43.800Z","0.3.0":"2015-11-05T11:50:48.865Z","0.4.0":"2015-11-06T00:28:56.788Z","0.5.0":"2015-11-06T09:08:35.459Z"}}}