{"name":"fireque","version":"0.5.4","description":"Fireque ======= 是一個用於處理大量request的解決方案, 透過fireque可以將大量的request在background分散至多個worker同時處理, 以達到提高處理效率的目標, 並且可以成功接受request, 但尚未處理, 將會在最短時間內進行處理的效果.（Ex. Http code 202）","main":"index.js","scripts":{"test":"mocha --reporter dot"},"keywords":["redis","queue"],"repository":"https://github.com/yutin1987/node-fireque","bin":{"fireque":"./bin/fireque"},"dependencies":{"redis":"~0.10.0","hiredis":"~0.1.16","node-uuid":"~1.4.1","async":"~0.2.10","commander":"~2.1.0","charm":"~0.2.0","printf":"~0.1.2"},"devDependencies":{"mocha":"~1.17.1"},"homepage":"https://github.com/yutin1987/node-fireque","versions":[{"number":"0.0.1","date":"2014-01-27T07:42:25.705Z"},{"number":"0.0.3","date":"2014-02-12T02:53:33.621Z"},{"number":"0.4.0","date":"2014-02-21T09:26:38.679Z"},{"number":"0.4.1","date":"2014-02-21T10:01:46.827Z"},{"number":"0.5.0","date":"2014-03-04T05:38:07.642Z"},{"number":"0.5.1","date":"2014-03-13T03:10:51.423Z"},{"number":"0.5.2","date":"2014-03-13T03:32:29.677Z"},{"number":"0.5.3","date":"2014-03-13T03:38:07.590Z"},{"number":"0.5.4","date":"2014-03-13T03:40:24.142Z"}],"readme":"Fireque\n=======\n是一個用於處理大量request的解決方案, 透過fireque可以將大量的request在background分散至多個worker同時處理, 以達到提高處理效率的目標, 並且可以成功接受request, 但尚未處理, 將會在最短時間內進行處理的效果.（Ex. Http code 202）\n\n通常用於**大量的圖片需要resize**, **大量的抓取資料**, **大量的發送訊息**, **排程資料分析**.\n\n## 特色\n- 可同時多個Worker/Consumer\n- 可依據protectKey限制同類型的Job, 最大的Worker數\n- 支援三個(high/med/low)等級的優先權(priority), 和最高等級的插單\n- 可指定schedule, 並依指定的時間執行.\n- 支援namespace設定\n\n[![Build Status](https://api.travis-ci.org/yutin1987/node-fireque.png)](https://travis-ci.org/yutin1987/node-fireque)\n\n## Install [![NPM version][npm-image]][npm-url]\n```\nnpm install fireque\n```\n\n> 安裝 [Redis](http://redis.io/) 請參考 [Redis安裝](http://redis.io/download)\n\n> Package使用[node_redis](https://github.com/mranney/node_redis)作為操作redis的library\n\n## Usage\n\n```\nvar Fireque = require('fireque');\n\nvar worker = new Fireque.Worker('addition');\nworker.onPerform( function (job, callback) {\n\tjob.data.ans = job.data.x + job.data.y;\n\tcallback(false);\n});\n\nvar job = new Fireque.Job('addition', {x: 1, y: 1});\njob.enqueue();\n\nconsumer = new Fireque.Consumer('addition');\n\nconsumer.onCompleted( function (jobs, callback) {\n\tvar x = jobs[0].data.x;\n\tvar y = jobs[0].data.y;\n\tvar ans = jobs[0].data.ans;\t\n   \tconsole.log(x + '+' + y + '=' + ans);\n   \tcallback();\n});\n```\n\n## Example\n\n[Protect](https://github.com/yutin1987/node-fireque/blob/master/example/protect.js) ProtectKey保護, 同時間最多3個worker\n\n[Schedule](https://github.com/yutin1987/node-fireque/blob/master/example/schedule.js) Schedule設定, 每5秒執行10個job\n\n## Global Config\n\n`Fireque.host = '127.0.0.1'`\n\n> Redis的address\n\n`Fireque.port = '6379'`\n\n> Redis的port\n\n`Fireque.databaseIndex = 0`\n\n> 指定Redis的資料庫編號\n\n`Fireque.namespace = 'noame'`\n\n> Fireque存放在Redis的namespace\n\n\nObject\n=======\n\n## Job\n\n`new Job(protocol, data, option)`\n> 建立一個新的Job, 物件初始化並不會將Job放入Queue\n\n`new Job(uuid, callback, option)`\n> 從database取出已經存在的Job, 必須要有UUID\n\n### 將Job放入Queue\n\n`enqueue(callback())`\n> 將Job放入Queue, 優先權(預設med)和protectKey(預設unrestricted)都使用預設\n\n**優先權(Priority)**\n\n`enqueue(\"high|med|low\", callback())`\n> 將Job放入Queue, 並指定優先權\n\n`enqueue(\"1|0|-1\", callback())`\n> 將Job放入Queue, 並指定優先權\n\n`enqueue(\"high|med|low\", {protectKey: 'key'}, callback())`\n> 將Job放入Queue, 並指定優先權和protectKey保護\n\n`enqueue(\"1|0|-1\", {protectKey: 'key'}, callback())`\n> 將Job放入Queue, 並指定優先權和protectKey保護\n\n**排程(Schedule)**\n\n`enqueueAt(new Date(), callback())`\n> 將Job放入Queue, 並指定schedule的日期時間\n\n`enqueueAt(Number, callback())`\n> 將Job放入Queue, 並指定幾秒後執行\n\n`enqueueAt(new Date(), {protectKey: 'key'}, callback())`\n> 將Job放入Queue, 並指定schedule的日期時間和protectKey保護\n\n`enqueueAt(Number, {protectKey: 'key'}, callback())`\n> 將Job放入Queue, 並指定幾秒後執行和protectKey保護\n\n**最高等級插單(Top)**\n\n`enqueueTop(callback())`\n> 將Job放入Queue, 當有Worker閒置時, 立即執行\n\n### 將Job從Queue移除\n\n`dequeue(callback())`\n> 將此Job從Queue中移除, 當job正在處理中(processing)會無法移除\n\n### 將Job重新放入Queue, 原本在Queue的Job將會移除\n\n`requeue( ... )`\n> 將Job重新放入Queue, 參數請參考enqueue\n\n`toCompleted()`\n> 將此Job移至完成清單\n\n`toFailed()`\n> 將此Job移至失敗清單\n\n## Work\n\n`new Wrok(protocol, option)`\n> 建立一個新的Worker, 物件初始化並不會立即接受Job\n\n```\noption = {\n  workload: 100,\n  workinghour: 30 * 60,\n  timeout: 60,\n  priority: ['high','high','high','med','med','low'],\n}\n```\n> workload - Work的最大工作量, 預設是100個job\n\n> workinghour - Work的最長的工作時間, 預設是30min\n\n> timeout - 當worker多久未回應代表已超時, 必須發出警告, 預設是1min\n\n> priority - 執行優先權的順序, 預設每次執行3個high, 2個med 和 1個low. 當Keeper有啟動時, 此設定等同無效\n\n`onPerform(function(job, callback))`\n> 設定處理Job的handler, 並開始接受委派的job\n\n> callback(null); 完成, 但不處理\n\n> callback(false); 完成, 並呼叫toFailed()\n\n> callback(true); 失敗, 並呼叫toCompleted()\n\n> 執行過程中發生throw, 會自動送至toFailed()\n\n`offPerform(callback())`\n> 移除處理Job的handler, 並停止接受委派的job, 正在處理中Job的handler會直至處理完為止.\n\n`onWorkOut(callback())`\n> 當Worker已超過工作量or超過工作時間, Worker將停止運作, 並拋出workout handler.\n\n## Consumer\n\n`new Consumer(protocol, option)`\n> 建立一個新的Consumer, 用於取得已完成or已失敗的Job, 並對timeout的job發出警告\n\n```\noption = {\n  max_wait: 30\n  max_count: 10\n}\n```\n> max_wait - 等待最久幾秒呼叫一次handler, 預設是30sec\n\n> max_count - 當到達多少數量時立即呼叫一次handler, 預設是10筆job\n\n`onCompleted(function([job, ...], callback()), option)`\n> 取得已處理完的Job, 並從清單中移除\n\n> 注意！必須要呼叫callback(), 才會繼續取得已完成的job.\n\n`onFailed(function([job, ...], callback()), option)`\n> 取得已失敗的Job, 並從清單中移除\n\n> 注意！必須要呼叫callback(), 才會繼續取得已失敗的job.\n\n`onTimeout(function([job, ...]), option)`\n> 取得已超時的Job, 但不清除處理中(processing)的清單\n\n> 注意！必須要呼叫callback(), 才會繼續檢查已超時的job.\n\n## Keeper\n\n`new Keeper(protocol, workload, option)`\n> 建立一個新的Keeper, 當Queue需要支援protectKey或Schedule時, 就必須執行至少1個Keeper\n\n> 亦可透過cli模式, 執行 fireque keeper\n\n```\noption = {\n  workload: 5\n  priority: ['high','high','high','med','med','low']\n}\n```\n> workload - 每個protectKey最大的worker數量, 預設是5個worker\n\n> priority - 執行優先權的順序, 預設每次執行3個high, 2個med 和 1個low.\n\n`start(function(err, reply), interval)`\n> 開始執行Keeper\n\n`stop()`\n> 停止執行Keeper\n\n[npm-url]: https://npmjs.org/package/fireque\n[npm-image]: https://badge.fury.io/js/fireque.png","created":"2014-01-27T07:42:25.705Z","modified":"2014-03-13T03:40:24.142Z","lastPublisher":{"name":"yutin1987","email":"yuting1987@gmail.com"},"owners":[{"name":"yutin1987","email":"yuting1987@gmail.com"}],"other":{"_attachments":{},"_from":".","_id":"fireque","_npmUser":{"name":"yutin1987","email":"yuting1987@gmail.com"},"_npmVersion":"1.3.21","_rev":"1-f93f6f66b477a0bcdfb316bf03e6058a","author":{"name":"YuTin","email":"yuting1987@gmail.com"},"bugs":{"url":"https://github.com/yutin1987/node-fireque/issues"},"directories":{},"dist-tags":{"latest":"0.5.4"},"dist":{"shasum":"c6280ab7b13b0c94960a2ffaaec63a0e3c287afa","tarball":"http://registry.npmjs.org/fireque/-/fireque-0.5.4.tgz"},"maintainers":[{"name":"yutin1987","email":"yuting1987@gmail.com"}],"readmeFilename":"README.md","time":{"modified":"2014-03-13T03:40:24.142Z","created":"2014-01-27T07:42:25.705Z","0.0.1":"2014-01-27T07:42:25.705Z","0.0.3":"2014-02-12T02:53:33.621Z","0.4.0":"2014-02-21T09:26:38.679Z","0.4.1":"2014-02-21T10:01:46.827Z","0.5.0":"2014-03-04T05:38:07.642Z","0.5.1":"2014-03-13T03:10:51.423Z","0.5.2":"2014-03-13T03:32:29.677Z","0.5.3":"2014-03-13T03:38:07.590Z","0.5.4":"2014-03-13T03:40:24.142Z"}}}