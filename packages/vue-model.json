{"name":"vue-model","version":"0.0.3","description":"A Javascript plugin for the excellent Vue.js framework that gives you the ability to transform your plain data into rich models with built-in and customizable HTTP actions.","main":"src/VueModel.js","scripts":{"test":"echo \"Error: no test specified\" && exit 1"},"repository":"https://github.com/aarondfrancis/vue-model","keywords":["vuejs","vue","model","restful"],"license":"MIT","homepage":"https://github.com/aarondfrancis/vue-model#readme","dependencies":{"lodash":"^4.13.1"},"versions":[{"number":"0.0.1","date":"2016-06-07T22:38:23.476Z"},{"number":"0.0.2","date":"2016-06-07T23:11:42.572Z"},{"number":"0.0.3","date":"2016-06-07T23:12:46.163Z"}],"readme":"## About\nVue-model is a Javascript plugin for Vue.js that gives you the ability to transform your plain data into rich models with built-in and customizable HTTP actions. \n\nThis project started because I work in Vue relatively often and really really wanted to be able to call `customer.save()`, have it `POST` the data to the server, show the user feedback that the action was in progress, and then apply the server's results to the model.\n\nSo that's what this plugin does. And much more!\n\nSee more at [aaronfrancis.com](http://aaronfrancis.com).\n\n## Installation\n \n```javascript\nVue.use(require('vue-model'));\n```\n\n> **Note:** This is my first node.js package, so the module setup may not be quite perfect. Please feel free to submit pull-requests. \n\n## Quick Examples\n\nHere are a few quick examples to show you what you can do with vue-model.\n\n### Edit a Model\n\n```html\n<div v-if='!customer.$.editing'>\n    @{{ customer.name }}\n    <br>\n    <a href='#' @click.prevent='customer.$.edit()'>Edit</a>\n</div>\n\n<div v-if=\"customer.$.editing\">\n    <input type='text' v-model='customer.name' :disabled='customer.$.inProgress'>\n    <br>\n    <a href='#' @click.prevent='customer.$.update()'>Save</a> or\n    <a href='#' @click.prevent='customer.$.cancel()'>Cancel</a>\n</div>\n```\n\n### Update a Model \n\n```html\n<input type='text' v-model='customer.name' :disabled='customer.$.inProgress'>\n<button @click.prevent='customer.$.update()' :disabled='customer.$.updateInProgress'>\n    <template v-if='customer.$.updateInProgress'>\n        <i class='fa fa-spinner fa-spin'></i>\n        Updating...\n    </template>\n    <template v-if='!customer.$.updateInProgress'>\n        Update Customer\n    </template>\n</button>\n```\n\n### Delete a Model\n\n```html\n<div v-for='customer in customers'>\n    @{{ customer.name }} (<a href='#' @click.prevent='customer.$.destroy()'>Delete</a>)\n</div>\n```\n\n### Listen for Events\n\n```javascript\nnew Vue({\n    el: 'body',\n    \n    models: ['customer'],\n    \n    data: {\n        customer: {\n            id: 1\n        }\n    },\n    \n    events: {\n        'customer.fetch.success': function(data) {\n            console.log('Customer fetched!');\n            console.log(data.sent);\n            console.log(data.received);\n        }\n    }\n})\n\n```\n\n## Registering Models\n\nBefore you can create models, you need to register them with vue-model. The registration process is simple using the `Vue.models.register` method. \n\n```javascript\nVue.models.register(type, options);\n```\n\nThe first argument is the `type` argument, which gives your model a \"name\". The second argument is a plain object that lets you define some options that are specific to your model. (We'll talk later on about all the ways to customize your model.)\n\nHere's an example of registering a `customer` model that has a base route of `/customers`: \n```javascript\nVue.models.register('customer', {\n    baseRoute: '/customers',\n});\n```\n\nNow you're ready to start creating and using your models.\n\n## Creating Models\n\nThere are two different ways to create models in vue-model: You can create them manually whenever you please, or you can have vue-model create them automatically.\n\n### Manually\n\nTo manually create a model, use the `$model()` Vue Instance method. \n  \nWithin a Vue Instance: \n\n```javascript\nthis.$model(type, data, options);\n```\n\nThe `$model()` method accepts 3 parameters:\n- `type`: (string) The type of model. This is the same key you used to register the model \n- `data`: (object) The model data\n- `options`: (object) Any _instance_ specific options\n\nYou can create the model wherever you please. For example, you can call the method inside the `data` function: \n\n```javascript\nnew Vue({\n    el: 'body',\n    \n    data: function() {\n        return {\n            customer: this.$model('customer', {\n                name: 'Aaron'\n            })\n        };\n    }\n});\n```\n\nOr you can call it anywhere else! Here's an example where we instantiate a model within Vue's `created` lifecycle hook.\n```javascript\nnew Vue({\n    el: 'body',\n    \n    data: {\n        customer: {\n            name: 'Aaron'\n        }\n    },\n    \n    created: function() {\n        this.customer = this.$model('customer', this.customer);\n    }\n});\n```\n\n#### Ad-hoc Model Creation\n\nThere may be times when you are using a model in a single place and don't want to register it, say in the case of a form. To create a model on-the-fly, just skip the `type` parameter. Your model's `data` becomes the first param, and the `options` become second.\n\n```javascript\nnew Vue({\n    el: 'body',\n    \n    data: function() {\n        var formData = {\n            \n        };\n        var formOptions = {\n            baseRoute: '/forms/something'\n        };\n    \n        return {\n            form: this.$model(formData, formOptions)\n        };\n    }\n});\n```\n\n### Automatically\nManually creating models gives you ultimate flexibility, but sometimes you just want it to work right away. That's where automatic model creation comes into play.\n \nTo automatically create models, you simply need to add a `models` array to your Vue Instance. A `models` array element can take two forms. The first form is just a string: \n\n```javascript\nnew Vue({\n    el: 'body',\n    \n    models: ['customer'],\n    \n    data: {\n        customer: {\n            name: 'Aaron'\n        }\n    }\n});\n```\n\nWhen you pass a string in, the model type the data key must be the same. In the example above, the model type must be `customer`, and the data key must also be `customer`. \n \nIf you need more flexibility in naming, you can pass in a proper object.\n\n```javascript\nnew Vue({\n el: 'body',\n \n models: [{\n    type: 'customer'\n    dataKey: 'newCustomer'\n }],\n \n data: {\n     newCustomer: {\n         name: 'Aaron'\n     }\n }\n});\n```\n \nIn this example, the model type is still `customer`, but the actual data lives on the data key `newCustomer`. \n \n> Under the hood, vue-model adds a mixin that latches on to the `created` lifecycle event to create models automatically. [Read more about the Vue Instance lifecycle](https://vuejs.org/guide/instance.html#Lifecycle-Diagram)\n \nIn the case where you need to pass options in, you can do that as well:\n\n```javascript\nnew Vue({\n  el: 'body',\n  \n  models: [{\n     type: 'customer'\n     dataKey: 'newCustomer',\n     options: {\n        eventPrefix: 'new-customer'\n     }\n  }],\n  \n  data: {\n      newCustomer: {\n          name: 'Aaron'\n      }\n  }\n});\n```\n\n### Creating Many Models At Once\nIn the case where you want to create many models at once, you can use the `this.$models` method. The second parameter should be an array of data and vue-model will loop through and create a model for each element.\n\n```javascript\nnew Vue({\n    el: 'body',\n    \n    data: function() {\n        var customers = [{\n            // customer 1 data\n        },{\n            // customer 2 data\n        },{\n            // customer 3 data\n        }];\n    \n        return {\n            customers: this.$models('customer', customers)\n        };\n    }\n});\n```\n\n> You can definitely do this yourself using a `for` loop and the `this.$model` method, `this.$models` is just a little more convenient.\n\n\n## The API Object\nEverything that vue-model provides lives on a single key on your data. By default, this key is `$`, although you can change it. Taking one of the model creation examples from above:\n\n```javascript\nnew Vue({\n    el: 'body',\n    \n    models: ['customer'],\n    \n    data: {\n        customer: {\n            name: 'Aaron'\n        }\n    }\n});\n```\n\nYour `customer` object now contains two properties: \n- `name`: the original property that was passed in (value of `Aaron`)\n- `$`: the vue-model API\n\nYou may be (correctly) wondering why we're adding this new `$` key instead of using prototypical inheritance like you might do traditionally. The reason we have to do that is because [Vue.js requires that observed data be __plain__ objects](http://vuejs.org/guide/reactivity.html), which means we can't use object-like functions and their prototypes.\n\n## Performing HTTP Actions\n\nPerforming HTTP Actions is the heart of vue-model. The whole purpose of this plugin is to make it painless for your models to interact with your application's backend. \n \nAll the actions are available on the vue-model key (`$` by default). To perform an action, you just need to call the corresponding method.\n\nExamples:\n\n```javascript\n// Create a new customer\ncustomer.$.create();\n\n// Fetch this customer from the server\ncustomer.$.fetch();\n\n// Save this customer\ncustomer.$.update();\n\n// Delete this customer\ncustomer.$.destroy();\n\n// Retrieve a list of customers\ncustomer.$.list()\n```\n\nThese are the 5 actions that vue-model ships with, but you are welcome to disable those and/or set up your own.\n\n### Action Definition\n\nActions are defined using the `action` key when you customize your model (which can be done in several places and will be covered in the __Customizing Your Models__ section).   \n\nFor simplicity, let's assume you are registering a `video` model and want to add two new actions: `complete` and `uncomplete`. That would be done as follows: \n \n```javascript\nVue.models.register('video', {\n    baseRoute: '/videos',\n    actions: {\n        complete: {\n            method: 'POST',\n            route: '/{id}/complete'\n        },\n        uncomplete: {\n            method: 'DELETE',\n            route: '/{id}/complete'\n        }\n    }\n});\n```\n\n#### Route Interpolation\n\nAll of your action's routes will be interpolated with your model's data. So if your model has an `id` of `10`, a route of \n\n```\n/videos/{id}\n```\n\nbecomes\n\n```\n/videos/10\n```\n\nYou can do this with any attribute from your model. If your model's `type` has a value of `watched`, a route defined as \n\n```\n/videos/{type}/increment\n```\n\nwould become\n\n```\n/videos/watched/increment\n```\n\n#### Disabling Default Actions\n\nIf you'd like to disable some of the default actions, you can do so by setting that action to `false`.\n\nExample:\n\n```javascript\n{\n    actions: {\n        list: false,\n        destroy: false\n    }\n}\n```\n\nThe resulting model will only have the `create`, `fetch`, and `update` methods. \n\n\n### Refining Data\n\nIt's probable that you'll want to send different data to the server based on what action it is that's being executed. When you send a off a `create` request, you'll send all the data. But when you send a `destroy` request, you really shouldn't be sending any data at all. Vue-model accomplishes this through the its DataPipeline.\n \nThe DataPipeline comes with several useful methods by default:  \n \n- `none()` - Don't send _any_ data at all\n- `only(keys)` - _Only_ send certain `keys`\n- `with(data)` - Add additional `data`\n- `without(keys)` - All the data, but without certain `keys` \n- `callback(fn)` - Return whatever data you like from a callback `fn` function\n \nThere are a couple of different ways to use the DataPipeline. The first is by defining it in your action definition:\n \n  \n```javascript\nVue.models.register('video', {\n    baseRoute: '/videos',\n    actions: {\n        complete: {\n            method: 'POST',\n            route: '/{id}/complete',\n            pipeline: function(DataPipeline) {\n                // Don't post *any* data\n                DataPipeline.none();\n            }\n        }\n    }\n});\n```\n\nNow, every time you call `video.$.complete()`, the data will run through the action's pipeline which will strip all the data out. \n\nThe other option would be to define the pipleline inline by using the `$.data` object.\n\n```javascript\nvideo.$.data\n    // Drop all model data\n    .none()\n    // Add some arbitrary data\n    .with({\n        forUser: 100 \n    });\n    \nvideo.$.list();\n```\n\nAll DataPipeline methods return the DataPipeline, so you can chain them.\n\nAnd if you want to do it _really_ in line, your `apiKey` also lives on the `data` object so you can access your actions again.\n\n```javascript\nvideo.$.data.none().$.complete();\n```\n\nIf you find yourself doing this too often, you should probably make that the default for the action. \n\n\n### Applying Response Data (or Not) \n\nAnother great thing about vue-model is that you can automatically update your models with the response that comes back from the server.\n\nIf you define your action with `apply = true`, vue-model will take the response from the server, loop through all the data, and call `Vue.set` on the keys that have changed.\n\n```javascript\nVue.models.register('video', {\n    baseRoute: '/videos',\n    actions: {\n        complete: {\n            method: 'POST',\n            route: '/{id}/complete',\n            // Apply the returned data\n            apply: true\n        }\n    }\n});\n```\n\nIf the server returns \n\n```json\n{\n    completed: 1\n}\n```\n\nas its payload from the `complete` action, then the `completed` attribute on our model will automatically be updated. \n\n```javascript\nvideo.$.complete();\n// Once it finishes...\nconsole.log(video.completed);\n// > 1\n```\n\nThat lets us create toggle buttons very easily, all in HTML.\n\n```html\n<button v-if=\"video.completed\" @click.prevent=\"video.$.uncomplete()\">\n    Completed\n</button>\n\n<button v-if=\"!video.completed\" @click.prevent=\"video.$.complete()\">\n    Mark as Complete\n</button>\n```\n\n\n### Preventing Simultaneous Actions\n\nBy default, vue-model will prevent another action from being initiated while another action is running. If you want to turn this behavior off, you can pass `false` in for the `preventSimultaneousActions` option.\n\n## Busy Indicators\n\nYou'll often want to know when the model is busy, so that you can show loading indicators or prevent other actions. Vue-model provides two types of busy indicators: Global, and Action Specific.\n\n### Global\nThe global busy indicator lives in the API object under the `inProgress` key.\n\nFor example, if you have a model named `customer`, you can observe the `customer.$.inProgress` attribute. This is helpful for showing/hiding elements or disabling buttons.\n\nHere's one way you can disable a button, should the model be busy performing an HTTP action:\n\n```html\n<button @click='video.$.complete()' :disabled='video.$.inProgress'>\n    Mark as Complete\n</button>\n```\n\n### Action-Specific\n\nIf you have loading indicators scattered across the page and only want to show the correct indicator based on the specific action, then you should use an action-specific busy indicator.\n\nFor every action, there is a corresponding property that indicates whether or not that action is currently in process. For example, if the action is named `update`, then the property would be named `updateInProgress`. \n\nConsider a case where you have a `complete` action for a `video` model and would like to show a loading indicator on the button.\n\n```html\n<button @click='video.$.complete()' :disabled='video.$.completeInProgress'>\n    <i v-if='video.$.completeInProgress' class='fa fa-spinner fa-spin'></i>\n    Mark as Complete\n</button>\n```\n\nThis button will disable itself and show the lovely Font Awesome loading indicator (<i class='fa fa-spinner fa-spin'></i>) while the model finishes the `complete` action. This provides feedback and a good experience for your users. However, in this example if a different action is being performed, say a `favorite` action, the button will not show the loading indicator because it is bound to `completeInProgress` and not `inProgress` or `favoriteInProgress`.\n\n> When _any_ of the action-specific loading indicators (`{action}InProgress`) are `true`, the global `inProgress` indicator will also be `true`.\n\n## Events\n\nVue-model emits several events that you can listen for and respond to, giving you many different ways to seamlessly tie your app into vue-model.  \n\n### Naming\n\nVue-model events follow a naming scheme of `{eventPrefix}.{action}.{result}`. The `eventPrefix` can be set when you are registering or instantiating your models. (See __Customizing Your Models__ for more information on how to set this.)\n\nBy default, if you don't pass in an `eventPrefix` while registering your model, vue-model will set it to the `type` of model you register.\n\n```javascript\n\n// No eventPrefix, model type is 'customer'\nVue.models.register('customer', {\n    baseRoute: '/customers'\n});\n// --> eventPrefix is equal to 'customer'\n\n\n// Explicit eventPrefix passed in\nVue.models.register('customer', {\n    baseRoute: '/customers',\n    eventPrefix: 'cst'\n});\n// --> eventPrefix is equal to 'cst'\n```\n\n`{action}` is always equal to the name of the action on your API. If you call `customer.$.update()`, `action` will be equal to `update`. \n\n`{result}` is one of the following:\n\n- `before` - Before the action takes place\n- `success` - Successful completion of the action\n- `error` - Action failed\n- `complete` - Action *finished*, regardless of outcome\n- `canceled` - Action canceled by because a `before` callback returned `false`\n- `prevented` - Action prevented because another action was still in progress\n\nPutting it all together, the event name will look similar to the following examples:\n\n- `customer.update.before`\n- `customer.destroy.success`\n- `customer.fetch.error`\n- `customer.list.complete`\n- `customer.create.canceled`\n- `customer.update.prevented`\n\n### Data\n\nEach event comes with `data` payload:\n\n- `{eventPrefix}.{action}.before` - Before the action takes place\n    \n    ```javascript\n    {\n        // The object that is about to \n        // be sent to the server\n        sending: {}\n    }\n    ```\n    \n- `{eventPrefix}.{action}.success` - Successful completion of the action\n\n    ```javascript\n    {\n        // The object that was sent to the server\n        sent: {},\n        \n        // Data that was received from the server\n        received: {}\n    }\n    ```\n\n- `{eventPrefix}.{action}.error` - Action failed\n\n    ```javascript\n    {\n        // The object that was sent to the server\n        sent: {},\n        \n        // The failed XHR object\n        received: {}\n    }\n    ```\n\n\n- `{eventPrefix}.{action}.complete` - Action *finished*, regardless of outcome\n\n    ```javascript\n    {\n        // The object that was sent to the server\n        sent: {},\n        \n        // Data that was received from the server\n        // OR an failed XHR, depending on success\n        // or failure of the request\n        received: {}\n    }\n    ```\n\n- `{eventPrefix}.{action}.canceled` - Action canceled by because a `before` callback returned `false`\n\n    No data.\n\n- `{eventPrefix}.{action}.prevented` - Action prevented because another action was still in progress\n\n    ```javascript\n    {\n        // The action that was prevented\n        action: {}\n    }\n    ```\n    \n\n> Vue-model also emits an `{eventPrefix}.prevented` event every time __any__ action is prevented. For this event, the `name` of the event is also attached. \n```javascript\n{\n        // The name of the event (create, update, destroy, etc)\n        name: '',\n        // The action that was prevented\n        action: {}\n}\n```\n\n### The Event Emitter\n\nVue-model needs to know _how_ to emit events before it can actually do so. By default, vue-model uses the `$emit` method on the instance that you used to create your models. This lets you put your listeners right in your Vue instance\n\n```javascript\nnew Vue({\n    el: 'body',\n    models: ['customer'],\n\n    data: {\n        customer: {\n            id: 1\n        }\n    },\n    \n    events: {\n        'customer.fetch.success': function(data) {\n            console.log('Got some new data from the server!');\n            console.log(data.received);\n        }\n    }\n});\n```\n\nIf you don't want to use the `$emit` method, you can pass use Vue's `$broadcast` or `$dispatch` methods by passing in `broadcast` or `dispatch`, respectively. (Leave off the leading `$`.)\n\nYou could also pass in your own callback if you don't want to use any of Vue's methods.\n\n```javascript\n// Emitter for your customer model\nVue.models.register('customer', {\n    emitter: function(action, data) {\n        // Pass the event on to...\n        // Pusher\n        // PubNub\n        // Websocket\n        // etc etc\n     }\n});\n\n// Emitter for *every* model\nVue.use(require('vue-model'), {\n    emitter: function(action, data) {\n        // Pass the event on to...\n        // Pusher\n        // PubNub\n        // Websocket\n        // etc etc\n     }\n});\n```\n\nSee more in the __Customizing Your Models__ section.\n\n## Errors\n### Is it a Validation Error Response?\n### Transform Errors\n\n## Customizing Your Models\n\nVue-model has been created to be as configurable as possible, but still remain very easy to use. We've also included several places where you can introduce model customization, so that you can worry about it as infrequently as possible.   \n\n### Precedence\n\nSince there are so many ways to customize your models, let's talk about order of importance.\n\n#### 4. Least Important: Vue-model Defaults.\n \nVue-model ships with a `ModelDefaults.js` file that defines all the possible defaults. This is the _least_ important, but provides a solid base to get you started. (See below for a copy of the `ModelDefaults.js`)\n  \n#### 3. Somewhat Important: User Defaults\n\nIf you have specific defaults that you'd like to apply to __every__ model you ever create, you can pass in your own defaults that override the vue-model defaults. You do that when you call `Vue.use`.\n \nFor example, if you want all your models to use the underscore `_` as the api key instead of the default `$`, you could easily do that one time and then forget about it:\n\n```javascript\nVue.use(require('vue-model'), {\n    apiKey: '_'\n});\n```\n\nYour new `apiKey` will override the vue-model default `apiKey` so that every model you create will have the api under `_`, making your actions look more like this:\n\n```javascript\nvideo._.complete();\n```\n\n#### 2. Moderately Important: Model Defaults\n\nWhen you register a model using `Vue.models.register`, you have the ability to pass in `options` as a third parameter. If, for example, you don't want a certain model to have the `destroy` action, you can disable it for a single model:\n \n```javascript\nVue.models.register('customer', {\n    actions: {\n        destroy: false\n    }\n});\n```\n\nWith this configuration, every time you call `this.$model('customer', {})`, there will be no `destroy` action, because you declared it `false` upon registration.\n\n#### 1. Most Important: Instance Options\n\nThe highest priority for options are _instance_ specific options. Instance specific options can override every other option. Instance specific options are (optionally) declared when you create a model. For example, if you'd like to change the event emitter for a _single instance_, you can:\n\n```javascript\nthis.$model('customer', data, {\n    // This model will not emit events (noop)\n    emitter: function() {}\n});\n```\n\nIf you are automatically creating models and want to pass in different options than the options you registered with, just make `models` a proper object and include an `options` object.\n\n```javascript\nnew Vue({\n    el: 'body',\n    \n    models: [{\n        type: 'customer'\n        dataKey: 'newCustomer',\n        options: {\n            emitter: function() {}\n        }\n    }],\n    \n    data: {\n        newCustomer: {\n            name: 'Aaron'\n        }\n    }\n});\n```\n\n\n### Available Options\n\nThis is the `ModelDefaults.js` file that vue-model ships with and contains all the available options.\n\n```javascript\n{\n    // The key that contains vue-model API\n    apiKey: '$',\n\n    // Any keys we don't want to send up to the server\n    // or apply from the server. Often, this can be\n    // used for related models, etc.\n    excludeKeys: [],\n\n    // Prepended to each of the action routes\n    baseRoute: '',\n\n    // Prepended to each event that gets emitted. If \n    // you leave this blank when your register your \n    // models, vue-model will set eventPrefix equal\n    // to the `type` that you registered. Event \n    // naming schema: {eventPrefix}.{action}.{status}\n    // Eg: \"customer.fetch.success\"\n    eventPrefix: '',\n\n    // The function that emits events. You can pass \n    // a string name of one of the Vue.js instance \n    // event methods here and vue-model will convert\n    // it to a proper function using the Vue instance \n    // from which you instantiated the model.\n    // Allowed: 'emit', 'broadcast', 'dispatch', or \n    // a callback function.\n    emitter: 'emit',\n\n    // Prevent an action from being invoked while\n    // another action is still running\n    preventSimultaneousActions: true,\n\n    // Default HTTP Actions that every model gets\n    actions: {\n        list: {\n            method: 'GET',\n            route: '',\n            pipeline: function(DataPipeline) {\n                DataPipeline.none();\n            }\n        },\n        create: {\n            method: 'POST',\n            route: '',\n        },\n        fetch: {\n            method: 'GET',\n            route: '/{id}',\n            apply: true,\n            pipeline: function(DataPipeline) {\n                DataPipeline.none();\n            }\n        },\n        update: {\n            method: 'PUT',\n            route: '/{id}',\n            apply: true\n        },\n        destroy: {\n            method: 'DELETE',\n            route: '/{id}',\n            pipeline: function(DataPipeline) {\n                DataPipeline.none();\n            }\n        }\n    },\n\n    // Base defaults for every action\n    actionDefaults: {\n        // Apply data that's returned \n        // from the server \n        apply: false,\n        \n        // Load validation errors into the \n        // model if the server returns them\n        validation: true,\n        \n        // Perform before the action. Return\n        // false to cancel the action\n        before: function() {\n            //\n        },\n        \n        // Perform after the action completes\n        after: function(data) {\n            //\n        }\n    },\n\n    // Model validation errors coming from the server\n    validationErrors: {\n        // Function to determine whether or not an\n        // error response is a validation error.\n        // 422 is the correct status code, so if\n        // you use Laravel, no need to update this.\n        isValidationError: function(xhr) {\n            return xhr.status === 422;\n        },\n\n        // The error object should have the field names\n        // as the keys and an array of errors as the\n        // values. Laravel does this automatically.\n        transformResponse: function(xhr) {\n            return xhr.responseJSON;\n        }\n    }\n}\n```\n\n## API\n\nThis is the API that vue-model appends to your object. By default, this is attached to your data under a `$` key, although you can specify the key by declaring an `apiKey` for your model.\n    \n- __`list()`__\n\n    The `list` HTTP action\n\n- __`create()`__\n\n    The `create` HTTP action\n\n- __`fetch()`__ \n\n    The `fetch` HTTP action\n\n- __`update()`__ \n\n    The `update` HTTP action\n\n- __`destroy()`__\n\n    The `destroy` HTTP action\n    \n- __`copy()`__\n\n    Returns a plain object copy of the model's `data`, without any vue-model extras. \n\n- __`edit()`__\n\n    Copies the current `data` into a cache and sets the `editing` flag to `true`\n\n- __`cancel()`__\n\n    Applies the old `data` that was copied into the cache by the `edit` function, and sets the `editing` flag back to `false`\n\n- __`apply(newData)`__\n\n    Load an object into the model's `data`. (This is the same function that vue-model uses to apply the data from the server's response.)\n\n- __`inProgress`__\n\n    `boolean` Global loading indicator\n    \n- __`listInProgress`__ \n\n    `boolean` Loading indicator for the `list` action\n\n- __`createInProgress`__ \n\n    `boolean` Loading indicator for the `create` action\n\n- __`fetchInProgress`__ \n\n    `boolean` Loading indicator for the `fetch` action\n\n- __`updateInProgress`__ \n\n    `boolean` Loading indicator for the `update` action\n\n- __`destroyInProgress`__ \n\n    `boolean` Loading indicator for the `destroy` action\n\n- __`editing`__ \n    \n    `boolean` Indicator as to whether or not the model is in editing mode.\n\n- __`errors`__\n    - __`hasAny()`__\n        \n        `boolean` Whether or not there are _any_ errors\n        \n    - __`has(field)`__\n        \n        `boolean` Whether or not there are errors for `field` \n        \n    - __`first(field)`__\n        \n        `string|undefined` The first error for `field`\n        \n    - __`get(field)`__\n        \n        `array|undefined` All the errors for `field`\n        \n    - __`clear(field)`__\n        \n        Clear the errors for a `field`\n        \n    - __`push(field, value)`__\n        \n        Add a new error `value` for `field`\n        \n    - __`set(collection)`__\n        \n        Completely overwrite all the errors with a new object. Keys should be field names and values should be arrays full of strings.\n        \n    - __`all`__\n            \n        A raw object of all the errors so Vue.js can observe and react to changes in errors.\n        \n- __`data`__\n   \n    - __`none()`__\n        \n        Drop all data\n        \n    - __`only(keys)`__\n        \n        Of all the attributes in your data, only keep ones that are in the `keys` array\n        \n    - __`with(data)`__\n        \n        Add any additional data that you please\n        \n    - __`without(keys)`__\n        \n        Drop `keys` out of your object\n        \n    - __`callback(fn)`__\n        \n        Pass in any callback function `fn` to process the `data`. The first argument to your `fn` will be the `data` as it currently exists. You can also pass args in to `callback` and they will be passed on to your `fn`. Example:\n        \n        ```javascript\n        var processData = function(data, foo, bar) {\n            // In this example:\n            // foo === 'foo-arg'\n            // bar === 'bar-arg'\n            \n            // Do something with the data...\n            return data;\n        };\n        \n        video.$.data.callback(processData, 'foo-arg', 'bar-arg');\n        ```\n        \n    - __`forAction(name)`__\n        \n        Returns the `data` that would be sent for an action. Useful for debugging.\n        \n        ```javascript\n        // Get the data that would be posted for the 'update' action\n        var dataToBePosted = video.$.data.with({test: 1}).forAction('update');\n        \n        // Inspect the data\n        console.log(dataToBePosted);\n        ```\n        \n    - __`$`__ (or whatever your `apiKey` is)\n        \n        A reference back to your API object\n        \n        ```javascript\n        video.$.data.none().$.complete();\n        ```\n        \n        Allows you to get back up a level from your data pipeline operations.","starsCount":1,"created":"2016-06-07T22:38:23.476Z","modified":"2017-04-25T18:35:52.960Z","lastPublisher":{"name":"aarondfrancis","email":"aarondfrancis@gmail.com"},"owners":[{"name":"aarondfrancis","email":"aarondfrancis@gmail.com"}],"other":{"_attachments":{},"_from":".","_id":"vue-model","_nodeVersion":"5.7.0","_npmOperationalInternal":{"host":"packages-16-east.internal.npmjs.com","tmp":"tmp/vue-model-0.0.3.tgz_1465341164015_0.3251284316647798"},"_npmUser":{"name":"aarondfrancis","email":"aarondfrancis@gmail.com"},"_npmVersion":"3.6.0","_rev":"2-d2e7b328305f4164901b68a3d965ebe1","_shasum":"6b0d368875c42a6a9127f2e1ff51077e8654c0b5","author":{"name":"Aaron Francis","email":"aarondfrancis@gmail.com","url":"http://aaronfrancis.com"},"bugs":{"url":"https://github.com/aarondfrancis/vue-model/issues"},"directories":{},"dist-tags":{"latest":"0.0.3"},"dist":{"shasum":"6b0d368875c42a6a9127f2e1ff51077e8654c0b5","tarball":"http://registry.npmjs.org/vue-model/-/vue-model-0.0.3.tgz"},"maintainers":[{"name":"aarondfrancis","email":"aarondfrancis@gmail.com"}],"readmeFilename":"README.md","time":{"modified":"2017-04-25T18:35:52.960Z","created":"2016-06-07T22:38:23.476Z","0.0.1":"2016-06-07T22:38:23.476Z","0.0.2":"2016-06-07T23:11:42.572Z","0.0.3":"2016-06-07T23:12:46.163Z"},"users":{"rshaw":true}}}