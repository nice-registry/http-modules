{"name":"swagger-http-router","version":"0.0.2","description":"A HTTP router based on your Swagger definition.","main":"src/index.js","metapak":{"data":{"files":"src/*.js","testsFiles":"src/*.mocha.js tests/*.mocha.js"},"configs":["jsdocs","jsarch","readme"]},"scripts":{"architecture":"jsarch src/*.js > ARCHITECTURE.md","changelog":"conventional-changelog -p angular -i CHANGELOG.md -s","cli":"env NODE_ENV=${NODE_ENV:-cli}","cover":"istanbul cover _mocha --report html -- src/*.mocha.js tests/*.mocha.js -R spec -t 5000","coveralls":"istanbul cover _mocha --report lcovonly -- src/*.mocha.js tests/*.mocha.js -R spec -t 5000 && cat ./coverage/lcov.info | coveralls && rm -rf ./coverage","cz":"env NODE_ENV=${NODE_ENV:-cli} git cz","doc":"mkdir -p .readme; echo \"# API\" > .readme/API.md; jsdoc2md src/*.js >> .readme/API.md","lint":"eslint src/*.js","metapak":"metapak || echo 'Please `npm install --save-dev metapak`' && exit 0","postinstall":"npm run metapak --silent","preversion":"npm t && npm run lint","test":"mocha src/*.mocha.js tests/*.mocha.js","version":"npm run changelog && git add CHANGELOG.md"},"repository":"https://github.com/nfroidure/swagger-http-router","license":"MIT","homepage":"https://github.com/nfroidure/swagger-http-router#readme","dependencies":{"ajv":"^5.1.5","body":"^5.1.0","bytes":"^2.5.0","common-services":"0.0.0","content-type":"^1.0.2","debug":"2.6.1","first-chunk-stream":"^2.0.0","knifecycle":"^2.1.1","negotiator":"^0.6.1","siso":"^2.1.1","statuses":"^1.3.1","strict-qs":"^2.0.0","swagger-parser":"^3.4.1","yerror":"^2.0.0","yhttperror":"^1.0.0"},"devDependencies":{"commitizen":"^2.9.6","conventional-changelog-cli":"^1.2.0","coveralls":"2.11.15","cz-conventional-changelog":"^2.0.0","eslint":"3.16.0","eslint-config-simplifield":"4.1.1","istanbul":"0.4.5","jsarch":"1.2.1","jsdoc-to-markdown":"^3.0.0","metapak":"0.0.20","metapak-nfroidure":"0.5.2","mocha":"3.2.0","mocha-lcov-reporter":"1.3.0","sinon":"^2.1.0","streamtest":"^1.2.2","supertest":"^3.0.0"},"engines":{"node":">=6.9.5"},"config":{"commitizen":{"path":"./node_modules/cz-conventional-changelog"}},"greenkeeper":{"ignore":["debug","eslint","eslint-config-simplifield","mocha","mocha-lcov-reporter","commitizen","cz-conventional-changelog","coveralls","istanbul","conventional-changelog-cli","jsarch","jsdoc-to-markdown"]},"gitHead":"94871e17126cf41f3585305516a57e84b242b2a1","versions":[{"number":"0.0.0","date":"2017-06-14T08:53:23.674Z"},{"number":"0.0.1","date":"2017-06-15T14:18:22.371Z"},{"number":"0.0.2","date":"2017-06-16T14:54:27.088Z"}],"readme":"<!--\n# This file is automatically generated by a `metapak`\n# module. Do not change it elsewhere, changes would\n# be overriden.\n-->\n# swagger-http-router\n> A HTTP router based on your Swagger definition.\n\n[![NPM version](https://badge.fury.io/js/swagger-http-router.svg)](https://npmjs.org/package/swagger-http-router)\n[![Build status](https://secure.travis-ci.org/nfroidure/swagger-http-router.svg)](https://travis-ci.org/nfroidure/swagger-http-router)\n[![Dependency Status](https://david-dm.org/nfroidure/swagger-http-router.svg)](https://david-dm.org/nfroidure/swagger-http-router)\n[![devDependency Status](https://david-dm.org/nfroidure/swagger-http-router/dev-status.svg)](https://david-dm.org/nfroidure/swagger-http-router#info=devDependencies)\n[![Coverage Status](https://coveralls.io/repos/nfroidure/swagger-http-router/badge.svg?branch=master)](https://coveralls.io/r/nfroidure/swagger-http-router?branch=master)\n[![Code Climate](https://codeclimate.com/github/nfroidure/swagger-http-router.svg)](https://codeclimate.com/github/nfroidure/swagger-http-router)\n[![Dependency Status](https://dependencyci.com/github/nfroidure/swagger-http-router/badge)](https://dependencyci.com/github/nfroidure/swagger-http-router)\n\nWhy write code when you have a Swagger/OpenAPI definition?\n\nBy taking part of the Swagger/OpenAPI standard and\n dependency injection  patterns, `swagger-http-router`\n provides a convenient, highly modular and easily\n testable REST tool.\n\n## Usage\n```js\nimport initDB from './services/db';\nimport {\n  initWepApplication\n} from 'swagger-http-router';\n\nimport API from './swagger.api.json';\nimport * as HANDLERS from './handlers';\n\n// STEP 1: Spawn a Knifecycle instance and attach\n// it the API definition and its handlers\nconst $ = initWepApplication(API, HANDLERS);\n\n// STEP 2: Register additional services\n// Override the build in `uniqueId` service\n// with the UUID v4 function\n$.constant('uniqueId', uuid.v4)\n// Provide the process environment\n.constant('ENV', process.env)\n// Register the database initializer\n.register(initDB);\n\n// STEP 3: Run your app!\n// Run the execution silo that encapsulates the app\n// Note that the `httpServer` and `process` services\n// are injected for their respective side effects:\n// creating the server and managing the process\n// lifecycle\n$.run(['ENV', 'log', 'httpServer', 'process', '$destroy'])\n.then(({ ENV, log, $destroy }) => {\n  log('info', `On air ðŸš€ðŸŒ•`);\n  if(ENV.DRY_RUN) {\n    return $destroy();\n  }\n})\n.catch((err) => {\n  console.error('ðŸ’€ - Cannot launch the process:', err.stack);\n  process.exit(1);\n});\n```\n\nIn order to work, your Swagger definition endpoints\nmust provide an\n [`operationId`](http://swagger.io/specification/#operationObject).\n This is how the router figures out which handler\n to run. Those ids have to be unique. Here is\n a sample Swagger definition you could use as is:\n```js\n// file: ./my-swagger.json\n{\n  \"host\": \"localhost:1337\",\n  \"basePath\": \"/v1\",\n  \"schemes\": [\"http\"],\n  // (...)\n  \"paths\": {\n    \"GET\": {\n      \"/users/{userId}\": {\n        \"operationId\": \"getUser\",\n        \"summary\": \"Retrieve a user.\",\n        \"produces\": [\n          \"application/json\"\n        ],\n        \"parameters\": [{\n          \"in\": \"path\",\n          \"name\": \"userId\",\n          \"type\": \"number\",\n          \"pattern\": \"^[0-9]+$\"\n        }, {\n          \"in\": \"query\",\n          \"name\": \"extended\",\n          \"type\": \"boolean\"\n        }, {\n          \"in\": \"header\",\n          \"name\": \"Content-Type\",\n          \"type\": \"string\"\n        }],\n        \"responses\": {\n          \"200\": {\n            \"description\": \"User found\",\n            \"schema\": {\n              \"type\": \"object\",\n              \"properties\": {\n                \"id\": { \"type\": \"number\" },\n                \"name\": { \"type\": \"string\" }\n              }\n            }\n          },\n          \"404\": {\n            \"description\": \"User not found\"\n          }\n        }\n      }\n    }\n  }\n}\n```\n\nTo bring to the router the logic that each\n endpoint implements, you have to create\n handlers for each `operationId`:\n```js\n// file: ./handlers.js\n\n// Knifecycle is the dependency injection tool\n// we use. It provides decorators to declare\n// which dependencies to inject in your handlers\nimport { initializer } from 'knifecycle/dist/util';\n\n@initializer({\n  name: 'getUser',\n  type: 'service',\n  inject: ['db'],\n})\nexport async function getUser({ db }) {\n  return ({ userId }) =>\n    db.query('users', {\n      id: userId,\n    })\n    .then(user => ({\n      status: 200,\n      headers: {},\n      body: {\n        id: userId,\n        name: user.name,\n      }\n    }));\n}\n\n```\n\nAs you can see, handlers are just asynchronous functions\nthat takes the request parameters in input and provide\na JSON serializable response in output.\n\nThis router is designed to be used with a DI system and\n is particularly useful with\n [`knifecycle`](https://github.com/nfroidure/knifecycle).\n\nThat said, you could completely avoid using a DI system\n by simply using the initializers as functions and handle\n their initialization manually. See this\n  [alternate example](https://gist.github.com/nfroidure/647189bdeffef33bced3a3b6d924640e).\n\n## Goal\n\nThis router is just my way to do things. It is nice\n if you use it and I'd be happy if you improve it.\n\nTo be honest, I think this is a better approach but I do\n not want to spend energy and fight with giants to make\n this a standard approach. It means that it will probably\n never be the next hype and if you use it you must feel\n confident with forking and maintaining it yourself.\n That said, the code is well documented and not that hard.\n Also, the handlers you will end with will be easily\n reusable in any framework with little to no changes.\n\nYou may wonder why I found that I'd better write\n my own router instead of using current solutions\n like `ExpressJS` or `HapiJS`:\n- I want documentation first APIs. No documentation, no\n web service.\n- I want my code to be clear and descriptive instead of\n binded to some cryptic middleware or plugin defined\n elsewhere. Here are some\n [thoughts on middlewares](http://insertafter.com/en/blog/no_more_middlewares.html)\n that explain this statement in more depth.\n - I want easily testable and reusable handlers just\n  returning plain JSON. To be able to reuse it in\n  multiple situations: a lambda/serverless back-end,\n  when rendering server side React views or in my\n  GraphQL server resolvers.\n- I prefer functional programming: it just makes my code\n better. There are too many encapsulated states in existing\n frameworks. I just want my handlers to be pure and\n composable. For example, why adding a CORS middleware or\n plugin when you can just compose handlers?\n```js\nimport { reuseSpecialProps } from 'knifecycle/dist/util';\n\nconst CORS = {\n  'Access-Control-Allow-Origin': '*',\n  'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',\n  'Access-Control-Allow-Headers': 'Keep-Alive,User-Agent',\n};\n\nexport function wrapWithCORS(initHandler) {\n  // `reuseSpecialProps` create a new initializer\n  // with the original initializer properties\n  // applyed on it.\n  return reuseSpecialProps(\n    initHandler,\n    initHandlerWithCORS.bind(null, initHandler)\n  );\n}\n\n// This function is the actual initializer that\n// wraps the handler initializer. It is executed\n// once at startup.\nasync function initHandlerWithCORS(initHandler, services) => {\n  const handler = await initHandler(services);\n\n  return handleWithCors.bind(null, handler);\n}\n\n// And finally this one applies CORS to the\n// response\nasync function handleWithCors(handler, parameters) {\n  const response = await handler(parameters);\n\n  return  {\n    ...response,\n    headers: {\n      ...response.headers,\n      ...CORS,\n    }\n  };\n}\n\n```\n- and finally, I want to be able to instrument my code\n without having to do ugly hacks. This is why DI and\n Inversion of Control are at the core of my way to\n handle web services.\n\nYou may want to have a look at the\n [architecture notes](./ARCHITECTURE.md) of this module\n to better grasp how it is built.\n\n## Recommendations\n\nThe above usage section shows you a very basic\n usage of this router. For larger apps:\n- you may want to build you Swagger file to avoid\n repeating yourself. It won't change anything for\n `swagger-http-router` since it just assumes a\n Swagger file.\n- you will probably end up by automating the\n handlers loading with a configuration file.\n At that point, the DI system will become very\n handy.\n- you will certainly need some more services\n to make your app work. Please double check if\n one exists before creating your own. Also,\n handlers can be reused so feel free to\n publish yours and add your Swagger path\n objects to them in order for your users to\n add them to their own Swagger build.\n\n# API\n## Functions\n\n<dl>\n<dt><a href=\"#initWepApplication\">initWepApplication(API, HANDLERS, [$])</a> â‡’ <code>Knifecycle</code></dt>\n<dd><p>Initialize a web application</p>\n</dd>\n<dt><a href=\"#registerHandlers\">registerHandlers($, HANDLERS)</a> â‡’ <code>void</code></dt>\n<dd><p>Register the handlers hash into the given Knifecycle\n instance</p>\n</dd>\n<dt><a href=\"#initHTTPRouter\">initHTTPRouter(services)</a> â‡’ <code>Promise</code></dt>\n<dd><p>Initialize an HTTP router</p>\n</dd>\n<dt><a href=\"#initHTTPServer\">initHTTPServer(services)</a> â‡’ <code>Promise</code></dt>\n<dd><p>Initialize an HTTP server</p>\n</dd>\n<dt><a href=\"#initHTTPTransaction\">initHTTPTransaction(services)</a> â‡’ <code>Promise.&lt;function()&gt;</code></dt>\n<dd><p>Instantiate the httpTransaction service</p>\n</dd>\n</dl>\n\n<a name=\"initWepApplication\"></a>\n\n## initWepApplication(API, HANDLERS, [$]) â‡’ <code>Knifecycle</code>\nInitialize a web application\n\n**Kind**: global function  \n**Returns**: <code>Knifecycle</code> - The passed in Knifecycle instance or the one created\n by default.  \n\n| Param | Type | Default | Description |\n| --- | --- | --- | --- |\n| API | <code>Object</code> |  | The Swagger definition of the we application |\n| HANDLERS | <code>Object</code> |  | The handlers for each operations defined by the  Swagger definition. |\n| [$] | <code>Knifecycle</code> | <code>getInstance(</code> | A Knifecycle instance on which to set the application  up. |\n\n<a name=\"registerHandlers\"></a>\n\n## registerHandlers($, HANDLERS) â‡’ <code>void</code>\nRegister the handlers hash into the given Knifecycle\n instance\n\n**Kind**: global function  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| $ | <code>Knifecycle</code> | The Knifecycle instance on which to set up the handlers |\n| HANDLERS | <code>Object</code> | The handlers hash |\n\n<a name=\"initHTTPRouter\"></a>\n\n## initHTTPRouter(services) â‡’ <code>Promise</code>\nInitialize an HTTP router\n\n**Kind**: global function  \n**Returns**: <code>Promise</code> - A promise of a function to handle HTTP requests.  \n\n| Param | Type | Default | Description |\n| --- | --- | --- | --- |\n| services | <code>Object</code> |  | The services the server depends on |\n| services.API | <code>Object</code> |  | The Swagger definition of the API |\n| services.HANDLERS | <code>Object</code> |  | The handlers for the operations decribe  by the Swagger API definition |\n| [services.ENV] | <code>Object</code> |  | The services the server depends on |\n| [services.DEBUG_NODE_ENVS] | <code>Array</code> |  | The environnement that activate debugging  (prints stack trace in HTTP errors responses) |\n| [services.BUFFER_LIMIT] | <code>String</code> |  | The maximum bufferisation before parsing the  request body |\n| [services.PARSERS] | <code>Object</code> |  | The synchronous body parsers (for operations  that defines a request body schema) |\n| [services.STRINGIFYERS] | <code>Object</code> |  | The synchronous body stringifyers (for  operations that defines a response body  schema) |\n| [services.log] | <code>function</code> | <code>noop</code> | A logging function |\n| services.httpTransaction | <code>function</code> |  | A function to create a new HTTP transaction |\n\n<a name=\"initHTTPServer\"></a>\n\n## initHTTPServer(services) â‡’ <code>Promise</code>\nInitialize an HTTP server\n\n**Kind**: global function  \n**Returns**: <code>Promise</code> - A promise of an object with a NodeJS HTTP server\n in its `service` property.  \n\n| Param | Type | Default | Description |\n| --- | --- | --- | --- |\n| services | <code>Object</code> |  | The services the server depends on |\n| services.ENV | <code>Object</code> |  | The process environment variables |\n| services.httpRouter | <code>function</code> |  | The function to run with the req/res tuple |\n| [services.log] | <code>function</code> | <code>noop</code> | A logging function |\n\n<a name=\"initHTTPTransaction\"></a>\n\n## initHTTPTransaction(services) â‡’ <code>Promise.&lt;function()&gt;</code>\nInstantiate the httpTransaction service\n\n**Kind**: global function  \n**Returns**: <code>Promise.&lt;function()&gt;</code> - A promise of the httpTransaction function  \n\n| Param | Type | Default | Description |\n| --- | --- | --- | --- |\n| services | <code>Object</code> |  | The services to inject |\n| [services.TIMEOUT] | <code>Number</code> | <code>30000</code> | A number indicating how many ms the transaction  should take to complete before being cancelled. |\n| [services.TRANSACTIONS] | <code>Object</code> | <code>{}</code> | A hash of every current transactions |\n| services.time | <code>function</code> |  | A timing function |\n| services.delay | <code>Object</code> |  | A delaying service |\n| [services.log] | <code>function</code> |  | A logging function |\n| [services.uniqueId] | <code>function</code> |  | A function returning unique identifiers |\n\n**Example**  \n```js\nimport { initHTTPTransaction } from 'swagger-http-router';\n\nconst httpTransaction = await initHTTPTransaction({\n  log: console.log.bind(console),\n  time: Date.now.bind(Date),\n});\n```\n<a name=\"initHTTPTransaction..httpTransaction\"></a>\n\n### initHTTPTransaction~httpTransaction(req, res) â‡’ <code>Array</code>\nCreate a new HTTP transaction\n\n**Kind**: inner method of [<code>initHTTPTransaction</code>](#initHTTPTransaction)  \n**Returns**: <code>Array</code> - The normalized request and the HTTP\ntransaction created in an array.  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| req | <code>HTTPRequest</code> | A raw NodeJS HTTP incoming message |\n| res | <code>HTTPResponse</code> | A raw NodeJS HTTP response |\n\n\n# License\n[MIT](https://github.com/nfroidure/swagger-http-router/blob/master/LICENSE)\n","created":"2017-06-14T08:53:23.674Z","modified":"2017-06-16T14:54:27.088Z","lastPublisher":{"name":"nfroidure","email":"nicolas.froidure@insertafter.com"},"owners":[{"name":"nfroidure","email":"nicolas.froidure@insertafter.com"}],"other":{"_attachments":{},"_from":".","_id":"swagger-http-router","_nodeVersion":"6.10.3","_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/swagger-http-router-0.0.2.tgz_1497624865909_0.09617468528449535"},"_npmUser":{"name":"nfroidure","email":"nicolas.froidure@insertafter.com"},"_npmVersion":"3.10.10","_rev":"3-d4ecb146c693f4225c54602c92a1a826","_shasum":"dcf6c1e904b3f679eb998cf336aa3b87fdcf42f9","author":{"name":"Nicolas Froidure"},"bugs":{"url":"https://github.com/nfroidure/swagger-http-router/issues"},"directories":{},"dist-tags":{"latest":"0.0.2"},"dist":{"shasum":"dcf6c1e904b3f679eb998cf336aa3b87fdcf42f9","tarball":"https://registry.npmjs.org/swagger-http-router/-/swagger-http-router-0.0.2.tgz"},"maintainers":[{"name":"nfroidure","email":"nicolas.froidure@insertafter.com"}],"readmeFilename":"README.md","time":{"modified":"2017-06-16T14:54:27.088Z","created":"2017-06-14T08:53:23.674Z","0.0.0":"2017-06-14T08:53:23.674Z","0.0.1":"2017-06-15T14:18:22.371Z","0.0.2":"2017-06-16T14:54:27.088Z"}}}