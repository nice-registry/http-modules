{"name":"sepia","version":"2.0.2","description":"A VCR-like module that records HTTP interactions and plays them back for speed and reliability","keywords":["http","testing"],"homepage":"https://github.com/linkedin/sepia","repository":"https://github.com/linkedin/sepia","license":"Apache","dependencies":{"levenshtein":"1.0.2"},"devDependencies":{"request":"2.x","then-request":"2.x","lodash":"2.x","step":"0.x","jshint":"2.x","mocha":"1.x","should":"2.x","sinon":"1.x"},"scripts":{"test":"jshint --config .jshintrc index.js src test examples && mocha test && sh examples/run-all-examples.sh"},"engines":{"node":">=0.8"},"gitHead":"84017ff6ff3c297fdbef5baeb0c28ff4127d98b1","versions":[{"number":"1.0.0","date":"2013-12-09T03:14:18.932Z"},{"number":"1.0.1","date":"2014-01-02T19:08:12.109Z"},{"number":"1.0.2","date":"2014-02-19T03:13:35.912Z"},{"number":"1.0.3","date":"2014-02-26T17:53:57.452Z"},{"number":"1.0.4","date":"2014-08-28T00:17:02.529Z"},{"number":"2.0.0","date":"2015-02-26T00:46:22.950Z"},{"number":"2.0.1","date":"2015-03-09T18:23:38.362Z"},{"number":"2.0.2","date":"2016-12-06T06:47:08.988Z"}],"readme":"# sepia - the way things used to be\n\nSepia is a VCR-like module for node.js that records HTTP interactions, then\nplays them back exactly like the first time they were invoked. Sepia was\ncreated to isolate a server from its remote downstream dependencies, for speed\nand fault-tolerence.\n\nSepia should work with any HTTP library in node.js that uses `http#request` and\n`https#request`. In practice, it has been extensively tested against [the\n`request` module](https://github.com/mikeal/request), and there is a test to\nensure it works with [the `then-request`\nmodule](https://github.com/then/then-request).\n\nSepia was developed and is in use at LinkedIn since early 2013. There, it is\nused to improve the speed and reliability of the integration test suite for the\nnode.js server powering the mobile applications.\n\nhttps://github.com/linkedin/sepia  \nhttps://npmjs.org/package/sepia\n\n## Quick Start\n\nInstall the module.\n\n    npm install sepia\n\nPlop it into your application:\n\n    require('sepia');\n\nNow, when you start your application, run it with the `VCR_MODE` environment\nvariable set to the correct value:\n\n    npm start                   # no sepia\n    VCR_MODE=record npm start   # sepia, in record mode\n    VCR_MODE=playback npm start # sepia, in playback mode\n    VCR_MODE=cache npm start    # sepia, in cache mode\n\n## Running the examples\n\n    cd sepia # wherever you installed the module\n    npm install\n    time VCR_MODE=record   node examples/http\n    time VCR_MODE=playback node examples/http # notice it's much faster!\n\nThe example is located in `examples/http.js`. It exercises the core\nfunctionality of the module.\n\n    cd sepia\n    npm install\n    rm -r fixtures # in case you had previously generated fixtures\n    VCR_MODE=cache node examples/cache\n\nThis example demonstrates the cache mode, which makes a real HTTP request and\nrecords it if the fixture does not exist, but then reuses the fixture if it\ndoes exist. Notice that the first call takes about one second, whereas the\nsecond call finishes quickly.\n\nTo run all the examples in the correct modes, run:\n\n    npm test\n\n## Motivation\n\n<img src=\"https://raw.github.com/linkedin/sepia/master/architecture-diagram-1.png\" alt=\"\" height=\"200\" width=\"450\" align=\"center\" />\n\nSepia was created for the following use case:\n\n* Integration tests are being run against a node.js server under test.\n* The server under test makes HTTP requests to external downstream services.\n* The integration tests are driven by a client running in a separate process\n  than the server.\n\nEven though the server is the system being tested, the stability of the\nintegration tests depends on the reliability of the downstream services.\nAdditionally, making HTTP calls to live downstream services makes the\nintegration tests very slow. To combat this, sepia hooks into the node.js\n`http` and `https` modules inside the server process, intercepting outgoing\nHTTP(S) requests. Sepia, records these requests, then plays them back the next\ntime the requests are made.\n\n## VCR Modes\n\nThe value of the `VCR_MODE` environment variable determines how sepia behaves.\nAcceptable values are:\n\n* `record`: Make the downstream request, then save it to a fixture file.\n* `playback`: Don't make the downstream request. Attempt to retrieve the data\n  from the corresponding fixture file, and throw an error if the file does not\n  exist.\n* `cache`: First try to locate the fixture and play it back. If the fixture\n  file does not exist, make the downstream request and save it to the file.\n\n## Fixture Filenames\n\nFixture data generated during the recording phase are stored in files. In order\nto uniquely associate each HTTP request with a filename used to store the\nfixture data, several characteristics of the request are examined:\n\n* The HTTP method, e.g. `GET` or `POST`.\n* The request URL.\n* The request body.\n* The names of all the request headers.\n* The names of all the cookies sent in the request.\n\nThis data is then aggregated and sent through an MD5 hash to produce the\nfilename. Users of sepia can hook into this process of constructing the\nfilename, as explained in a subsequent sections.\n\nThis core functionality is exercised in `examples/http.js` and\n`examples/request.js`:\n\n    time VCR_MODE=record   node examples/http\n    time VCR_MODE=playback node examples/http\n\n    time VCR_MODE=record   node examples/request\n    time VCR_MODE=playback node examples/request\n\n## Fixture Data\n\nBy default, the files are stored in `fixtures/generated` under the directory in\nwhich the application was started. To override this:\n\n    var sepia = require('sepia');\n    sepia.fixtureDir(path.join(process.cwd(), 'sepia-fixtures'));\n\nIf this directory doesn't exist, it will be created.\n\nThis functionality is exercised in `examples/fixtureDir`:\n\n    VCR_MODE=record   node examples/fixtureDir\n    VCR_MODE=playback node examples/fixtureDir\n\n## Configure\n\nSepia can be optionally configured using a call to `sepia.configure()`. All\noptions have default values, so they need not be configured unless necessary.\n\n    var sepia = require('sepia');\n    sepia.configure({\n      verbose: true,\n      debug: true\n    });\n\nThe full list of options are as follows:\n\n- `verbose`: outputs extra data whenever a fixture is accessed, along with the\n  parts used to create the name of the fixture.\n- `touchHits`: disable timestamp update of fixture files on a cache hit.\n- `includeHeaderNames`, `headerWhitelist`, `includeCookieNames`,\n  `cookieWhitelist`: detailed in a later section.\n- 'debug': Useful for debugging the requests when there is a cache miss. If\n   fixtures are recorded with debug mode true, Sepia will additionally save all\n   the incoming requests  as '.request' files. Furthermore, in case of a cache\n   miss, during playback, it will attempt to compare the the missing\n   request(.missing), against all the available saved requests(.requests)\n   to find the best match, by computing the string distance between each. The\n   output will be the most similar request fixture, having the least string\n   distance. Based on this url and body filters can be added which is explained\n   in the next section.\n\n   For performance and to minimize the search space & space complexity, it is\n   recommended to have fixtures saved in separate folders per test or test suite.\n   The debug feature is still under development and we will continue to refine\n   it in the upcoming releases.\n\n## URL and Body Filtering\n\nBoth the URL and the request body, if present, are used to generate the\nfilename for fixtures. The latter is used to differentiate between two POST or\nPUT requests pointing to the same URL but differing only in the request body.\n\nSometimes, a request contains data in the URL or the body that is necessary for\nthe successful execution of that request, but changes from repeated invocations\nof that resource. One typical example is a timestamp; another is a uniquely\ngenerated request ID. However, sometimes two requests that have all other parts\nof the request aside from these parameters constant should be considered the\nsame for recording and playback purposes.\n\nTo this end, a URL and body filtering functionality is provided. Suppose that\nyour tests make the following request:\n\n    request('http://example.com/my-resource?time=' + Date.now(), next);\n\nand while the `time` query parameter is required for the request to complete,\nyou want to playback the same data that was recorded, regardless of what\ntimestamp was used during recording and during playback. Use a URL filter:\n\n    var sepia = require('sepia');\n    sepia.filter({\n      url: /my-resource/,\n      urlFilter: function(url) {\n        return url.replace(/time=[0-9]+/, '');\n      }\n    });\n\nThe `url` field is used to determine which requests should have `urlFilter`\napplied to it. The matcher is a regex. The filter is only applied to determine\nwhich fixture will be used; the actual request made to the remote resource\nduring recording is unchanged.\n\nThe filter specification can also contain a `bodyFilter` function that operates\non the request body. Either `urlFilter` or `bodyFilter` may be specified.\n\nMultiple calls to `sepia#filter` may be made. All matching filters are applied\nin the order they are specified. The `url` property of the filter is used to\nmatch the unmodified URL, regardless of the transformations it undergoes due to\nmatching `urlFilter` functions.\n\nAn example of this functionality can be found in `examples/filters`:\n\n    VCR_MODE=record   node examples/filters\n    VCR_MODE=playback node examples/filters\n\n## Headers and Cookies\n\nHTTP headers and cookies are often relevant to the way requests are served, but\ntheir exact values are often highly variable. For example, the presence of\ncertain cookies may affect the authentication mechanism used behind the scenes,\nand while one may wish to exercise both mechanisms, it is not useful to require\nthat the actual authentication cookie have a particular value.\n\nSepia generates filenames based on the presence and absence of header and\ncookie _names_. In particular, all the header names are lower-cased and sorted\nalphabetically, and this list is used to construct the fixture filename\ncorresponding to a request. The same applies to the cookie names.\n\nIf this feature is not desired, it can be disabled by calling\n`sepia.configure()`:\n\n    var sepia = require('sepia');\n    sepia.configure({\n      includeHeaderNames: false,\n      includeCookieNames: false\n    });\n\nAdditionally, a whitelist can be specified for the headers or for the cookies.\nIf the whitelist is empty, as is the default, all header names and cookie names\nwill be used to construct the fixture filename. If either whitelist has any\nstrings in it, only the corresponding headers or cookies will be used to\nconstruct the filename. Either whitelist can be specified in isolation or both\nmay be specified:\n\n    var sepia = require('sepia');\n    sepia.configure({\n      headerWhitelist: ['upgrade', 'via', 'x-custom'],\n      cookieWhitelist: ['oldAuth', 'newAuth']\n    });\n\nNote that capitalization does not matter.\n\nExamples of this functionality can be seen in `examples/headers.js`:\n\n    rm -r fixtures # in case you had previously generated fixtures\n    VCR_MODE=cache node examples/headers\n\n## Languages\n\nA downstream request may return different data based on the language requested\nby the server under test. To support this use case, sepia automatically\nisolates fixtures based on the value of the `Accept-Language` request header.\n\nThe first language in the list of languages specified by this header is used as\nthe directory name into which the fixtures will be placed for that request.\nThis directory is placed under the configured fixture directory. If no\nlanguages are specified, either due to an empty value or due to the header not\nbeing present in the first place, the fixtures will be placed directly into the\nconfigured fixture directory.\n\nExamples of this functionality can be seen in `examples/languages.js`:\n\n    rm -r fixtures # in case you had previously generated fixtures\n    VCR_MODE=record   node examples/languages\n    VCR_MODE=playback node examples/languages\n\n## VCR Cassettes\n\nA series of downstream requests can be isolated, and their fixtures stored in a\nseparate directory, using sepia.fixtureDir(). However, this requires that the\ngrouping happens in the same process as the one running sepia. In the\nmotivating example given at the beginning of this document, the integration\ntest driver runs in a completely different process than the server managed by\nsepia.\n\nTo help manage the sepia instance in a separate process, sepia itself can start\nup an embedded HTTP server in the process where it replaces the HTTP request\nfunctions. The test process can then communicate with this HTTP server and set\noptions, namely the directory into which fixtures will go. This architecture is\nis visualized as follows:\n\n<img src=\"https://raw.github.com/linkedin/sepia/master/architecture-diagram-2.png\" alt=\"\" height=\"210\" width=\"450\" align=\"center\" />\n\nThis can be enabled by asking to start up the embedded server:\n\n    var sepia = require('sepia').withSepiaServer();\n\nNote that because this causes a new server to be started, the process that\nincludes sepia should shutdown the server as follows:\n\n    sepia.shutdown();\n\nThis can be used to emulate \"cassette\"-like functionality:\n\n    // suppose the process that is running sepia is bound to port 8080\n    // in the test process\n    request.post({\n      url: 'localhost:58080/testOptions', // sepia's embedded server\n      json: {\n        testName: 'test1'\n      }\n    }, function(err, res, body) {\n      // now, all requests made by localhost:8080 will have their fixtures\n      // isolated into a directory name 'test1'\n      request.get({\n        url: 'localhost:8080/makeDownstreamRequests'\n      });\n    });\n\nNote that the functionality of setting the test options will be available in a\nsepia client library in the future.\n\nCurrently, the port of the embedded server is hard-coded to be `58080`, but\nthis will be configurable in the future. Furthermore, only the \"test name\" can\nbe set, but more options may become available.\n\nAn example of this functionality can be seen in `examples/testName.js`:\n\n    rm -r fixtures # in case you had previously generated fixtures\n    VCR_MODE=cache node examples/testName\n\n### Bypassing the Cassette\n\nWhen isolating a group of fixtures into a separate directory, it is sometimes\nuseful to specify a single fixture as \"global,\" that is living outside the\ntest-specific directory and shared by multiple tests. To achieve this, a filter\ncan be added:\n\n    var sepia = require('sepia');\n    sepia.filter({\n      url: /my-global-resource/,\n      global: true\n    });\n\nNow, all requests whose URLs match `/my-global-resource/` will be placed in\nthe root of the configured `fixtureDir`, regardless of what the current test\nname is.\n\n### Cassettes Without Modifying Global State\n\nThe above approach to VCR cassettes modifies global state in the server managed\nby sepia. This prevents running multiple tests--with different test names--in\nparallel, because the nature of the global state is such that only one test\nname can be set at one time. If you're willing to pass along information from\nan incoming request down to a downstream request, sepia provides a stateless\nalternative: the `x-sepia-test-name` header.\n\nThe `x-sepia-test-name` header, when passed to a downstream request, will\noverride the globally-configured test name. The header itself is not passed to\nany downstream service, nor is the header name used in the calculation of the\nfixture name.\n\nThe downside is that the server under test must pass along information from the\ntest integration runner to each of its downstream requests, because otherwise,\nsepia has no means of determining the associated test name for a particular\ndowstream request.\n\n## Limitations\n\n### Repeated Identical HTTP Requests\n\nIf the same request returns different data during different invocations, sepia\nhas no way of differentiating between the two invocations. This can happen\nwhen, for example, a resources is fetched using a `GET` request, it is\nmodified using a `PUT` request, and it is fetched once more using a `GET`\nrequest to verify that it was updated successfully.\n\nWhile you can use the test name functionality described above, it may not be\nsemantically valid to spread fixtures for the same test under multiple\ndirectories. One way around this currently is to actually make the requests\ndifferent in some way.\n\nFor example, in an integration test scenario, you may be able to pass a unique\nidentifier (e.g. `testUpdate1` and `testUpdate2`) along with each\nrequest made from the test. Typically, this would be passed as a query\nparameter that would be passed along by the server under test to any downstream\nservices, which would then ignore this parameter.\n\n## Technical Details\n\nSepia wraps around the `http#request` and the `https#request` functions. Each\noutgoing request is trapped. Depending on the value of the `VCR_MODE`\nenvironment variable, the request is either made and stored in a file, or the\ndata is retrieved from a file and sent back using a dummy response object.\n\n## Contributors\n\n* [Avik Das](https://github.com/avik-das)\n* [Vlad Shlosberg](https://github.com/vshlos)\n* [Ethan Goldblum](https://github.com/egoldblum)\n* [Shao-Hua Kao](https://github.com/ethankao)\n* [Deepank Gupta](https://github.com/deepankgupta)\n* [Priyanka Salvi](https://github.com/salvipriyanka/)\n* [Ashima Atul](https://github.com/ashimaatul)\n* [Delwyn de Villiers](https://github.com/delwyn)\n* [Mark Seminatore](https://github.com/mseminatore)\n","starsCount":4,"created":"2013-12-09T03:14:16.755Z","modified":"2016-12-06T06:47:08.988Z","lastPublisher":{"name":"avik-das","email":"avik.das@berkeley.edu"},"owners":[{"name":"avik-das","email":"avik.das@berkeley.edu"},{"name":"deepankgupta","email":"deepankgupta@gmail.com"}],"other":{"_attachments":{},"_from":".","_id":"sepia","_nodeVersion":"6.9.1","_npmOperationalInternal":{"host":"packages-12-west.internal.npmjs.com","tmp":"tmp/sepia-2.0.2.tgz_1481006828754_0.37460095318965614"},"_npmUser":{"name":"avik-das","email":"avik.das@berkeley.edu"},"_npmVersion":"3.10.8","_rev":"3-c84184ea7bc78903b5275bb7c850660d","_shasum":"5310bb7357e7d47e5c2d20e54c02865dafec5285","author":{"name":"Avik Das","email":"avik.das@berkeley.edu"},"bugs":{"url":"https://github.com/linkedin/sepia/issues"},"contributors":[{"name":"Vlad Shlosberg","url":"https://github.com/vshlos"},{"name":"Ethan Goldblum","url":"https://github.com/egoldblum"},{"name":"Shao-Hua Kao","url":"https://github.com/ethankao"},{"name":"Deepank Gupta","url":"https://github.com/deepankgupta"},{"name":"Priyanka Salvi","url":"http://www.linkedin.com/in/coolsmartgalpriyankanew"},{"name":"Ashima Atul","url":"https://github.com/ashimaatul"}],"directories":{},"dist-tags":{"latest":"2.0.2"},"dist":{"shasum":"5310bb7357e7d47e5c2d20e54c02865dafec5285","tarball":"http://registry.npmjs.org/sepia/-/sepia-2.0.2.tgz"},"maintainers":[{"name":"avik-das","email":"avik.das@berkeley.edu"},{"name":"deepankgupta","email":"deepankgupta@gmail.com"}],"readmeFilename":"README.md","time":{"modified":"2016-12-06T06:47:08.988Z","created":"2013-12-09T03:14:16.755Z","1.0.0":"2013-12-09T03:14:18.932Z","1.0.1":"2014-01-02T19:08:12.109Z","1.0.2":"2014-02-19T03:13:35.912Z","1.0.3":"2014-02-26T17:53:57.452Z","1.0.4":"2014-08-28T00:17:02.529Z","2.0.0":"2015-02-26T00:46:22.950Z","2.0.1":"2015-03-09T18:23:38.362Z","2.0.2":"2016-12-06T06:47:08.988Z"},"users":{"phette23":true,"tobiasnickel":true,"nickeltobias":true,"mseminatore":true}}}