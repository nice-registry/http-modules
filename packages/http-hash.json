{"name":"http-hash","version":"2.0.0","description":"HTTP router based on a strict path tree structure","keywords":["router","http","path","hash"],"repository":"https://github.com/Matt-Esch/http-hash","main":"index","homepage":"https://github.com/Matt-Esch/http-hash","dependencies":{},"devDependencies":{"coveralls":"^2.10.0","istanbul":"^0.2.7","jshint":"^2.5.0","opn":"^1.0.0","pre-commit":"0.0.5","run-browser":"^1.3.0","tap-spec":"^0.1.8","tape":"^2.12.3"},"licenses":[{"type":"MIT","url":"http://github.com/Matt-Esch/http-hash/raw/master/LICENSE"}],"scripts":{"test":"npm run jshint -s && NODE_ENV=test node test/index.js | tap-spec","unit-test":"NODE_ENV=test node test/index.js | tap-spec","jshint-pre-commit":"jshint --verbose $(git diff --cached --name-only | grep '\\.js$')","jshint":"jshint --verbose .","cover":"istanbul cover --report html --print detail test/index.js","view-cover":"istanbul report html && opn ./coverage/index.html","travis":"npm run cover -s && istanbul report lcov && ((cat coverage/lcov.info | coveralls) || exit 0)","phantom":"run-browser test/index.js -b","browser":"run-browser test/index.js"},"engine":{"node":">= 0.8.x"},"pre-commit":["jshint-pre-commit","unit-test"],"ngen-version":"4.0.3","gitHead":"7bcc2f74cd52137483d40f15711c512e0aefee8c","versions":[{"number":"1.0.0","date":"2014-11-17T11:24:23.463Z"},{"number":"1.0.1","date":"2014-11-30T02:54:37.994Z"},{"number":"1.0.2","date":"2014-12-02T17:11:54.961Z"},{"number":"1.1.0","date":"2015-02-25T19:21:58.087Z"},{"number":"1.1.1","date":"2015-04-10T03:20:15.450Z"},{"number":"2.0.0","date":"2015-08-03T22:11:29.248Z"}],"readme":"# http-hash\n\n[![build status][build-png]][build]\n[![Coverage Status][cover-png]][cover]\n[![Davis Dependency status][dep-png]][dep]\n\n\n[![NPM][npm-png]][npm]\n\n<!-- [![browser support][test-png]][test] -->\n\nHTTP router based on a strict path tree structure\n\n## Example 1 : Basic routes\n\n```js\nvar HttpHash = require('http-hash');\n\n// Create a new http hash\nvar hash = HttpHash();\n\n// Create a route mapping to /test/<anything but \"/\">\nhash.set('/test/:foo/', function (req, res) {\n    res.end();\n});\n\n// Get a valid route\nvar route = hash.get('/test/var');\nconsole.log(route);\n/*\n-> {\n    handler: function (req, res) {},\n    params: {\n        foo: 'var'\n    },\n    splat: null\n}\n*/\n\n// Get an invalid route (returns null)\nvar missing = hash.get('/missing');\nconsole.log(missing);\n/*\n-> {\n    handler: null,\n    params: {},\n    splat: null\n}\n*/\n\n```\n\n## Example 2 : Trailing splats\n\n```js\nvar HttpHash = require('http-hash');\n\n// Create a new http hash\nvar hash = HttpHash();\n\n// Create a route mapping to /test/<anything but \"/\">/<anything>\nhash.set('/foo/:test/*', function (req, res) {\n    res.end();\n});\n\nvar route = hash.get('/foo/val/one/two/three');\nconsole.log(route);\n/*\n-> {\n    handler: function (req, res) { ... },\n    params: {\n        test: 'val'\n    },\n    splat: 'one/two/three'\n}\n*/\n```\n\n## Overview\n\nThe most popular node routers are based on regular expression\nmathching. This means that the order in which the routes are\ndefined affects the resolution of a route to handler. Sometimes\nthis is desirable, but it would often be better to have a\nresolution scheme that is easier to reason about.\n\n`http-hash` solves the routing problem by making route resolution\nindependent of the order in which routes are defined. It does so\nby breaking a path into a tree of nodes, based on a simple split\non `/`. For example, the route `/foo/bar/baz` is treated as tree\nnodes `foo > bar > baz`. We call `foo`, `bar` and `baz` path\nsegments.\n\nTheses path segments are arranged into a tree of nodes, where\neach segment defines a node in the tree. Each node can point to:\n\n - a fixed handler `node.handler`, otherwise known as the node\n   value\n\n - a set of static paths indexed by path name `node.staticPaths`\n\n - a variable subtree `node.variablePaths`, that can match a\n   single named parameter OR the remainder of a route (splat).\n\n\nIf the last character of a defined route is `*`, a variable path\n(or splat) will be inserted, consuming the rest of the path.\nThis allows for subrouting, i.e. if you want to mount a static\nfilesystem on `/fs` you would set the path as `/fs/*` where\nthe nodes are broken down into the tree `fs > *`. The remainder\nof the route will be returned as a \"splat\" value, allowing for\nfurther routing.\n\nIn the simple case, the route tree is based on exact matches on\nthe name of the segment. That is to say, for the case where we\nwant to match `/foo/bar/baz`, the tree looks like\n\n```js\n{\n  staticPaths: {\n    foo: {\n      staticPaths: {\n        bar: {\n          staticPaths: {\n            baz: {\n              handler: function (req, res) {}\n            }\n          }\n        }\n      }\n    }\n  }\n}\n```\n\nWhen defining routes, variable paths may be specified. This is\nwhere path segments are prefixed with `:` i.e. `/foo/:bar/baz`.\n\nFor the `:bar` segment, the route consumes the single variable\nroute slot for that node in the tree. So for example, the route\n`/foo/:bar/baz looks like\n\n```js\n{\n  staticPaths: {\n    foo: {\n      variablePaths: {\n        staticPaths: {\n          'baz': function (req, res) {}\n        }\n      }\n    }\n  }\n}\n```\n\nSince a node can have both static and dynamic paths associated\nwith it, the static path will win over the variable path when we\nresolve the path.\n\n### Trailing slashes\n\nIn most cases the trailing / does not matter. Variables cannot be\nthe empty string, and neither can splats. A splat value will not\ncontain the leading slash as it is consumed by the parent node.\n\n### Path conflicts\n\nIf a path conflict occurs, an exception will be thrown. Conflicts\noccur when:\n\n - A route is defined twice, resolving to two handlers\n\nThis is the simplest case where `/foo` has been defined twice.\n\n\n - Variable names in the path are different\n\nNote that `/foo/:vara/` and `/foo/:varb/` conflict, since they\nboth resolve to `foo.variablePaths`, but have different param\nnames.\n\n\n - A variable route is defined for a splat node\n\nIn the case of splats being defined at a level, no other\nother variables may be specified, as we cannot distinguish\nbetween `/foo/:var` and `/foo/*`. It is however ok to put static\npaths on the same level, i.e. `/foo/bar` and `/foo/*`. In this\ncase, the static paths will be tried first before yielding the\nsplat.\n\n\n## Docs\n\n### `var hash = HttpHash()`\n\n```ocaml\nhttp-hash := () => HttpHash\n\ntype HttpHash := {\n    get: (String: url) => RouteResult,\n    set: (String: path, Any: handler) => void,\n    _hash: RouteNode\n}\n\ntype RouteNode := {\n    handler: Any,\n    fixedPaths: Object<String, RouteNode>,\n    variablePaths: RouteNode | null\n}\n\ntype RouteResult := {\n    handler: Any | null,\n    params: Object<String, String>,\n    splat: String | null\n}\n```\n\n`http-hash` exports a safe constructor function that when called\nreturns a new `HttpHash`. `get` and `set` methods are exposed for\npublic consumption and the underlying data structure `_hash` is\nexposed for private inspection/internal use.\n\n### `hash.set(path, handler)`\n\n```ocaml\nhash.set := (String: path, Any: handler) => void\n```\n\nPuts a path  in the route table. If the path conflicts with an\nexisting path, an exception will be thrown.\n\nRoutes containing a `*` that are not part of a `/*` prefix will\nalso throw an exception.\n\nA path should look like `/` or `/foo` or `/:foo` or a union of\ntheses things, or optionally end with `/*`\n\n- param names should not be repeated as they will conflict but\n  there is no strong assertion for this. The last param name\n  wins.\n\n- specifying a variable twice for a node will cause an exception\n\n- repeated and trailing '/' are ignored\n\n- paths are case sensitive\n\n- variables and splats are not matched by the empty string.\n\n\n### `hash.get(path)`\n\n```ocaml\nhash.get := (String: path) => RouteResult\n```\n\nGets a route from the route table. If there is no viable route,\nthe handler will be returned as `null` in the `RouteResult`\nobject.\n\nThe route result contains a `params hash`, containing a key for\neach named variable in the path. Additionally, if a splat route\nwas defined, the `splat` property will contain the tail portion\nof the route matched.\n\n\n## Installation\n\n`npm install http-hash`\n\n## Tests\n\n`npm test`\n\n## Contributors\n\n - Matt Esch\n\n## MIT Licensed\n\n  [build-png]: https://secure.travis-ci.org/Matt-Esch/http-hash.png\n  [build]: https://travis-ci.org/Matt-Esch/http-hash\n  [cover-png]: https://coveralls.io/repos/Matt-Esch/http-hash/badge.png?branch=master\n  [cover]: https://coveralls.io/r/Matt-Esch/http-hash\n  [dep-png]: https://david-dm.org/Matt-Esch/http-hash.png\n  [dep]: https://david-dm.org/Matt-Esch/http-hash\n  [test-png]: https://ci.testling.com/Matt-Esch/http-hash.png\n  [test]: https://ci.testling.com/Matt-Esch/http-hash\n  [npm-png]: https://nodei.co/npm/http-hash.png?stars&downloads\n  [npm]: https://nodei.co/npm/http-hash\n","starsCount":4,"created":"2014-11-17T11:24:23.463Z","modified":"2015-08-03T22:11:29.248Z","lastPublisher":{"name":"mattesch","email":"matt@mattesch.info"},"owners":[{"name":"mattesch","email":"matt@mattesch.info"}],"other":{"_attachments":{},"_from":".","_id":"http-hash","_nodeVersion":"0.10.32","_npmUser":{"name":"mattesch","email":"matt@mattesch.info"},"_npmVersion":"2.11.3","_rev":"1-ee833affabc3d65658a814446b3e6582","_shasum":"0b1c2615277e87c73084ec2c3d8c33cf2237b200","author":{"name":"Matt Esch","email":"matt@mattesch.info"},"bugs":{"url":"https://github.com/Matt-Esch/http-hash/issues","email":"matt@mattesch.info"},"contributors":[{"name":"Matt Esch"}],"directories":{},"dist-tags":{"latest":"2.0.0"},"dist":{"shasum":"0b1c2615277e87c73084ec2c3d8c33cf2237b200","tarball":"http://registry.npmjs.org/http-hash/-/http-hash-2.0.0.tgz"},"maintainers":[{"name":"mattesch","email":"matt@mattesch.info"}],"readmeFilename":"README.md","time":{"modified":"2015-08-03T22:11:29.248Z","created":"2014-11-17T11:24:23.463Z","1.0.0":"2014-11-17T11:24:23.463Z","1.0.1":"2014-11-30T02:54:37.994Z","1.0.2":"2014-12-02T17:11:54.961Z","1.1.0":"2015-02-25T19:21:58.087Z","1.1.1":"2015-04-10T03:20:15.450Z","2.0.0":"2015-08-03T22:11:29.248Z"},"users":{"nick.luo":true,"n370":true,"wenbing":true,"nicohe":true}}}