{"name":"sublog-http","version":"0.0.1","description":"Subscribe to Redis channel and push messages to a Redis list","main":"index.js","scripts":{"lint":"eslint --cache src","development":"NODE_ENV=development node --harmony-async-await src/index.js","test":"NODE_ENV=test node --harmony-async-await src/index.js","start":"NODE_ENV=production node --harmony-async-await src/index.js"},"license":"ISC","dependencies":{"bluebird":"^3.4.6","koa":"^2.0.0","koa-bodyparser":"^3.2.0","koa-router":"^7.0.1","lodash":"^4.17.2","redis":"^2.6.3"},"devDependencies":{"eslint":"^3.12.2"},"repository":"https://github.com/evanx/sublog-http","homepage":"https://github.com/evanx/sublog-http#readme","gitHead":"ee2d8e6ba7d0322a0f9e9d826bb8fdedbdfd41fb","versions":[{"number":"0.0.1","date":"2017-02-05T12:13:59.666Z"}],"readme":"# sublog-http\n\nA microservice to subscribe to a Redis pubsub channel, and serve messages via HTTP.\n\n## Example problem description\n\nThis service is intended for a personal requirement to subscribe to logging messages published via Redis.\nThese are arrays published via pubsub.\n```\nredis-cli publish 'logger:mylogger' '[\"info\", {\"name\": \"evanx\"}]'\n```\nwhere we might subscribe in the terminal as follows:\n```\nredis-cli psubscribe 'logger:*'\n```\nwhere we see the messages in the console as follows:\n```\nReading messages... (press Ctrl-C to quit)\n1) \"psubscribe\"\n2) \"logger:*\"\n3) (integer) 1\n1) \"pmessage\"\n2) \"logger:*\"\n3) \"logger:mylogger\"\n4) \"[\\\"info\\\", {\\\"name\\\": \\\"evanx\\\"}]\"\n```\nHowever we want to pipe to a command-line JSON formatter to enjoy a more readable rendering:\n```json\n[\n  \"info\",\n  {\n    \"name\": \"evanx\"\n  }\n]\n```\n\nWe found that `redis-cli psubscribe` didn't suit that use case, e.g. piping to `jq` or `python -mjson.tool` to format the JSON.\n\nIncidently see https://github.com/evanx/sub-push where we transfer messages to a list, `brpop` and then pipe to `jq` as an initial work-around.\n\nAlso see https://github.com/evanx/sub-write to subscribe and write to `stdout` with optional JSON formatting.\n\nHowever it seemed like a good idea to use a browser to render the logging messages, even for local viewing,\nwhich prompted the development of this `sublog-http` service.\n\n\n## Implementation\n\nThe essence of the implementation is as follows:\n```javascript\nasync function start() {\n    sub.on('message', (channel, message) => {\n        if (process.env.NODE_ENV !== 'production') {\n            console.log({channel, message});\n        }\n        state.messages.splice(0, 0, JSON.parse(message));\n        state.messages = state.messages.slice(0, 10);\n    });\n    sub.subscribe(config.subscribeChannel);\n    return startHttpServer();\n}\n```\nwhere we keep a list of the last 10 messages in reverse order by splicing incoming messages\ninto the head of the array.\n\nWe publish these `messages` via HTTP using Koa:\n```javascript\nasync function startHttpServer() {\n    api.get('/', async ctx => {\n        if (/(Mobile|curl)/.test(ctx.get('user-agent'))) {\n            ctx.body = JSON.stringify(state.messages, null, 2);\n        } else {\n            ctx.body = state.messages;\n        }\n    });\n    app.use(api.routes());\n    app.use(async ctx => {\n       ctx.statusCode = 404;\n    });\n    state.server = app.listen(config.httpPort);\n}\n```\nwhere we format the JSON for mobile browsers i.e. without JSON formatting extensions.\n```\nevans@eowyn:~$ curl -s -I localhost:8080\nHTTP/1.1 200 OK\nContent-Type: text/plain; charset=utf-8\n```\n\nNote that `config` is populated from environment variables as follows:\n```javascript\nconst config = ['subscribeChannel', 'httpPort', 'redisHost'].reduce((config, key) => {\n    if (process.env[key] === '') {\n        throw new Error('empty config ' + key);\n    } else if (process.env[key]) {\n        config[key] = process.env[key];\n    } else if (!config[key]) {\n        throw new Error('missing config ' + key);\n    }\n    return config;\n}, {\n    redisHost: '127.0.0.1'\n});\n```\nwhere we default `redisHost` to `localhost`\n\nNote that we check that an environment variable is not empty, for safety sake.\n\nFor example the following command line runs this service to subscribe to channel `logger:mylogger` and serve the JSON messages via port `8888`\n```shell\nsubscribeChannel=logger:mylogger httpPort=8888 npm start\n```\n\n![screenshot](https://raw.githubusercontent.com/evanx/sublog-web/master/readme-images/logger-phantomjs-redis.png)\n<hr>\n\nIncidently, some sample Node code for a client logger that publishes via Redis:\n```javascript\nconst createRedisLogger = (client, loggerName) =>\n['debug', 'info', 'warn', 'error'].reduce((logger, level) => {\n    logger[level] = function() {\n        if (!client || client.ended === true) { // Redis client ended\n        } else if (level === 'debug' && process.env.NODE_ENV === 'production') {\n        } else {\n            const array = [].slice.call(arguments);\n            const messageJson = JSON.stringify([\n                level,\n                ...array.map(item => {\n                    if (lodash.isError(item)) {\n                        return item.stack.split('\\n').slice(0, 5);\n                    } else {\n                        return item;\n                    }\n                })\n            ]);\n            client.publish(['logger', loggerName].join(':'), messageJson);\n        }\n    };\n    return logger;\n}, {});\n```\nwhere the logger `level` is spliced as the head of the `arguments` array.\n\nNote that logged errors are specially handled i.e. a slice of the `stack` is logged.\n\nLater we'll publish a more sophisticated client logger with rate limiting:\n```javascript\n    const minute = new Date().getMinutes();\n    if (metric.minute !== minute) {\n        if (metric.ignored > 0) {\n            client.publish(['logger', loggerName].join(':'), ['warn', {ignored: metric.ignored}]);\n        }\n        metric.minute = minute;\n        metric.count = 0;\n        metric.ignored = 0;\n    } else {\n        metric.count++;\n        if (options.minuteLimit && metric.count > options.minuteLimit) {\n            metric.ignored++;\n            return;\n        }\n    }\n```\n\n\n## Docker notes\n\nThis tested on Docker 1.12 (Ubuntu 16.04) and 1.11 (Amazon Linux 2016.09)\n```\ndocker -v\n```\n- `Docker version 1.12.1, build 23cf638`\n- `Docker version 1.11.2, build b9f10c9/1.11.2`\n\n```\ncat /etc/issue\n```\n- `Ubuntu 16.04.1 LTS`\n- `Amazon Linux AMI release 2016.09`\n\n### Build application container\n\nLet's build our application container:\n```shell\ndocker build -t sublog-http:test https://github.com/evanx/sublog-http.git\n```\nwhere the image is named and tagged as `sublog-http:test`\n\nAlternatively `git clone` and `npm install` and build from local dir e.g. if you wish to modify the `Dockerfile`\n```shell\ngit clone https://github.com/evanx/sublog-http.git &&\n  cd sublog-http && npm install &&\n  docker build -t sublog-http:test .\n```\nwhere the default `Dockerfile` is as follows:\n```\nFROM mhart/alpine-node\nADD package.json .\nRUN npm install\nADD src .\nENV httpPort 8080\nEXPOSE 8080\nCMD [\"node\", \"--harmony-async-await\", \"src/index.js\"]\n```\nwhere we `ADD package.json` and `RUN npm install` first before `ADD src` - so that if the source has changed but not `package.json` then the cached intermediate image after `npm install` is stil usable for a fast rebuild.\n\n\n### Run on host network\n\nUsing the latest Docker version or 1.12, we run on the host's network i.e. using the host's Redis instance:\n```shell\ndocker run --network=host -e NODE_ENV=test \\\n  -e subscribeChannel=logger:mylogger -e httpPort=8088 -d sublog-http:test\n```\nwhere we configure its port to `8088` to test, noting:\n- although by default the port is `8080` and that is exposed via the `Dockerfile`\n- as the network is a `host` bridge, so the reconfigured `httpPort` is accessible on the host\n\nThis container can be checked as follows:\n- `docker ps` to see if actually started, otherwise omit `-d` to debug.\n- `netstat -ntl` to see that a process is listening on port `8088`\n- `http://localhost:8088` via `curl` or browser\n\nEnsure that Redis is running on the host i.e. `localhost` port `6379`\n\n#### Test message\n\nWe can publish a test logging message as follows:\n```shell\nredis-cli publish logger:mylogger '[\"info\", \"test message\"]'\n```\nHTTP fetch:\n```shell\ncurl -s http://localhost:8088 | python -mjson.tool\n```\n\nSample output:\n```json\n[\n    [\n        \"11:45\",\n        \"info\",\n        \"test message\"\n    ],\n    [\n        \"11:43\",\n        \"debug\",\n        \"subscribeChannel\",\n        \"logger:mylogger\"\n    ]\n]\n```\n\n### Bridge network\n\nAlternatively for Docker 1.11 without `--network=host` but configuring a `redisHost` IP number:\n```shell\ndocker run -e NODE_ENV=test -e subscribeChannel=logger:mylogger \\\n  -e redisHost=$redisHost -d sublog-http:test\n```\nwhere `redisHost` is the IP number of the Redis instance to which the container should connect.\n\nNote that it cannot be `localhost` as the context is the container which is running the HTTP service only.\nNor can it be omitted as `localhost` is the default Redis host used by this service.\n\nWe publish a test message as follows:\n```shell\nredis-cli -h $redisHost publish logger:mylogger '[\"info\", \"test message\"]'\n```\nwhere naturally we must specify the same `redisHost` to which the service connects\ni.e. not the default `localhost` unless its external IP number was provided to the service,\nand even then rather use that to test.\n\nGet container ID, IP address, and curl:\n```shell\nsublogContainer=`docker ps -q -f ancestor=sublog-http:test | head -1`\nsublogHost=`docker inspect --format '{{ .NetworkSettings.Networks.bridge.IPAddress }}' $sublogContainer`\necho $sublogHost\ncurl -s http://$sublogHost:8080 | python -mjson.tool\n```\n\nNote that in this case the port will be the `8080` default configured and exposed in the `Dockerfile`\n\nIncidently we can kill all containers by our image name as follows:\n```shell\nids=`docker ps -q -f ancestor=sublog-http:test`\n[ -n \"$ids\" ] && docker kill $ids\n```\n\nAltogether:\n```shell\nif [ -n \"$redisHost\" ]\nthen    \n  ids=`docker ps -q -f ancestor=sublog-http:test`\n  [ -n \"$ids\" ] && docker kill $ids\n  docker run -e NODE_ENV=test -e subscribeChannel=logger:mylogger \\\n    -e redisHost=$redisHost -d sublog-http:test\n  sleep 1\n  redis-cli -h $redisHost publish logger:mylogger '[\"info\", \"test message\"]'\n  sublogContainer=`docker ps -q -f ancestor=sublog-http:test`\n  if [ -n \"$sublogContainer\" ]\n  then\n    sublogHost=`\n      docker inspect --format '{{ .NetworkSettings.Networks.bridge.IPAddress }}' $sublogContainer`\n    echo $sublogHost\n    curl -s http://$sublogHost:8080 | python -mjson.tool\n    docker kill $sublogContainer\n  fi\nfi\n```\n\n## Isolated Redis container and network\n\nIn this example we create an isolated network:\n```shell\ndocker network create --driver bridge redis\n```\n\nWe can create a Redis container named `redis-logger` as follows\n```shell\ndocker run --network=redis --name redis-logger -d redis\n```\n\nWe query its IP number and store in shell environment variable `loggerHost`\n```\nloggerHost=`docker inspect --format '{{ .NetworkSettings.Networks.redis.IPAddress }}' redis-logger`\n```\nwhich we can debug via\n```shell\necho $loggerHost\n```\nto see that set e.g. to `172.18.0.2`\n\nFinally we run our service container:\n```shell\ndocker run --network=redis --name sublog-http-mylogger \\\n  -e NODE_ENV=test -e redisHost=$loggerHost -e subscribeChannel=logger:mylogger -d sublog-http:test\n```\nwhere we configure `redisHost` for the `redis-logger` container via environment variable.\n\nNote that we:\n- use the `redis` isolated network bridge for the `redis-logger` container\n- configure `subscribeChannel` to `logger:mylogger` via environment variable\n- name this container `sublog-http-mylogger`\n- use the previously built image `sublog-http:test`\n\nGet its IP address:\n```\nmyloggerHttpServer=`\n  docker inspect --format '{{ .NetworkSettings.Networks.redis.IPAddress }}' sublog-http-mylogger\n`\n```\n\nPrint its URL:\n```\necho \"http://$myloggerHttpServer:8080\"\n```\n\nCurl test:\n```\ncurl -s $myloggerHttpServer:8080 | python -mjson.tool\n```\n\n\n## Related projects\n\nSee\n- https://github.com/evanx/sub-push - subscribe to Redis pubsub channel and transfer messages to a Redis list\n- https://github.com/evanx/sub-write - subscribe to Redis pubsub channel and write to `stdout` with optional JSON formatting\n\nWe plan to publish microservices that similarly subscribe, but with purpose-built rendering for logging messages e.g. error messages coloured red.\n\nWatch\n- https://github.com/evanx/sublog-console\n","created":"2017-02-05T12:13:59.666Z","modified":"2017-02-05T12:13:59.666Z","lastPublisher":{"name":"evanx","email":"evan.summers@gmail.com"},"owners":[{"name":"evanx","email":"evan.summers@gmail.com"}],"other":{"_attachments":{},"_from":".","_id":"sublog-http","_nodeVersion":"7.4.0","_npmOperationalInternal":{"host":"packages-18-east.internal.npmjs.com","tmp":"tmp/sublog-http-0.0.1.tgz_1486296838898_0.8648790568113327"},"_npmUser":{"name":"evanx","email":"evan.summers@gmail.com"},"_npmVersion":"4.0.5","_rev":"1-cf525d7310163495dc66d162429618e9","_shasum":"d382afb669f67e81131399d35a38ef92ad98a360","author":{"name":"Evan Summers"},"bugs":{"url":"https://github.com/evanx/sublog-http/issues"},"directories":{},"dist-tags":{"latest":"0.0.1"},"dist":{"shasum":"d382afb669f67e81131399d35a38ef92ad98a360","tarball":"https://registry.npmjs.org/sublog-http/-/sublog-http-0.0.1.tgz"},"maintainers":[{"name":"evanx","email":"evan.summers@gmail.com"}],"readmeFilename":"README.md","time":{"modified":"2017-02-05T12:13:59.666Z","created":"2017-02-05T12:13:59.666Z","0.0.1":"2017-02-05T12:13:59.666Z"}}}