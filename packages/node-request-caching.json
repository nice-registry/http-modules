{"name":"node-request-caching","version":"0.0.1","description":"HTTP and HTTPS requests with caching for node.js","scripts":{"test":"mocha --reporter spec"},"main":"./lib/request-caching","repository":"https://github.com/matteoagosti/node-request-caching","keywords":["caching","http","https","request"],"dependencies":{"hiredis":"0.1.x","redis":"0.7.x"},"devDependencies":{"mocha":"1.4.x"},"license":"MIT","engines":{"node":">=0.6"},"readme":"node-request-caching\n====================\n\n## HTTP and HTTPS requests with caching for node.js\n\n### Features\n\n- Zero configuration\n- Convenience methods for GET / POST requests with parameters (querystring / request body)\n- Automatic key generation based on request signature\n- Memory and Redis adapters for cache storage\n\n### Installation\n\nAs the module is not yet on npm registry, install with:\n\n```\nnpm install https://github.com/matteoagosti/node-request-caching/tarball/master\n```\n\nIf you want to run tests you first have to install `mocha` and the from the module directory run:\n\n```\nnpm test\n```\n\n### Usage\n\nYou can find a simple example into `examples/simple.js`\n\n```javascript\nvar RequestCaching = require('../lib/request-caching');\n\n// Cache into Memory\nvar rc = new RequestCaching();\n\nfor (var i = 0; i < 10; i++) {\n  setTimeout(function() {\n    rc.get(\n      'https://graph.facebook.com/facebook',  // URI\n      {fields: 'id,name'},                    // query string params\n      1,                                      // TTL in seconds\n      function(err, res, body, cache) {\n        console.log('Response', res);         // response params object (headers, statusCode)\n        console.log('Body', body);            // response body as string\n        console.log('Cache', cache);          // cache info object (hit, key)\n      }\n    );\n  }, i * 1000);\n}\n```\n\n### API\n\n#### RequestCaching(options)\n\nEvery instance has its own shared cache storage adapter.\n\nThis is the structure for the `options` parameter (with defaults values included):\n\n```javascript\n{\n  store: {                    // STORE config, shared among requests from the same instance\n    adapter: 'method',        // can be either memory or redis\n    options: {                // any additional options for the adapter (e.g. redis config)\n      ...\n    }\n  },\n  request: {                  // any defaults for node HTTP.request method\n    method: 'GET',\n    ...\n  },\n  caching: {                  // CACHING config\n    ttl: 60*60,               // default TTL in seconds, used when not specified in request\n    prefix: 'requestCaching'  // prefix to append before each key, if set keys will be prefix:key\n  }\n}\n```\n\n#### request(options, callback)\n\nIssues an HTTP / HTTPS request, optionally caching its result.\n\n`options` must be an object conformig to the following schema:\n\n```javascript\n{\n  uri: 'http[s]://...',       // Optional string containing remote uri. If specified\n                              // it will be used for building HTTP.request options\n  \n  params: {                   // Optional parameters that will be querystringified and\n    param1: 'value1',         // appended to GET querystring or added to POST request body.\n    ...                       // If uri contains already a query string, its param=value pairs \n                              // will be merged with params, without overwrite them\n  },\n  \n  request: {                  // HTTP.request method options\n    method: 'GET',            // default request method is GET\n    hostname: '...',\n    port: 80,\n    path: '/',\n    auth: '...',\n    headers: {                // If params is given, headers will contain the following:\n      'key': 'value',         // 'Content-Type': 'application/x-www-form-urlencoded',\n      ...                     // 'Content-Length': querystring.stringify(params)\n                              // However, if you specify them, they won't get overwritten\n    }\n  },\n\n  caching: {                  // CACHING config (if not specified will take instance's defaults)\n    ttl: 60*60,               // TTL in seconds\n    prefix: 'requestCaching', // prefix to append before key, if set final key will be prefix:key\n    key: '...'                // Optional parameter containing the cache key. If not specified\n                              // will be autogenerated by MD5 hashing the JSON.stringify of\n                              // [querystring.stringify(options.params), options.request]\n  }\n}\n```\n\n`callback(err, res, body, cache)` gets invoked whenever error or response occurs. Function arguments are:\n- `err`: the error message, `null` if everything is ok\n- `res`: object containing some properties of the HTTP.response:\n\n```javascript\n{\n\theaders: {\n\t\t'key': 'value',\n\t\t...\n\t},\n\tstatusCode: ...\n}\n```\n\n- `body`: response's body as string\n- `cache`: object containing some cache properties:\n\n```javascript\n{\n\thit: true/false,   // true if content was fetched from cache\n\tkey: '...',        // the key (useful when using automatic key generation)\n}\n```\n\n#### get(uri, params, ttl, callback)\n\nConvenience method over `request(options, callback)`. Issues a `GET` request to the given `uri`, adding `params` to the query string, storing into cache for `ttl` seconds, invoking `callback` once done (both when error or success, according to the same schema of `request(options, callback)`. If `uri` already includes a query string, its value get added to `params`, but without overriding what's already defined in `params`.\n\n#### post(uri, params, ttl, callback)\n\nThe same as previously mentioned `get(uri, params, ttl, callback)`, but issuing a `POST` request, adding `params` to the request body and including the following request headers:\n\n```\n'Content-Type': 'application/x-www-form-urlencoded',\n'Content-Length': querystring.stringify(params)\n```\n\n### Additional notes\n\nRight now the TTL is specified in seconds, despite the `Memory` adapter can work with milliseconds resolution. I went for it as until `Redis 2.6` will be out, the current `Redis` adapter can't go below second precision; for consistency reasons I preferred to leave everything in seconds. In addition, `Redis` key's expire precision is in the order of half a second (more or less), so pay attention when storing keys with a TTL of 1, as it may happen that when reading them after 1.5 seconds you'll still get the cached entry.","versions":[{"number":"0.0.1","date":"2012-09-06T20:05:44.691Z"}],"starsCount":1,"created":"2012-09-06T20:05:42.610Z","modified":"2012-09-06T20:05:44.691Z","owners":[{"name":"matteoagosti","email":"matteo.agosti@gmail.com"}],"other":{"_attachments":{},"_id":"node-request-caching","_rev":"1-cef9b9d3757e404280bc84c4792f3700","author":{"name":"Matteo Agosti","email":"matteo@matteoagosti.com"},"directories":{},"dist-tags":{"latest":"0.0.1"},"dist":{"shasum":"6e48fe0e80a3950d9e8e8b0d0a0e207d54118f98","tarball":"http://registry.npmjs.org/node-request-caching/-/node-request-caching-0.0.1.tgz"},"maintainers":[{"name":"matteoagosti","email":"matteo.agosti@gmail.com"}],"time":{"modified":"2012-09-06T20:05:44.691Z","created":"2012-09-06T20:05:42.610Z","0.0.1":"2012-09-06T20:05:44.691Z"},"users":{"anmol1771":true}}}