{"name":"http-disk-cache","version":"0.7.1","description":"An HTTP client that maintains a persistent disk-based cache","homepage":"https://github.com/artillery/node-http-disk-cache#readme","license":"MIT","main":"index.js","scripts":{"test":"nodeunit test.js"},"keywords":["http cache","http","cache","stream"],"engines":{"node":">=0.12"},"repository":"https://github.com/artillery/node-http-disk-cache","devDependencies":{"nodeunit":"^0.9.1","commander":"^2.9.0","temp":"^0.8.3"},"dependencies":{"artillery-async":"^1.0.2","debug":"^2.2.0","glob":"^6.0.1","mkdirp":"^0.5.1","request":"^2.65.0"},"gitHead":"30bdc2968b737b31c9421bbf8812a22da2f94293","versions":[{"number":"0.0.1","date":"2015-10-22T23:40:29.764Z"},{"number":"0.0.2","date":"2015-10-23T01:20:49.557Z"},{"number":"0.1.0","date":"2015-10-26T01:11:16.953Z"},{"number":"0.2.0","date":"2015-12-08T21:10:22.551Z"},{"number":"0.3.0","date":"2015-12-11T19:07:01.499Z"},{"number":"0.3.1","date":"2015-12-11T20:23:22.102Z"},{"number":"0.3.2","date":"2015-12-12T16:42:25.581Z"},{"number":"0.4.0","date":"2016-04-06T21:45:39.560Z"},{"number":"0.5.0","date":"2016-04-11T20:15:09.588Z"},{"number":"0.6.0","date":"2016-04-20T14:59:25.712Z"},{"number":"0.7.0","date":"2016-05-18T01:06:33.068Z"},{"number":"0.7.1","date":"2016-05-18T04:06:58.844Z"}],"readme":"# http-disk-cache\n\n[![License](https://img.shields.io/github/license/artillery/node-http-disk-cache.svg)](https://github.com/artillery/node-http-disk-cache/blob/master/LICENSE)\n[![Issues](https://img.shields.io/github/issues/artillery/node-http-disk-cache.svg)](https://github.com/artillery/node-http-disk-cache/issues)\n[![Build Status](https://img.shields.io/circleci/project/artillery/node-http-disk-cache.svg)](https://circleci.com/gh/artillery/node-http-disk-cache)\n[![Dependencies](https://img.shields.io/gemnasium/artillery/node-http-disk-cache.svg)](https://gemnasium.com/artillery/node-http-disk-cache)\n\nAn HTTP client that maintains a persistent disk-based cache. This module was written for internal use with [Project Atlas](https://www.artillery.com/atlas) but may be of use to others.\n\n## Installation\n\n    npm install http-disk-cache\n\n## Example\n\n```javascript\nvar cache = new HTTPCache('/cache/root/directory');\n\ncache.getContents('http://example.com/url', function(err, buf, path) {\n  if (err) {\n    console.error(\"Error:\", err);\n  } else {\n    console.log(\"Saved\", buf.length, \"bytes to path\", path);\n  }\n};\n\ncache.openReadStream('http://example.com/url', function(err, readStream) {\n  if (err) { /* handle error */ }\n  else { readStream.pipe(destination); }\n});\n```\n\n## API\n\n### Class: HTTPCache\n\n#### new HTTPCache(cacheRoot)\n\nCreates an HTTP cache directory which will work out of `cacheRoot`. The directory is created if it doesn't exist.\n\n#### cache.getContents(url, callback)\n\nMain URL request method for HTTPCache.\n\n`url` may be a string URL or an object with a `url` key and any of the following options:\n- `headers`: An object of headers to pass along with the request\n- `encoding`: If specified, `callback` will get a String instead of a Buffer\n\nCallback arguments:\n- `err`: Optional error message\n- `contents`: A String if the `encoding` option was specified, otherwise a Buffer\n- `filename`: The path to the contents on disk (contents are always saved to disk regardless of cache expiry)\n\n#### cache.openReadStream(url[, onProgress], callback)\n\nCreates a readable stream for the contents of `url`.\n\n`url` may be a string URL or an object with a `url` key and any of the following options:\n- `headers`: An object of headers to pass along with the request\n\nonProgress arguments:\n- `numBytes`: Number of bytes read in the last chunk.\n\nCallback arguments:\n- `err`: Optional error message\n- `stream`: A readable stream containing the content of the URL\n- `filename`: The path to the contents on disk (contents are always saved to disk regardless of cache expiry)\n\n#### cache.assertCached(url[, onProgress], callback)\n\nChecks whether `url` is already in the cache and, if not, fetches and caches it. `url` may be a string or an object with the same options as `openReadStream()`. This is used to warm up the cache and is less resource-intensive than the other methods.\n\nonProgress arguments:\n- `numBytes`: Number of bytes read in the last chunk.\n\nCallback arguments:\n- `err`: Optional error message\n\n#### cache.abortAllInFlightRequests()\n\nCalls `abort()` on any in-progress HTTP requests that may have been initiated by `openReadStream()` or `assertCached()`. The callbacks for those methods will get called with an error.\n\n#### cache.getContentPathname(url[, options])\n\nReturn a path to a requested URL assuming that it's already been cached.\n\nOptions:\n- `absolute`: Return an absolute path instead of a path relative to the cache root (default: false)\n\n#### cache.setContentsSync(url, contents)\n\nSynchronously set the contents for `url`. `url` must begin with `cache:`. Throws on error.\n\n#### cache.getContentsSync(url, contents)\n\nSynchronously get the contents for `url`. Throws on error.\n\n`url` may be a string URL or an object with a `url` key and any of the following options:\n- `headers`: An object of headers to pass along with the request\n- `encoding`: If specified, will return a String instead of a Buffer\n\nReturns a buffer, unless `encoding` is provided.\n\n#### cache.reset()\n\n`reset` must be called if you wish to reload any expired assets. (Otherwise, assets always\npersist for the lifetime of the cache, even if they would not otherwise be cached at all.)\n\n#### cache.clean(shouldCleanCb, finalCb)\n\nIterates over all `.meta` files in the cache. For each one, the meta data is loaded and parsed,\nand the corresponding content file is `stat`ed.\n\n`shouldCleanCb` is then called as `shouldCleanCb(curFileNum, totalFiles, metadata, stat, resultCb)`\nwhere:\n\n  * curFileNum: A running count of how many files we have processed.\n  * totalFiles: The total number of files that are to be processed. (Will not change in\n                between calls to `shouldCleanCb`).\n  * metadata: The parsed metadata contained in the meta file for the current cache entry.\n  * stat: An fs.Stat object for the content file corresponding to the current meta file.\n  * resultCb: a callback which takes a single argument.\n\n`shouldCleanCb` should call `resultCb` with `'REMOVE'` to signal that the entry should be removed from the\ncache, or `'KEEP'` to indicate that the file should be kept.\n\n## Notes\n\nThe on-disk cache is structured as follows:\n\n- URLs are canonicalized and hashed via the MD5 algorithm.\n- The hex digest of the hash is split into 3 pieces: characters 0-1, characters 2-3,\n  and characters 4-31, and used to construct a pathname relative to the cache root, e.g.\n  `79/da/646f91932de1ed0267ed1abdb741`\n- The contents of the cached object are stored at that pathname. Additionally, metadata\n  about the cached object is stored at that pathname with the suffix `.meta`.\n\nA cached object is valid iff:\n\n- The `.meta` file contains a valid JSON object.\n- The expiration time stored in the .meta file under the `expiry` property has not elapsed.\n- The contents stored in the cache object file have an MD5 sum equal to that stored in the\n  `.meta` file as the `contentMD5` property.\n\nA valid cached object may always be served in response to an `openReadStream` request.\nAn invalid cached object may be deleted at any time, and in practice, will be deleted when it\nis next accessed while attempting to meet a request.\n\nFetched resources are always saved to disk regardless of expiry. This is ease integration with\nthings such as SDL functions which load images or dynamic libraries from disk.\n\nEnable debug output by setting the `DEBUG` environment variable to include `http-disk-cache`\n\n## License\n\n[MIT](https://github.com/artillery/node-http-disk-cache/blob/master/LICENSE)\n","created":"2015-10-22T23:40:29.764Z","modified":"2016-05-18T04:06:58.844Z","lastPublisher":{"name":"marktillery","email":"mark@artillery.com"},"owners":[{"name":"marktillery","email":"mark@artillery.com"},{"name":"statico","email":"ian@langworth.com"}],"other":{"_attachments":{},"_from":".","_id":"http-disk-cache","_nodeVersion":"4.2.4","_npmOperationalInternal":{"host":"packages-12-west.internal.npmjs.com","tmp":"tmp/http-disk-cache-0.7.1.tgz_1463544416367_0.7308346938807517"},"_npmUser":{"name":"marktillery","email":"mark@artillery.com"},"_npmVersion":"2.14.12","_rev":"1-bb86275ae3c1f5926659b32c550c955d","_shasum":"6923a23732fc18d773f52bbcde1ef1d2bdd862fe","author":{"name":"Mark Logan","email":"mark@artillery.com"},"bugs":{"url":"https://github.com/artillery/node-http-disk-cache/issues"},"directories":{},"dist-tags":{"latest":"0.7.1"},"dist":{"shasum":"6923a23732fc18d773f52bbcde1ef1d2bdd862fe","tarball":"http://registry.npmjs.org/http-disk-cache/-/http-disk-cache-0.7.1.tgz"},"maintainers":[{"name":"marktillery","email":"mark@artillery.com"},{"name":"statico","email":"ian@langworth.com"}],"readmeFilename":"README.md","time":{"modified":"2016-05-18T04:06:58.844Z","created":"2015-10-22T23:40:29.764Z","0.0.1":"2015-10-22T23:40:29.764Z","0.0.2":"2015-10-23T01:20:49.557Z","0.1.0":"2015-10-26T01:11:16.953Z","0.2.0":"2015-12-08T21:10:22.551Z","0.3.0":"2015-12-11T19:07:01.499Z","0.3.1":"2015-12-11T20:23:22.102Z","0.3.2":"2015-12-12T16:42:25.581Z","0.4.0":"2016-04-06T21:45:39.560Z","0.5.0":"2016-04-11T20:15:09.588Z","0.6.0":"2016-04-20T14:59:25.712Z","0.7.0":"2016-05-18T01:06:33.068Z","0.7.1":"2016-05-18T04:06:58.844Z"}}}