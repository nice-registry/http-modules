{"name":"stream-file","version":"0.2.0","description":"Buffered streaming HTTP fetch abstraction","main":"lib/stream-file.js","files":["lib/","dist/","readme.md","COPYING"],"dependencies":{},"devDependencies":{"assert":"^1.4.1","babel-preset-es2015":"^6.16.0","browserify-derequire":"^0.9.4","es6-promise":"^4.0.3","grunt":"^1.0.1","grunt-babel":"^6.0.0","grunt-browserify":"^5.0.0","grunt-contrib-compress":"^1.3.0","grunt-contrib-copy":"^1.0.0","grunt-contrib-uglify":"^2.0.0","mocha":"^3.0.2"},"scripts":{"test":"mocha","prepublish":"grunt","build":"grunt"},"repository":"https://github.com/brion/stream-file","keywords":["http","streaming","input"],"license":"MIT","homepage":"https://github.com/brion/stream-file#readme","gitHead":"3785d29f2d21551d112581666a62c5656b48694e","versions":[{"number":"0.1.0","date":"2016-10-03T03:30:24.091Z"},{"number":"0.1.1","date":"2017-01-26T20:52:11.841Z"},{"number":"0.1.2","date":"2017-01-26T22:09:53.377Z"},{"number":"0.1.3","date":"2017-03-02T04:50:05.154Z"},{"number":"0.1.4","date":"2017-03-16T08:31:10.983Z"},{"number":"0.1.5","date":"2017-03-16T09:12:42.763Z"},{"number":"0.2.0","date":"2017-04-23T09:17:05.745Z"}],"readme":"StreamFile\n==========\n\nHandy class / XHR wrapper for streaming large files from the web.\nSupports chunking and seeking within large files using the HTTP 'Range' header.\n\nCopyright 2013-2017 by Brion Vibber <brion@pobox.com>. Provided under MIT license.\n\nhttps://github.com/brion/stream-file\n\n0.2.0 - 2017-04-23\n* Added `readBytes()` method allowing copying directly into a byte array such as an emscripten heap subarray.\n* Breaking API changes:\n    * Drop `cancelToken` scheme in favor of `abort()` method.\n\n0.1.5 - 2017-03-17\n* prefer binary string over MSStream on IE 11 for now (MSStream backend does not maintain readahead buffer across boundaries)\n\n0.1.4 - 2017-03-16\n* fixes for MSStream detection on IE\n\n0.1.3 - 2017-03-01\n* fixes for stream.buffering prop with cancelToken usage\n\n0.1.2 - 2017-01-27\n* fix for end-of-file edge cases\n\n0.1.1 - 2017-01-26\n* fix for failure on very short files\n\n0.1.0 - 2016-10-02\n* initial npm release\n\ntodo:\n* add Fetch backend\n* add node CLI/server backend\n* track down some bugs with end of file and buffering\n\n# Requirements\n\nstream-file depends on the ES6 Promise class; you can use a polyfill such as [es6-promise](https://www.npmjs.com/package/es6-promise) when deploying to older browsers. A prebuilt copy of es6-promise is included in the dist directory for the browser distribution, or may be included in your application code for webpack/browserify users.\n\n# Usage\n\n## Example\n\nModule setup and constructor:\n\n```js\nvar StreamFile = require('stream-file');\n\nvar stream = new StreamFile({\n  url: 'https://upload.wikimedia.org/wikipedia/commons/9/94/Folgers.ogv',\n\n  // Optional; max size of each download chunk\n  chunkSize: 1 * 1024 * 1024,\n\n  // Optional; total amount of in-memory cache\n  cacheSize: 32 * 1024 * 1024\n});\n```\n\nES5 with Promises:\n```js\nfunction demo(stream) {\n  // load() opens up an HTTP request and gets some state info.\n  return stream.load().then(function() {\n    console.log(stream.seekable ? 'stream is seekable' : 'stream is not seekable');\n    console.log('stream length',  stream.length);\n    console.log('stream headers', stream.headers);\n\n    // seek() moves the input point to a new position, if stream is seekable\n    return stream.seek(1024);\n  }).then(function() {\n\n    // read() waits until given byte count is available (or eof) and returns buffer\n    return stream.read(65536);\n  }).then(function(buffer) {\n    console.log('read buffer with ' + buffer.byteLength + ' bytes');\n    console.log(stream.eof ? 'at eof' : 'not at eof');\n    console.log(stream.buffered); // buffered ranges\n\n    // All done!\n    stream.close();\n\n  }).catch(function(err) {\n    // Any error conditions chain through the Promises to the final catch().\n    console.log('failed', err)\n  });\n}\n```\n\nES7 async syntax:\n```js\nasync function demo(stream) {\n  try {\n    // load() opens up an HTTP request and gets some state info.\n    await stream.load();\n    console.log(stream.seekable ? 'stream is seekable' : 'stream is not seekable');\n    console.log('stream length',  stream.length);\n    console.log('stream headers', stream.headers);\n\n    // seek() moves the input point to a new position, if stream is seekable\n    await stream.seek(1024);\n\n    // read() waits until given byte count is available (or eof) and returns buffer\n    let buffer = await stream.read(65536);\n    console.log('read buffer with ' + buffer.byteLength + ' bytes');\n    console.log(stream.eof ? 'at eof' : 'not at eof');\n    console.log(stream.buffered); // buffered ranges\n\n    // All done!\n    stream.close();\n\n  } catch (err) {\n    // Any error conditions chain through the Promises to the final catch().\n    console.log('failed', err)\n  }\n}\n```\n\n## Reading asynchronously\n\nThe `read()` method waits for the requested amount of data to be available, or end-of-file to be reached, and passes back an ArrayBuffer.\n\nES5 syntax with Promises:\n```js\nfunction readAsArrayBufferAsync(stream) {\n  // Wait for eof or available byte range\n  return stream.read(1024).then(function(buffer) {\n    // ... do something with buffer ...\n    console.log('read ' + buffer.byteLength + ' bytes');\n  })\n}\n```\n\nES7 async syntax:\n```js\nasync function readAsArrayBufferAsync(stream) {\n  // Wait for eof or available byte range\n  let buffer = await stream.read(1024);\n\n  // ... do something with buffer ...\n  console.log('read ' + buffer.byteLength + ' bytes');\n}\n```\n\n## Buffering ahead\n\nTo ensure data is buffered and available without reading it yet, call `buffer()`:\n\nES5 syntax with Promises:\n```js\nfunction doBufferAsync(stream) {\n  // Wait for eof or available byte range\n  return stream.buffer(1024).then(function(nbytes) {\n    // ... do some sync stuff\n    console.log(nbytes + ' bytes ready to read');\n  });\n}\n```\n\nES7 async syntax:\n```js\nasync function doBufferAsync(stream) {\n  // Wait for eof or available byte range\n  let nbytes = await stream.buffer(1024);\n\n  // ... do some sync stuff\n  console.log(nbytes + ' bytes ready to read');\n}\n```\n\n## Reading synchronously\n\nIf you already have enough data buffered, you can work synchronously with that data by reading chunks of data with `readSync()`:\n\n```js\nfunction readAsArrayBufferSync(stream) {\n  // Wait for eof or available byte range\n  var available = stream.buffer(1024);\n\n  // May return 1024 bytes\n  var buffer = stream.readSync(available);\n  // ... do something with buffer ...\n  console.log('read ' + buffer.byteLength + ' bytes');\n}\n```\n\nIf you're going to copy the result directly into a larger byte array such as an emscripten heap or WebAssembly memory, you can avoid an intermediate copy with `readBytes()` by reading from the StreamFile's buffers directly into the target array.\n\nES5 syntax with Promises:\n\n```js\nfunction readIntoByteArray(stream) {\n  // Allocate a sub-buffer\n  var buflen = 1024;\n  var bufptr = Module._malloc(buflen);\n  var data = Module.HEAPU8.subarray(ptr, ptr + buflen);\n\n  // Copy the bytes directly into the aliased subarray...\n  var nbytes = stream.readBytes(data);\n  console.log('read ' + nbytes + ' bytes');\n\n  // Have the asm.js or wasm module process...\n  Module._process_my_data(bufptr, nbytes);\n\n  // Free the sub-buffer\n  Module._free(bufptr);\n}\n```\n\n\n## Cancellation\n\nThe `load()`, `buffer()`, `read()`, and `seek()` calls may be canceled by calling `abort()`. Further reads or seeks may then be triggered at will.\n\nNote that earlier versions used a per-call \"cancellation token\" argument, which has been dropped as of 0.2.0 since cancelable Promises have not been standardized and the use cases are actually simple enough not to need it.\n\nThis can be used to implement a timeout, or otherwise cancel something:\n\nES5 with Promises:\n```js\nfunction readWithTimeout(stream) {\n  var timeout = setTimeout(function() {\n    // Cancel read if didn't succeed within 5 seconds\n    stream.abort();\n  }, 5000);\n\n  return stream.read(65536).then(function(buffer) {\n    // Success!\n    clearTimeout(timeout);\n    doSomething(buffer);\n  }).catch(function(err) {\n    // Cancelation will trigger the error path.\n    if (err.name === 'AbortError') {\n      console.log('Timeout!');\n    } else {\n      console.log(err);\n    }\n  });\n}\n```\n\nES7 async syntax:\n```js\nasync function readWithTimeout(stream) {\n  let timeout = setTimeout(() => {\n    // Cancel read if didn't succeed within 5 seconds\n    stream.abort();\n  }, 5000);\n\n  try {\n    let buffer = await stream.read(65536);\n    // Success!\n    clearTimeout(timeout);\n    doSomething(buffer);\n  } catch(err) {\n    // Cancelation will trigger the error path.\n    if (err.name === 'AbortError') {\n      console.log('Timeout!');\n    } else {\n      console.log(err);\n    }\n  }\n}\n```\n# API\n\n## Constructor options\n\nPass the constructor an object with various properties:\n\n**url**: string (required)\n* the URL to load\n\n**chunkSize**: number\n* optional size to chunk loads in, in bytes\n* defaults to 1MB\n\n**cacheSize**: number\n* optional max size for in-memory buffer\n* defaults to 32MB\n\n## Properties\n\n**seekable**: boolean\n* is underlying stream seekable?\n\n**length**: number\n* total byte length of file/buffer, or -1 for unknown\n\n**offset**: number\n* current byte offset of reader\n\n**eof**: boolean\n* true if reading reached end of file\n\n**loaded**: boolean\n* did load() complete?\n\n**loading**: boolean\n* is load() running?\n\n**buffering**: boolean\n* is buffer() or read() running?\n\n**seeking**: boolean\n* is seek() running?\n\n## Methods\n\n**load**(): Promise\n* start loading the URL and buffering data\n* while running, `loading` will be true\n* on completion, `loaded` will be true\n\n**bytesAvailable**(max:number=Infinity): number\n* count of available buffered bytes that can be read synchronously from the current position\n* may be 0!\n* pass optional 'max' parameter to reduce search time within cache if you only care about hitting a certain number\n\n**seek**(offset): Promise\n* seek to the target offset from the beginning of the file\n* invalid if stream not seekable\n* invalid if currently loading, seeking, or buffering\n* may change `offset`, `eof` state\n\n**buffer**(nbytes:number): Promise\n* wait until at least nbytes are available in the buffer or eof\n* while running, `buffering` will be true\n\n**read**(nbytes): Promise<ArrayBuffer>\n* wait until nbytes are available or eof, read the data, then return a buffer via Promise\n* if eof is reached, will return fewer -- even 0\n\n**readSync**(nbytes): ArrayBuffer\n* read up to nbytes from buffer and return immediately\n* if less than nbytes are available due to eof or limited buffer, will return fewer -- even 0\n* may change offset, eof state\n\n**readBytes**(dest:Uint8Array): Promise&lt;number>\n* wait until up to dest.byteLength bytes are available or eof, read the data, and return the number of bytes actually read via Promise\n* if less than nbytes are available due to eof or limited buffer, will return fewer -- even 0\n* may change offset, eof state\n\n**readBytesSync**(dest:Uint8Array): number\n* read up to dest.byteLength bytes into a bytes array and return immediately\n* returns the number of bytes actually read\n* if less than nbytes are available due to eof or limited buffer, will return fewer -- even 0\n* may change offset, eof state\n\n**abort**()\n* cancel any active network operations but keep state live\n\n**close**()\n* close resources and cancel all operations\n\n# Deployment\n\n## getting the module\n\n```\nnpm install stream-file\n```\n\n## browserify and webpack\n\nThe stream-file package is meant to be used in web client code via a package bundler such as [browserify](http://browserify.org/) or [webpack](http://webpack.github.io/).\n\nAlthough compiled to ES5, a few ECMAScript 2015 features are used such as the Promise class. If you're targeting older browser versions, you will need to convert the code to ES5 and add a Promise polyfill.\n\nPre-built bundles of the StreamFile class and the es6-promise shim are available in the dist subdirectory.\n\n## node\n\nCLI/server-side node will be supported in a future release.\n\n# Backends\n\nBackend selection is automatic and cannot yet be overridden or plugged.\nThere are currently three XMLHttpRequest-based backends for in-browser usage:\n\n* 'ms-stream' for IE and Edge: reads on demand via MSStream & MSStreamReader\n* 'moz-chunked-arraybuffer' for Firefox: progressive download via ArrayBuffer chunks\n* 'binary string' for Safari, Chrome: progressive download via string chunks\n\nThe binary string backend uses more memory to buffer data.\n\nCurrently the ms-stream backend may be slightly buggier than the others.\n\n# License\n\nCopyright (c) 2013-2017 Brion Vibber and other contributors\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n","created":"2016-10-03T03:30:24.091Z","modified":"2017-04-23T09:17:05.745Z","lastPublisher":{"name":"brion","email":"brion@pobox.com"},"owners":[{"name":"brion","email":"brion@pobox.com"}],"other":{"_attachments":{},"_from":".","_id":"stream-file","_nodeVersion":"7.9.0","_npmOperationalInternal":{"host":"packages-12-west.internal.npmjs.com","tmp":"tmp/stream-file-0.2.0.tgz_1492939025442_0.963961468078196"},"_npmUser":{"name":"brion","email":"brion@pobox.com"},"_npmVersion":"4.2.0","_rev":"6-8a6346b87f3f0a083803414ebfa46c1a","_shasum":"4b9f6121150ee5aab60b8c3393e7e6d58fa9553b","author":{"name":"Brion Vibber","email":"brion@pobox.com"},"bugs":{"url":"https://github.com/brion/stream-file/issues"},"directories":{"lib":"lib","test":"test"},"dist-tags":{"latest":"0.2.0"},"dist":{"shasum":"4b9f6121150ee5aab60b8c3393e7e6d58fa9553b","tarball":"https://registry.npmjs.org/stream-file/-/stream-file-0.2.0.tgz"},"maintainers":[{"name":"brion","email":"brion@pobox.com"}],"readmeFilename":"readme.md","time":{"modified":"2017-04-23T09:17:05.745Z","created":"2016-10-03T03:30:24.091Z","0.1.0":"2016-10-03T03:30:24.091Z","0.1.1":"2017-01-26T20:52:11.841Z","0.1.2":"2017-01-26T22:09:53.377Z","0.1.3":"2017-03-02T04:50:05.154Z","0.1.4":"2017-03-16T08:31:10.983Z","0.1.5":"2017-03-16T09:12:42.763Z","0.2.0":"2017-04-23T09:17:05.745Z"}}}