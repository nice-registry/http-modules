{"name":"zipsprite","version":"1.0.2","description":"Reduce HTTP requests by packing binary assets into a zip and accessing them via Blob URLs directly from memory","main":"index.js","homepage":"https://github.com/Prinzhorn/zipsprite","repository":"https://github.com/Prinzhorn/zipsprite","scripts":{"test":"npm run lint && npm run qunit","lint":"eslint index.js test/tests.js","qunit":"browserify test/tests.js -o test/bundle.js && http-server test -o"},"keywords":["zip","sprite","performance"],"license":"MIT","devDependencies":{"http-server":"0.8.5","minimatch":"3.0.0","xhr":"2.2.0"},"dependencies":{"blob":"0.0.4","create-object-url":"1.0.2","revoke-object-url":"1.0.2"},"gitHead":"b3fafff337425b0e7cbb13c42b8f1f087fe9af53","versions":[{"number":"1.0.0","date":"2016-02-18T16:30:26.100Z"},{"number":"1.0.1","date":"2016-02-22T08:54:56.404Z"},{"number":"1.0.2","date":"2016-03-01T10:12:27.329Z"}],"readme":"ZipSprite\n=========\n\nZipSprite is currently only available as a CommonJS module to use with Browserify.\n\n`npm install zipsprite`\n\nZipSprite is a general purpose library to use uncompressed zip files as a container format in the browser. ZipSprite can be used to reduce HTTP requests whether you're creating a game, a multimedia interactive or an app.\n\nFor example if your game needs a set of asset (like five images, three audio files and nine models) ASAP before it can load you can bundle these assets into one zip and then use ZipSprite to use them like they would be separate files. This example would save 16 HTTP requests (17 assets vs 1 zip).\n\nSince the zip files are uncompressed (compression is already done by the image/audio/video format you use) ZipStream is very low on CPU usage. **It's basically just handing out pointers to memory in the form of URLs.**\n\n\nHow to use\n==========\n\nFirst you need to get the zip file into memory as `ArrayBuffer`. This is out of scope of ZipSprite, but you could for example load it via xhr with `responseType` set to `arraybuffer`. Then construct a new ZipStream instance and get a URL to the file you want!\n\n```js\nvar xhr = require('xhr');\nvar ZipSprite = require('zipsprite');\n\nvar options = {\n\turl: 'assets.zip',\n\tmethod: 'GET',\n\tresponseType: 'arraybuffer'\n};\n\nxhr(options, function(err, response, buffer) {\n\tvar sprite = new ZipSprite(buffer);\n\n\t//Get URLs to specific files inside the zip.\n\tvar boom = sprite.createURL('audio/explosion.mp3');\n\tvar wow = sprite.createURL('images/memes/doge.jpg');\n\n\t//Or get all files inside the zip.\n\t//Every file has a `name` property you can pass to createURL.\n\tvar files = sprite.getFiles();\n\n\t//Or just some of the files?\n\t//This demo uses minimatch for globbing, but your filter function can do whatever you want (e.g. regular expressions).\n\tvar wav = sprite.getFiles(minimatch('audio/*.wav'));\n});\n```\n\nCalling `createURL` multiple times for the same file returns the same URL.\n\nAfter you've used the URL (you've displayed the image, loaded the model or played the audio) release the Blob URL. This is especially important for longer sessions because you'll otherwise eat memory.\n\n```js\nsprite.revokeURL('images/mind-blown.gif');\n```\n\n\nHow to create compatible zip files\n==================================\n\nUsing different CLIs to pack all jpg files into archive.zip\n-----------------------------------------------------------\n\n```\nzip -Z store archive.zip *.jpg\n\n7z a -tzip archive.zip *.jpg -mx0\n```\n\nDynamically generate a zip and stream it to the user in node (example uses express)\n-----------------------------------------------------------------------------------\n\nUseful if you need per user ZipSprites or based on request params.\n\n```js\nvar fs = require('fs');\nvar express = require('express');\nvar archiver = require('archiver');\n\nvar app = express();\n\napp.get('/zip', function(req, res, next) {\n\tvar archive = archiver.create('zip', {\n\t\t//This is the important bit.\n\t\tstore: true\n\t});\n\n\tarchive.pipe(res);\n\n\tarchive.append(fs.createReadStream('./photo.jpg'), {\n\t\tname: 'photo.jpg',\n\t\tprefix: 'images/'\n\t});\n\n\tarchive.append(fs.createReadStream('./boom.wav'), {\n\t\tname: 'boom.wav',\n\t\tprefix: 'audio/'\n\t});\n\n\tarchive.finalize();\n});\n\napp.listen(8080);\n```\n\nOn the client you'll access the files like this\n\n```js\nimage.src = sprite.createURL('images/photo.jpg');\naudioPlayer.src = sprite.createURL('audio/boom.wav');\n```\n\n\nChangelog\n=========\n\n1.0.2\n-----\n\n* Version bump to push new README to npm\n\n1.0.1\n-----\n\n* Use `application/octet-stream` as mime type when creating the Blob. Otherwise it is served as `text/plain`. This may cause problems for binary data. Images will now correctly preview in the \"network\" tab of the dev tools.","created":"2016-02-18T16:30:26.100Z","modified":"2016-03-01T10:12:27.329Z","lastPublisher":{"name":"prinzhorn","email":"alexander@prinzhorn.it"},"owners":[{"name":"prinzhorn","email":"alexander@prinzhorn.it"}],"other":{"_attachments":{},"_from":".","_id":"zipsprite","_nodeVersion":"5.1.0","_npmOperationalInternal":{"host":"packages-9-west.internal.npmjs.com","tmp":"tmp/zipsprite-1.0.2.tgz_1456827143692_0.13185377046465874"},"_npmUser":{"name":"prinzhorn","email":"alexander@prinzhorn.it"},"_npmVersion":"3.3.12","_rev":"1-e3f27cc4f08e91bbf26c234aebebb197","_shasum":"effc736419d95e6aee84cf1fcfba6a5c2ea8b0b1","author":{"name":"Alexander Prinzhorn","email":"alexander@prinzhorn.it"},"bugs":{"url":"https://github.com/Prinzhorn/zipsprite/issues"},"directories":{},"dist-tags":{"latest":"1.0.2"},"dist":{"shasum":"effc736419d95e6aee84cf1fcfba6a5c2ea8b0b1","tarball":"http://registry.npmjs.org/zipsprite/-/zipsprite-1.0.2.tgz"},"maintainers":[{"name":"prinzhorn","email":"alexander@prinzhorn.it"}],"readmeFilename":"README.md","time":{"modified":"2016-03-01T10:12:27.329Z","created":"2016-02-18T16:30:26.100Z","1.0.0":"2016-02-18T16:30:26.100Z","1.0.1":"2016-02-22T08:54:56.404Z","1.0.2":"2016-03-01T10:12:27.329Z"}}}