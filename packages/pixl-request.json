{"name":"pixl-request","version":"1.0.14","description":"A very simple module for making HTTP requests.","homepage":"https://github.com/jhuckaby/pixl-request","license":"MIT","main":"request.js","repository":"https://github.com/jhuckaby/pixl-request","keywords":["http","request","upload","multipart"],"dependencies":{"form-data":"^2.0.0","errno":"^0.1.4 || ^1.0.0","pixl-class":"^1.0.0","pixl-xml":"^1.0.0","pixl-perf":"^1.0.0"},"devDependencies":{},"gitHead":"200e7fa71fe74e913c517169a32abc1e7997d2e2","scripts":{},"versions":[{"number":"1.0.0","date":"2015-08-08T00:43:13.995Z"},{"number":"1.0.1","date":"2015-08-08T16:03:41.403Z"},{"number":"1.0.2","date":"2015-08-08T16:19:35.598Z"},{"number":"1.0.3","date":"2015-08-16T06:45:34.522Z"},{"number":"1.0.4","date":"2015-10-09T05:50:13.389Z"},{"number":"1.0.5","date":"2016-01-23T03:44:09.136Z"},{"number":"1.0.6","date":"2016-03-18T04:09:24.640Z"},{"number":"1.0.7","date":"2016-04-01T18:49:18.731Z"},{"number":"1.0.8","date":"2016-06-10T06:38:38.459Z"},{"number":"1.0.9","date":"2016-11-05T19:32:33.283Z"},{"number":"1.0.10","date":"2016-11-07T17:15:49.234Z"},{"number":"1.0.11","date":"2016-11-19T03:44:13.472Z"},{"number":"1.0.12","date":"2017-01-05T05:58:01.953Z"},{"number":"1.0.13","date":"2017-01-15T18:14:30.072Z"},{"number":"1.0.14","date":"2017-01-27T22:01:23.327Z"}],"readme":"# Overview\n\nThis module is a very simple wrapper around Node's built-in [http](https://nodejs.org/api/http.html) library for making HTTP requests.  It provides an easy way to send an HTTP GET or POST, including things like support for HTTPS (SSL), file uploads and JSON REST style API calls.  Gzip-encoded responses are also handled automatically.\n\n# Usage\n\nUse [npm](https://www.npmjs.com/) to install the module:\n\n```\nnpm install pixl-request\n```\n\nThen use `require()` to load it in your code:\n\n```javascript\nvar PixlRequest = require('pixl-request');\n```\n\nInstantiate a request object and pass in an optional user agent string (you can also set this later via a header):\n\n```javascript\nvar request = new PixlRequest();\nvar request = new PixlRequest( \"My Custom Agent 1.0\" );\n```\n\nHere is a simple HTTP GET example:\n\n```javascript\nrequest.get( 'https://www.bitstamp.net/api/ticker/', function(err, resp, data) {\n\tif (err) console.log(\"ERROR: \" + err);\n\telse console.log(\"Success: \" + data);\n} );\n```\n\nAnd here is a simple JSON REST API request:\n\n```javascript\nrequest.json( 'http://myserver.com/api', { foo: \"test\", bar: 123 }, function(err, resp, data) {\n\tif (err) console.log(\"ERROR: \" + err);\n\telse console.log( \"JSON Response: \", data );\n} );\n```\n\n# Method List\n\nHere are all the methods available in the request library:\n\n| Method Name | Description |\n|---------------|-------------|\n| [get()](#http-get) | Performs an HTTP GET request. |\n| [post()](#http-post) | Performs an HTTP POST request. |\n| [json()](#json-rest-api) | Sends a request to a JSON REST API endpoint and parses the response. |\n| [xml()](#xml-rest-api) | Sends a request to an XML REST API endpoint and parses the response. |\n| [setHeader()](#default-headers) | Overrides or adds a default header for future requests. |\n| [setTimeout()](#handling-timeouts) | Overrides the default socket timeout (milliseconds). |\n| [setFollow()](#automatic-redirects) | Overrides the default behavior for following redirects. |\n| [setDNSCache()](#dns-caching) | Enable DNS caching and set the TTL in seconds. |\n| [flushDNSCache()](#flushing-the-cache) | Flush all IPs from the internal DNS cache. |\n\n# Request Types\n\nHere are all the request types supported by the library.\n\n## HTTP GET\n\n```\nget( URL, CALLBACK )\nget( URL, OPTIONS, CALLBACK )\n```\n\nTo perform a simple HTTP GET, call the `get()` method.  All you need to provide is the URL and a callback:\n\n```javascript\nrequest.get( 'https://www.bitstamp.net/api/ticker/', function(err, resp, data) {\n\tif (err) console.log(\"ERROR: \" + err);\n\telse {\n\t\tconsole.log(\"Status: \" + resp.statusCode + \" \" + resp.statusMessage);\n\t\tconsole.log(\"Headers: \", resp.headers);\n\t\tconsole.log(\"Content: \" + data);\n\t}\n} );\n```\n\nYour callback function is passed an error object (which will be false upon success), the HTTP response object from Node ([IncomingMessage](https://nodejs.org/api/http.html#http_http_incomingmessage)), and a data buffer of the content (if any).\n\nNote that an \"error\" in this case is something like a TCP connection failure, DNS lookup failure, socket timeout, connection aborted, or other internal client library failure.  HTTP response codes like 404 or 500 are *not* considered errors, so make sure to look at `resp.statusCode` if you are expecting an HTTP 200.\n\nTo specify additional options, such as custom request headers or HTTP authentication, include an object just before the callback:\n\n```javascript\nrequest.get( 'https://www.bitstamp.net/api/ticker/', {\n\theaders: {\n\t\t'X-Custom-Header': \"My custom value\"\t\n\t},\n\tauth: \"username:password\"\n}, \nfunction(err, resp, data) {\n\tif (err) console.log(\"ERROR: \" + err);\n\telse {\n\t\tconsole.log(\"Status: \" + resp.statusCode + \" \" + resp.statusMessage);\n\t\tconsole.log(\"Headers: \", resp.headers);\n\t\tconsole.log(\"Content: \" + data);\n\t}\n} );\n```\n\nCheck out the Node [http.request](https://nodejs.org/api/http.html#http_http_request_options_callback) documentation for all the properties you can pass in the options object.\n\nBy default, connections are closed at the end of each request.  If you want to reuse a persistent connection across multiple requests, see the [Keep-Alives](#keep-alives) section below.\n\n## HTTP POST\n\n```\npost( URL, OPTIONS, CALLBACK )\n```\n\nTo perform a HTTP POST, call the `post()` method.  Provide a URL, an options object with a `data` property containing your key/value pairs, and a callback function:\n\n```javascript\nrequest.post( 'http://myserver.com/api/post', {\n\tdata: {\n\t\tfull_name: \"Fred Smith\", \n\t\tgender: \"male\",\n\t\tage: 35\n\t}\n}, \nfunction(err, resp, data) {\n\tif (err) console.log(\"ERROR: \" + err);\n\tconsole.log(\"Status: \" + resp.statusCode + ' ' + resp.statusMessage);\n\tconsole.log(\"Headers: \", resp.headers));\n\tconsole.log(\"Content: \" + data);\n} );\n```\n\nYour key/value pairs will be serialized using the `application/x-www-form-urlencoded` format.  For a multipart post, see [Multipart POST](#multipart-post) below.\n\nYour callback function is passed an error object (which will be false upon success), the HTTP response object from Node ([IncomingMessage](https://nodejs.org/api/http.html#http_http_incomingmessage)), and a data buffer of the content (if any).\n\nNote that an \"error\" in this case is something like a TCP connection failure, DNS lookup failure, socket timeout, connection aborted, or other internal client library failure.  HTTP response codes like 404 or 500 are *not* considered errors, so make sure to look at `resp.statusCode` if you are expecting an HTTP 200.\n\nCheck out the Node [http.request](https://nodejs.org/api/http.html#http_http_request_options_callback) documentation for all the properties you can pass in the options object.\n\nBy default, connections are closed at the end of each request.  If you want to reuse a persistent connection across multiple requests, see the [Keep-Alives](#keep-alives) section below.\n\n## Multipart POST\n\nFor a `multipart/form-data` post, which is typically better for binary data, all you need to do is pass in a `multipart` property in your options object, and set it to a true value.  Everything else is the same as a standard [HTTP POST](#http-post):\n\n```javascript\nrequest.post( 'http://myserver.com/api/post', {\n\tmultipart: true, // activate multipart/form-data\n\tdata: {\n\t\tfoo: new Buffer(\"Joe was here!\"), \n\t\tbar: 54321\n\t}\n}, \nfunction(err, resp, data) {\n\tif (err) console.log(\"ERROR: \" + err);\n\tconsole.log(\"Status: \" + resp.statusCode + ' ' + resp.statusMessage);\n\tconsole.log(\"Headers: \", resp.headers));\n\tconsole.log(\"Content: \" + data);\n} );\n```\n\nNote that you can use [Buffer](https://nodejs.org/api/buffer.html) objects instead of strings for your data values.\n\n## File Uploads\n\nTo upload files, use `post()` and include a `files` object with your options, containing key/pair pairs.  Each file needs an identifier key (POST field name), and a value which should be a path to the file on disk:\n\n```javascript\nrequest.post( 'http://myserver.com/api/upload', {\n\tfiles: {\n\t\tkitten1: '/images/SillyKitten1.jpg',\n\t\tkitten2: '/images/SillyKitten2.jpg'\n\t}\n}, \nfunction(err, resp, data) {\n\tif (err) console.log(\"ERROR: \" + err);\n\telse console.log(\"Success: \" + data);\n} );\n```\n\nThe file path can also be a readable stream, if you happen to have one of those already open:\n\n```javascript\nvar stream = fs.createReadStream('/images/SillyKitten1.jpg');\n\nrequest.post( 'http://myserver.com/api/upload', {\n\tfiles: {\n\t\tfile1: stream\n\t}\n}, \nfunction(err, resp, data) {\n\tif (err) console.log(\"ERROR: \" + err);\n\telse console.log(\"Success: \" + data);\n} );\n```\n\nIf you want to customize the filename of the uploaded file, set your file value to an array, with the first element containing the file path (or a stream), and the second element the desired filename:\n\n```javascript\nfiles: {\n\tfile1: ['/images/SillyKitten1.jpg', \"A-New-Filename.JPG\"]\n}\n```\n\nYou can combine file uploads with other POST data fields, just by including a `data` property in your options, similar to a standard HTTP POST.  You can of course include any other options keys as well, such as custom headers:\n\n```javascript\nrequest.post( 'http://myserver.com/api/post', {\n\tfiles: {\n\t\tfile1: '/images/SillyKitten1.jpg'\n\t},\n\tdata: {\n\t\tfoo: new Buffer(\"Joe was here!\"), \n\t\tbar: 54321\n\t},\n\theaders: {\n\t\t'X-Custom-Header': \"My custom value\"\t\n\t}\n}, \nfunction(err, resp, data) {\n\tif (err) console.log(\"ERROR: \" + err);\n\telse console.log(\"Success: \" + data);\n} );\n```\n\nIncluding a `files` property automatically sets `multipart/form-data` mode, so you don't need to include the `multipart` boolean flag in this case.\n\n## File Downloads\n\nIf you want to download the response data to a file, instead of loading it all into an in-memory Buffer object, you can specify a `download` property in your `options` object, passed to either `get()` or `post()`.  Set this property to a filesystem path, and a file will be created and written to.  Your callback will still be fired when the download is complete, and passed the response object with access to headers, etc.  Example:\n\n```js\nrequest.get( 'https://upload.wikimedia.org/wikipedia/commons/9/9b/Gustav_chocolate.jpg', {\n\tdownload: '/var/tmp/myimage.jpg'\n}, \nfunction(err, resp) {\n\tif (err) console.log(\"ERROR: \" + err);\n\telse {\n\t\tconsole.log(\"Status: \" + resp.statusCode + \" \" + resp.statusMessage);\n\t\tconsole.log(\"Headers: \", resp.headers);\n\t}\n} );\n```\n\nYour callback will only be invoked when the file is *completely* downloaded and written to the stream.  If the response is Gzip-encoded, this is handled transparently for you using an intermediate stream.  Your file will contain the final decompressed data, and no memory will be used.\n\nAlternatively, if you already have an open stream object, you can pass that to the `download` property.  Example:\n\n```js\nvar stream = fs.createWriteStream( '/var/tmp/myimage.jpg', { flags: 'w' } );\n\nrequest.get( 'https://upload.wikimedia.org/wikipedia/commons/9/9b/Gustav_chocolate.jpg', {\n\tdownload: stream\n}, \nfunction(err, resp) {\n\tif (err) console.log(\"ERROR: \" + err);\n\telse {\n\t\tconsole.log(\"Status: \" + resp.statusCode + \" \" + resp.statusMessage);\n\t\tconsole.log(\"Headers: \", resp.headers);\n\t}\n} );\n```\n\n## Keep-Alives\n\nTo reuse the same socket connection across multiple requests, you need to use a [http.Agent](https://nodejs.org/api/http.html#http_class_http_agent) object (provided by Node).  Simply construct an instance, set the `keepAlive` property to `true`, and pass it into the options object for your requests, using the `agent` property:\n\n```javascript\nvar http = require('http');\nvar agent = new http.Agent({ keepAlive: true });\n\nrequest.get( 'http://myserver.com/api/get', {\n\tagent: agent, // custom agent for connection pooling\n\theaders: {\n\t\t'X-Custom-Header': \"My custom value\"\t\n\t}\n}, \nfunction(err, resp, data) {\n\tif (err) console.log(\"ERROR: \" + err);\n\telse console.log(\"Success: \" + data);\n} );\n```\n\nYou can then use the same `agent` object for subsequent requests on the same host (provided the server you are connecting to also supports Keep-Alives).\n\n## JSON REST API\n\n```\njson( URL, JSON, CALLBACK )\njson( URL, JSON, OPTIONS, CALLBACK )\n```\n\nThe `json()` method is designed for sending requests to JSON REST APIs.  If you want to send a JSON REST style HTTP POST to an API endpoint, and expect to receive a JSON formatted response, this wraps up all the serialization and parsing for you.  Example:\n\n```javascript\nrequest.json( 'http://myserver.com/api', { foo: \"test\", bar: 123 }, function(err, resp, data) {\n\tif (err) console.log(\"ERROR: \" + err);\n\telse console.log( \"Success: \", data );\n} );\n```\n\nThis will serialize the object into a JSON string, and send it as the HTTP POST data to the provided URL, with a Content-Type of `application/json`.  It also expects the response back from the server to be JSON, and will parse it for you.  Your callback will be passed an error (false on success), the HTTP response object ([IncomingMessage](https://nodejs.org/api/http.html#http_http_incomingmessage)), and the parsed JSON object.\n\nYou can also specify options such as custom request headers using this API.  Simply include an options object just before your callback (similar to the `get()` and `post()` methods).  Example:\n\n```javascript\nvar json = {\n\tfoo: \"test\", \n\tbar: 123\n};\n\nrequest.json( 'http://myserver.com/api', json, {\n\theaders: {\n\t\t'X-Custom-Header': \"My custom value\"\t\n\t}\n}, \nfunction(err, resp, data) {\n\tif (err) console.log(\"ERROR: \" + err);\n\telse console.log( \"Success: \", data );\n} );\n```\n\nIf you pass `null` or `false` as the JSON data argument, the request will be sent as a `GET` instead of a `POST`.\n\n**Note:** If the server doesn't send back JSON, or it cannot be parsed, an error will be sent to your callback.\n\n## XML REST API\n\n```\nxml( URL, XML, CALLBACK )\nxml( URL, XML, OPTIONS, CALLBACK )\n```\n\nThe `xml()` method is designed for sending requests to XML REST APIs.  If you want to send a XML REST style HTTP POST to an API endpoint, and expect to receive a XML formatted response, this wraps up all the serialization and parsing for you.  Example:\n\n```javascript\nrequest.xml( 'http://myserver.com/api', { foo: \"test\", bar: 123 }, function(err, resp, data) {\n\tif (err) console.log(\"ERROR: \" + err);\n\telse console.log( \"Success: \", data );\n} );\n```\n\nThis will serialize the object into an XML document (using the [pixl-xml](https://www.npmjs.com/package/pixl-xml) package), and send it as the HTTP POST data to the provided URL, with a Content-Type of `text/xml`.  It also expects the response back from the server to be XML, and will parse it for you.  Your callback will be passed an error (false on success), the HTTP response object ([IncomingMessage](https://nodejs.org/api/http.html#http_http_incomingmessage)), and the parsed XML document.\n\nYou can also specify options such as custom request headers using this API.  Simply include an options object just before your callback (similar to the `get()` and `post()` methods).  Example:\n\n```javascript\nvar xml = {\n\tfoo: \"test\", \n\tbar: 123\n};\n\nrequest.xml( 'http://myserver.com/api', xml, {\n\theaders: {\n\t\t'X-Custom-Header': \"My custom value\"\t\n\t}\n}, \nfunction(err, resp, data) {\n\tif (err) console.log(\"ERROR: \" + err);\n\telse console.log( \"Success: \", data );\n} );\n```\n\nPlease note that [pixl-xml](https://www.npmjs.com/package/pixl-xml) discards the XML root node element when parsing XML, and similarly the request library doesn't expect one when serializing.  Meaning, you should omit the XML root node element (just include the contents), and expect the server XML result to be parsed in a similar fashion.\n\nFor example, if you wanted to send this XML:\n\n```xml\n<?xml version=\"1.0\"?>\n<Document>\n\t<foo>test</foo>\n\t<bar>123</bar>\n</Document>\n```\n\nThen just include an object with `foo` and `bar` properties:\n\n```javascript\n{\n\tfoo: \"test\", \n\tbar: 123\n}\n```\n\nSee the [pixl-xml](https://www.npmjs.com/package/pixl-xml) documentation for details, including how to include attributes, etc.\n\nBy default, the XML will be serialized to a document with `<Request>` as the root node name.  However if you are posting to an API that requires a specific XML root node name, you can set it with the `xmlRootNode` property in the options object.  Example of this:\n\n```javascript\nvar xml = {\n\tfoo: \"test\", \n\tbar: 123\n};\n\nrequest.xml( 'http://myserver.com/api', xml, {\n\txmlRootNode: 'Document'\n}, \nfunction(err, resp, data) {\n\tif (err) console.log(\"ERROR: \" + err);\n\telse console.log( \"Success: \", data );\n} );\n```\n\nIf you pass `null` or `false` as the XML data argument, the request will be sent as a `GET` instead of a `POST`.\n\n**Note:** If the server doesn't send back XML, or it cannot be parsed, an error will be sent to your callback.\n\n# Default Headers\n\nBy default the request library will add the following outgoing headers to every request:\n\n```\nUser-Agent: PixlRequest 1.0.0\nAccept-Encoding: gzip, deflate\n```\n\nYou can override these by passing in custom headers with your request:\n\n```javascript\nrequest.post( 'http://myserver.com/api/post', {\n\theaders: {\n\t\t'User-Agent': \"My Request Library!\",\n\t\t'Accept-Encoding': \"none\"\n\t},\n\tdata: {\n\t\tfull_name: \"Fred Smith\", \n\t\tgender: \"male\",\n\t\tage: 35\n\t}\n}, \nfunction(err, resp, data) {\n\tif (err) console.log(\"ERROR: \" + err);\n\telse console.log(\"Success: \" + data);\n} );\n```\n\nOr by overriding your class instance defaults before making a request:\n\n```javascript\nrequest.setHeader( 'Accept-Encoding', \"none\" );\n```\n\nYou can also replace the entire header set by rewriting the `defaultHeaders` property:\n\n```javascript\nrequest.defaultHeaders = {\n\t'User-Agent': \"My Request Library!\",\n\t'Accept-Encoding': \"none\"\n};\n```\n\n# Handling Timeouts\n\nPixlRequest handles timeouts by measuring the \"time to first byte\", from the start of the request.  This is *not* an idle timeout, and *not* a connect timeout.  It is simply the maximum amount of time allowed from the start of the request, to the first byte received.  The Node.js [socket.setTimeout()](https://nodejs.org/api/net.html#net_socket_settimeout_timeout_callback) method is not used, because we have found it to be totally unreliable, especially with Keep-Alives.\n\nThe default socket timeout for all requests is 30 seconds.  You can customize this per request by including a `timeout` property with your options object, and setting it to the number of milliseconds you want:\n\n```javascript\nrequest.post( 'http://myserver.com/api/post', {\n\tdata: {\n\t\tfull_name: \"Fred Smith\", \n\t\tgender: \"male\",\n\t\tage: 35\n\t},\n\ttimeout: 10 * 1000, // 10 second timeout\n}, \nfunction(err, resp, data) {\n\tif (err) console.log(\"ERROR: \" + err);\n\telse console.log(\"Success: \" + data);\n} );\n```\n\nOr by resetting the default on your class instance, using the `setTimeout()` method:\n\n```javascript\nrequest.setTimeout( 10 * 1000 ); // 10 seconds\n```\n\nWhen a timeout occurs, an `error` event is emitted.  The error message will follow this syntax: `Socket Timeout (### ms)`.  Note that a socket timeout results in the socket being destroyed ([request.abort()](https://nodejs.org/api/http.html#http_request_abort) is called on the request object, which in turn destroys the socket).\n\n# Automatic Redirects\n\nThe default behavior for handling redirect responses (i.e. `HTTP 302` and friends) is to *not* follow them automatically, and instead return the original 3xx response for your callback to handle.  You can change this by including a `follow` property with your options object, and setting it to the maximum number of redirects you want to allow:\n\n```javascript\nrequest.post( 'http://myserver.com/api/post', {\n\tdata: {\n\t\tfull_name: \"Fred Smith\", \n\t\tgender: \"male\",\n\t\tage: 35\n\t},\n\tfollow: 2, // auto-follow up to 2 redirects\n}, \nfunction(err, resp, data) {\n\tif (err) console.log(\"ERROR: \" + err);\n\telse console.log(\"Success: \" + data);\n} );\n```\n\nAlternatively, you can set a class instance default by calling the `setFollow()` method:\n\n```javascript\nrequest.setFollow( 2 ); // auto-follow up to 2 redirects\n```\n\nIf you want to follow an unlimited number of redirects, set this to boolean `true` (not advised).  To disable the auto-follow behavior, set it to `0` or `false`.\n\nThe library recognizes HTTP codes 301, 302, 307 and 308 as \"redirect\" responses, as long as a `Location` header accompanies them.\n\n# Compressed Responses\n\nThe request library automatically handles Gzip-encoded responses that come back from the remote server.  These are transparently decoded for you.  However, you should know that by default all outgoing requests include an `Accept-Encoding: gzip, deflate` header, which broadcasts our support for it.  If you do not want responses to be compressed, you can unset this header.  See the [Default Headers](#default-headers) section above.\n\n# Performance Metrics\n\nThe request library keeps high resolution performance metrics on every HTTP request, including the DNS lookup time, socket connect time, request send time, wait time, receive time, decompress time, and total elapsed time.  These are all tracked using the [pixl-perf](https://www.npmjs.com/package/pixl-perf) module, and passed to your callback as the 4th argument.  Example:\n\n```js\nrequest.get( 'https://www.bitstamp.net/api/ticker/', function(err, resp, data, perf) {\n\tif (err) console.log(\"ERROR: \" + err);\n\telse {\n\t\tconsole.log(\"Status: \" + resp.statusCode + \" \" + resp.statusMessage);\n\t\tconsole.log(\"Performance: \", perf.metrics());\n\t}\n} );\n```\n\nThis would output something like the following:\n\n```\nStatus: 200 OK\nPerformance: {\n  scale: 1000,\n  perf: { \n     total: 315.508,\n     dns: 100.068,\n     connect: 42.597,\n     send: 118.563,\n     wait: 45.585,\n     receive: 3.017,\n     decompress: 3.929 \n   }\n}\n```\n\nAll the `perf` values are in milliseconds (represented by the `scale`).  Here are descriptions of all the metrics:\n\n| Metric | Description |\n|--------|-------------|\n| `dns` | Time to resolve the hostname to an IP address via DNS.  Omitted if cached, or you specify an IP on the URL. |\n| `connect` | Time to connect to the remote socket (omitted if using Keep-Alives and reusing a host). |\n| `send` | Time to send the request data (typically for POST / PUT).  Also includes SSL handshake time (if HTTPS). |\n| `wait` | Time spent waiting for the server response (after request is sent). |\n| `receive` | Time spent downloading data from the server (after headers received). |\n| `decompress` | Time taken to decompress the response (if encoded with Gzip or Deflate). |\n| `total` | Total time of the entire HTTP transaction. |\n\nAs indicated above, some of the properties may be omitted depending on the situation.  For example, if you are using a shared [http.Agent](https://nodejs.org/api/http.html#http_class_http_agent) with Keep-Alives, then subsequent requests to the same host won't perform a DNS lookup or socket connect, so those two metrics will be omitted.  Similarly, if the response from the server isn't compressed, then the `decompress` metric will be omitted.\n\nNote that the `send` metric includes the SSL / TLS handshake time, if using HTTPS.  Also, this metric may be `0` if using plain HTTP GET or HEAD, as it is mainly used to measure the POST or PUT data send time (i.e. uploading file data).\n\nSee the [pixl-perf](https://www.npmjs.com/package/pixl-perf) module for more details.\n\n# DNS Caching\n\nYou can optionally have the library cache DNS lookups in RAM, for faster subsequent requests on the same hostnames.  You can also specify the TTL (time to live) to control how long hostnames will be cached.  This means it will only request a DNS lookup for a given hostname once every N seconds.  To enable this feature, call `setDNSCache()` and specify the number of seconds for the TTL:\n\n```js\nrequest.setDNSCache( 300 ); // 5 minute TTL\n```\n\nThis will cache hostnames and their IP addresses in RAM for 5 minutes.  Meaning, during that time subsequent requests to the same hostname will not require a DNS lookup.  After 5 minutes, the cache objects will expire, and the next request will perform another DNS lookup.\n\nNote that while the feature can be enabled or disabled per request object, the DNS cache itself is global.  Meaning, it is shared by all `pixl-request` objects in the same process.\n\n## Flushing the Cache\n\nTo flush the DNS cache (i.e. eject all the IPs from it), call the `flushDNSCache()` method.  Example:\n\n```js\nrequest.flushDNSCache();\n```\n\n# SSL Certificate Validation\n\nIf you are trying to connect to a host via HTTPS and getting certificate errors, you may have to bypass Node's SSL certification validation.  To do this, set the following environment variable before you make your HTTPS request:\n\n```js\nprocess.env.NODE_TLS_REJECT_UNAUTHORIZED = \"0\";\n```\n\nPlease only do this if you understand the security ramifications, and *completely trust* the host you are connecting to, and the network you are on.  Skipping the certificate validation step should really only be done in special circumstances, such as testing your own internal server with a self-signed cert.\n\n# License\n\nThe MIT License\n\nCopyright (c) 2015 - 2016 Joseph Huckaby.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n","starsCount":1,"created":"2015-08-08T00:43:13.995Z","modified":"2017-01-27T22:01:23.327Z","lastPublisher":{"name":"jhuckaby","email":"jhuckaby@gmail.com"},"owners":[{"name":"jhuckaby","email":"jhuckaby@gmail.com"}],"other":{"_attachments":{},"_from":".","_id":"pixl-request","_nodeVersion":"6.9.1","_npmOperationalInternal":{"host":"packages-12-west.internal.npmjs.com","tmp":"tmp/pixl-request-1.0.14.tgz_1485554483093_0.4329064032062888"},"_npmUser":{"name":"jhuckaby","email":"jhuckaby@gmail.com"},"_npmVersion":"3.10.8","_rev":"7-dd4514ac436fa8dea680dd662f4dce7f","_shasum":"49f73f01b3ab8a984444f8021bbbf04b6aba7a5a","author":{"name":"Joseph Huckaby","email":"jhuckaby@gmail.com"},"bugs":{"url":"https://github.com/jhuckaby/pixl-request/issues"},"directories":{},"dist-tags":{"latest":"1.0.14"},"dist":{"shasum":"49f73f01b3ab8a984444f8021bbbf04b6aba7a5a","tarball":"https://registry.npmjs.org/pixl-request/-/pixl-request-1.0.14.tgz"},"maintainers":[{"name":"jhuckaby","email":"jhuckaby@gmail.com"}],"readmeFilename":"README.md","time":{"modified":"2017-01-27T22:01:23.327Z","created":"2015-08-08T00:43:13.995Z","1.0.0":"2015-08-08T00:43:13.995Z","1.0.1":"2015-08-08T16:03:41.403Z","1.0.2":"2015-08-08T16:19:35.598Z","1.0.3":"2015-08-16T06:45:34.522Z","1.0.4":"2015-10-09T05:50:13.389Z","1.0.5":"2016-01-23T03:44:09.136Z","1.0.6":"2016-03-18T04:09:24.640Z","1.0.7":"2016-04-01T18:49:18.731Z","1.0.8":"2016-06-10T06:38:38.459Z","1.0.9":"2016-11-05T19:32:33.283Z","1.0.10":"2016-11-07T17:15:49.234Z","1.0.11":"2016-11-19T03:44:13.472Z","1.0.12":"2017-01-05T05:58:01.953Z","1.0.13":"2017-01-15T18:14:30.072Z","1.0.14":"2017-01-27T22:01:23.327Z"},"users":{"rdominy":true}}}