{"name":"routes-http","version":"0.5.0","description":"Simple but powerful HTTP request router","licenses":{"type":"UNLICENSE","url":"https://github.com/pluma/routes-http/blob/master/UNLICENSE"},"repository":"https://github.com/pluma/routes-http","keywords":["route","routes","router","routing","request","url","http"],"dependencies":{"routes":"~0.2","httperr":"~0.4"},"devDependencies":{"mocha":"~1.17","istanbul":"~0.2","coveralls":"~2.6","expect.js":"~0.2","jshint":"~2.4"},"main":"index.js","scripts":{"coveralls":"make coveralls","test":"make test"},"engines":{"node":">=0.6"},"versions":[{"number":"0.1.0","date":"2013-12-30T17:40:38.795Z"},{"number":"0.2.0","date":"2014-01-16T20:41:22.369Z"},{"number":"0.3.0","date":"2014-01-23T00:10:11.729Z"},{"number":"0.4.0","date":"2014-01-25T00:53:26.565Z"},{"number":"0.4.1","date":"2014-03-08T14:30:05.951Z"},{"number":"0.4.2","date":"2014-03-08T14:52:51.438Z"},{"number":"0.5.0","date":"2014-03-08T15:05:42.090Z"}],"readme":"# Synopsis\n\n**routes-http** is a simple HTTP request router for node.js based on [routes](https://github.com/aaronblohowiak/routes.js).\n\n[![stability 2 - unstable](http://b.repl.ca/v1/stability-2_--_unstable-yellow.png)\n](http://nodejs.org/api/documentation.html#documentation_stability_index) [![license - Unlicense](http://b.repl.ca/v1/license-Unlicense-lightgrey.png)](http://unlicense.org/)\n\n[![Build Status](https://travis-ci.org/pluma/routes-http.png?branch=master)](https://travis-ci.org/pluma/routes-http) [![Coverage Status](https://coveralls.io/repos/pluma/routes-http/badge.png?branch=master)](https://coveralls.io/r/pluma/routes-http?branch=master) [![Dependencies](https://david-dm.org/pluma/routes-http.png?theme=shields.io)](https://david-dm.org/pluma/routes-http)\n\n[![NPM status](https://nodei.co/npm/routes-http.png?compact=true)](https://npmjs.org/package/routes-http)\n\n# Features\n\n## Simple but powerful\n\n*routes-http* is just a thin wrapper around *routes*. This means if you've used *routes* or routes-based routers before, you can start using *routes-http* right away:\n\n```javascript\nvar routes = require('routes-http')();\nroutes.addRoute('/foo/:arg/*', function(req, res, opts) {\n    console.log(opts);\n});\n// … more code …\nreq.url = '/foo/bar/qux/baz';\nroutes(req, res);\n/*\n{\n    params: {arg: 'bar'},\n    splats: ['qux/baz']\n}\n*/\n```\n\n## Chaining API\n\nYou can create a router and add all your routes in a single line. No more repeating yourself! The following is perfectly valid:\n\n```javascript\nvar routes = require('routes-http')()\n    .addRoute('/foo', function(req, res) {/* … */})\n    .addRoute('/bar', function(req, res) {/* … */})\n    .addRoute('/qux', function(req, res) {/* … */});\n// … more code …\nroutes(req, res);\n```\n\nOr simply:\n\n```javascript\nvar routes = require('routes-http')().addRoutes({\n    '/foo': function(req, res) {/* … */},\n    '/bar': function(req, res) {/* … */},\n    '/qux': function(req, res) {/* … */}\n});\n```\n\n## Semantic error-handling\n\n*routes-http* uses [httperr](https://github.com/pluma/httperr) for its own errors and allows you to provide an error handler that will be used for all errors, including matching errors:\n\n```javascript\nvar routes = require('routes-http')();\nroutes.addRoute('/foo', function(req, res) {/* … */});\n// … more code …\nreq.url = 'http://localhost/foo';\nroutes(req, res, function(err) {\n    console.error(err);\n});\n/*\n{ [NotFound]\n    title: 'Not Found',\n    name: 'NotFound',\n    code: 'NOT_FOUND',\n    statusCode: 404\n}\n*/\n```\n\n## Pain-free nesting\n\nWant to use a separate router for each namespace of your app? No problem. Nesting routes is as simple as defining normal routes. They don't even need to know about each other or that they are nested in order to work:\n\n```javascript\nvar router = require('routes-http'),\n    routes = router(),\n    childRoutes = router();\n\nroutes.addRoute('/hello/', childRoutes); // Always use a trailing slash!\nchildRoutes.addRoute('/world', function(req, res) {\n    res.end('Hello from /hello/world !');\n});\n```\n\n## HTTP method dispatching\n\nWant to have different views for each HTTP method? Just specify an object instead of a function:\n\n```javascript\nvar routes = require('routes-http')();\nroutes.addRoute('/foo', {\n    GET: function(req, res) {res.end('You used GET');},\n    POST: function(req, res) {res.end('You used POST')}\n});\n\n/* … more code … */\n\nroutes(req, res, function(err) {\n    if (err.statusCode === 405) {\n        res.writeHead(err.statusCode, err.title, {'Allow': err.allowed.join(', ')});\n        res.write('You used ' + req.method + '\\n');\n        res.write('Allowed methods: ' + err.allowed.join(', ') + '\\n');\n    } else {\n        res.writeHead(err.statusCode, err.title);\n    }\n    res.end(err.statusCode + ' ' + err.title);\n});\n```\n\n```sh\n$ curl http://localhost:8000/foo\nYou used GET\n$ curl -X POST http://localhost:8000/foo\nYou used POST\n$ curl -X DELETE http://localhost:8000/foo\nYou used DELETE\nAllowed methods: GET, POST\n405 Method Not Allowed\n```\n\n## Minimalistic requirements\n\nWant to use the router without passing in request and response objects? You can do that.\n\n```javascript\nvar routes = require('routes-http')();\nroutes.addRoute('/foo', function() {/* … */});\nroutes({url: 'http://localhost/foo'}); // Works!\nroutes('/foo'); // Also works!\n```\n\n```javascript\nvar routes = require('routes-http')();\nroutes.addRoute('/foo', function(url, data) {/* … */});\nroutes('/foo', {proprietary: 'data-structure'}); // Works!\n```\n\n# Basic Usage Example\n\n```javascript\nvar router = require('routes-http'),\n    http = require('http'),\n    routes = router();\n\nroutes.addRoute('/hello/world', function(req, res) {\n    res.end('Hello world!');\n});\nroutes.addRoute('/throws', function(req, res) {\n    throw new Error();\n});\n\nhttp.createServer(function(req, res) {\n    routes(req, res, function(err) {\n        if (err.statusCode && err.title) {\n            res.writeHead(err.statusCode, err.title);\n            res.end(err.statusCode + ' ' + err.title);\n        } else {\n            res.writeHead(500, 'Internal Server Error');\n            res.end('An error occurred');\n        }\n    });\n}).listen(8000);\n```\n\n```sh\n$ curl http://localhost:8000/hello/world\nHello World!\n$ curl http://localhost:8000/does/not/exist\n404 Not Found\n$ curl Http://localhost:8000/throws\nAn error occurred\n```\n\n# Install\n\n## With NPM\n\n```sh\nnpm install routes-http\n```\n\n## From source\n\n```sh\ngit clone https://github.com/pluma/routes-http.git\ncd routes-http\nnpm install\nmake test\n```\n\n# API\n\n## routes(req, [res], [handleError:Function])\n\nResolves the given request and invokes the matching view if possible.\n\nIf the route can not be resolved, a `404 Not Found` error will be raised.\n\nIf a `handleError` function is passed, the function will be called with the `Error` object if an error is thrown by the view or the route resolution fails.\n\nThe matched view will be invoked with the following arguments:\n\n### req\n\nThe original request.\n\n### res\n\nThe original response.\n\n### opts\n\nAn object with two properties:\n\n#### opts.params\n\nAn object containing the matched route params. For child routes, the object will contain params matched by their parent routes as well, but child routes will take precedence over parent routes when params are named identically.\n\nExample:\n\n```javascript\nchildRoutes.addRoute('/:foo', function(req, res, opts) {/* … */});\nroutes.addRoute('/:foo/', childRoutes);\nroutes({url: '/qux/bar'}); // opts.params = {'foo': 'bar'}\n```\n\n#### opts.splats\n\nAn array containing the matched route splats. For child routes, the array will contain splats matched by their parent routes as well, with child routes' splats appearing at the end of the array.\n\nExample:\n\n```javascript\nchildRoutes.addRoute('/*', function(req, res, opts) {/* … */});\nroutes.addRoute('/*/foo/', childRoutes);\nroutes({url: '/qux/foo/bar'}); // opts.splats = ['qux', 'bar']\n```\n\n## routes.addRoutes({path: view})\n\nInvokes `routes.addRoute` for each key/value pair.\n\nNote that because JavaScript object key order can not be guaranteed this is not recommended if you have paths that depend on the resolution order.\n\nExample:\n\nThe following may produce inconsistent results:\n\n```javascript\nroutes.addRoutes({\n    '/:foo/': function(req, res, opts) {/* … */},\n    '/:bar/': function(req, res, opts) {/* … */}\n});\n```\n\n## routes.addRoutes([[path:String, view]])\n\nInvokes `routes.addRoute` for each pair of `path` and `view` in the given array.\n\n## routes.addRoute(path:String, view:Function)\n\nAdds a route with the given path. The route will resolve to the given function, invoking it when the route is matched.\n\n## routes.addRoute(path:String, view:Object)\n\nAdds a route with the given path. The object is expected to have methods named after the HTTP methods supported by the view that will be invoked when the route is matched with the respective HTTP method.\n\nIf the route is resolved, but the view object has no matching property for the request's HTTP method, a `405 Method Not Allowed` error will be raised with an array containing the names of the supported HTTP methods as its `allowed` property.\n\nExample:\n\n```javascript\nroutes.addRoute('/foo/bar', {\n    GET: function(req, res) { // Always use uppercase!\n        res.end('You have sent a GET request.');\n    },\n    POST: function(req, res) {\n        res.end('You have sent a POST request');\n    }\n});\n```\n\n## routes.addRoute(path:String, view:routes)\n\nAdds a route with the given path prefix. When the route is matched, the prefix will be replaced by a slash and the resulting URL will be passed to the given routes function.\n\nExample:\n\n```javascript\nchildRoutes.addRoute('/bar', function(req, res) {\n    res.end('You have accessed /foo/bar !');\n});\nchildRoutes.addRoute('/', function(req, res) {\n    res.end('You have accessed /foo/ !');\n});\nroutes.addRoute('/foo/', childRoutes); // Always use a trailing slash!\n```\n\n# Unlicense\n\nThis is free and unencumbered public domain software. For more information, see http://unlicense.org/ or the accompanying [UNLICENSE](https://github.com/pluma/routes-http/blob/master/UNLICENSE) file.\n","created":"2013-12-30T17:40:35.472Z","modified":"2014-03-08T15:05:42.090Z","lastPublisher":{"name":"pluma","email":"me@pluma.io"},"owners":[{"name":"pluma","email":"me@pluma.io"}],"other":{"_attachments":{},"_from":".","_id":"routes-http","_npmUser":{"name":"pluma","email":"me@pluma.io"},"_npmVersion":"1.2.18","_rev":"1-2cd2a64aaeb2e6bbd4bfda94c6247cf9","author":{"name":"Alan Plum","email":"me@pluma.io"},"directories":{},"dist-tags":{"latest":"0.5.0"},"dist":{"shasum":"7c1a52bdfe6b801dc0b4afafdfe7ec93cae4b56f","tarball":"http://registry.npmjs.org/routes-http/-/routes-http-0.5.0.tgz"},"maintainers":[{"name":"pluma","email":"me@pluma.io"}],"readmeFilename":"README.md","time":{"modified":"2014-03-08T15:05:42.090Z","created":"2013-12-30T17:40:35.472Z","0.1.0":"2013-12-30T17:40:38.795Z","0.2.0":"2014-01-16T20:41:22.369Z","0.3.0":"2014-01-23T00:10:11.729Z","0.4.0":"2014-01-25T00:53:26.565Z","0.4.1":"2014-03-08T14:30:05.951Z","0.4.2":"2014-03-08T14:52:51.438Z","0.5.0":"2014-03-08T15:05:42.090Z"}}}