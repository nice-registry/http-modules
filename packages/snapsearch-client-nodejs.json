{"name":"snapsearch-client-nodejs","version":"1.1.6","description":"NodeJS HTTP Client Middleware Libraries for SnapSearch. Search engine optimisation for single page applications.","repository":"https://github.com/SnapSearch/SnapSearch-Client-Node","main":"index.js","scripts":{"prepublish":"npm prune","test":"make test"},"keywords":["seo","search","engine","optimisation","javascript","ajax","angular","ember","knockout","backbone","extjs","dojo"],"license":"MIT","dependencies":{"request":"~2.33.0"},"devDependencies":{"mocha":"~1.17.1","chai":"~1.9.0","express":"~3.4.8","supertest":"~0.9.0"},"engines":{"node":">= 0.8.0"},"homepage":"https://github.com/SnapSearch/SnapSearch-Client-Node","versions":[{"number":"0.0.1","date":"2014-02-09T14:06:18.016Z"},{"number":"0.0.2","date":"2014-03-11T05:06:12.789Z"},{"number":"1.0.0","date":"2014-04-25T16:11:07.763Z"},{"number":"1.1.0","date":"2015-04-19T11:58:22.361Z"},{"number":"1.1.1","date":"2015-04-20T12:01:37.617Z"},{"number":"1.1.2","date":"2015-04-25T09:16:17.225Z"},{"number":"1.1.3","date":"2015-04-26T03:48:57.409Z"},{"number":"1.1.4","date":"2015-04-26T06:27:26.380Z"},{"number":"1.1.5","date":"2015-04-26T06:31:17.438Z"},{"number":"1.1.6","date":"2015-06-02T11:40:41.795Z"}],"readme":"SnapSearch-Client-Node\n======================\n\n[![Build Status](https://travis-ci.org/SnapSearch/SnapSearch-Client-Node.png?branch=master)](https://travis-ci.org/SnapSearch/SnapSearch-Client-Node)\n\nSnapsearch Client Node is Node.js based framework agnostic HTTP client library for SnapSearch (https://snapsearch.io/).\n\nSnapsearch is a search engine optimisation (SEO) and robot proxy for complex front-end javascript & AJAX enabled (potentially realtime) HTML5 web applications.\n\nSearch engines like Google's crawler and dumb HTTP clients such as Facebook's image extraction robot cannot execute complex javascript applications. Complex javascript applications include websites that utilise AngularJS, EmberJS, KnockoutJS, Dojo, Backbone.js, Ext.js, jQuery, JavascriptMVC, Meteor, SailsJS, Derby, RequireJS and much more. Basically any website that utilises javascript in order to bring in content and resources asynchronously after the page has been loaded, or utilises javascript to manipulate the page's content while the user is viewing them such as animation.\n\nSnapsearch intercepts any requests made by search engines or robots and sends its own javascript enabled robot to extract your page's content and creates a cached snapshot. This snapshot is then passed through your own web application back to the search engine, robot or browser.\n\nSnapsearch's robot is an automated load balanced Firefox browser. This Firefox browser is kept up to date with the nightly versions, so we'll always be able to serve the latest in HTML5 technology. Our load balancer ensures your requests won't be hampered by other user's requests.\n\nFor more details on how this works and the benefits of usage see https://snapsearch.io/\n\nSnapSearch provides similar libraries in other languages: https://github.com/SnapSearch/Snapsearch-Clients\n\nInstallation\n------------\n\nInstall it from NPM.\n\n```\nnpm install snapsearch-client-nodejs --save\n```\n\nUsage\n-----\n\nSnapSearch's NodeJS client is broken up into 3 basic classes, Client, Detector and Interceptor. All it needs is a request object extended from NodeJS's `http.IncomingMessage` prototype. This allows you to use it any NodeJS framework. However we have bundled a connect compatible middleware for ease of use. This middleware should be used at the entry/bootstrap point of your NodeJS application. There are more examples are in the examples folder.\n\nThe order of middleware setup in Express **is** important. For most cases, you should place the SnapSearch middleware as closest to the kernel of your application as possible. This means placing the SnapSearch middleware setup lower in the sequence of `app.use` expressions. Any middleware augmenting the request and response that should be running when a normal user is accessing the site, should probably also run when SnapSearch is intercepting. Any middleware placed after SnapSearch will not run during an interception.\n\nFor full documentation on the API and API request parameters see: https://snapsearch.io/documentation\n\n**By the way, you need to blacklist non-html resources such as `sitemap.xml`. This is explained in https://snapsearch.io/documentation#notes**\n\n### Basic Connect/Express Usage\n\n```javascript\nvar express = require('express');\nvar snapsearch = require('snapsearch-client-nodejs');\n\nvar app = express();\n\n//by default the it will only intercept and return a response with only status, header location, and html body\napp.use(snapsearch.connect(\n    new snapsearch.Interceptor(\n        new snapsearch.Client('ENTER YOUR EMAIL', 'ENTER YOUR KEY', {}, function (error, debugging) {\n                //mandatory custom exception handler for Client errors such as HTTP errors or validation errors from the API\n                console.log(error); \n                // error is a SnapSearchException containing a message and errorDetails which can acquired from `getMessage()` `getErrors()`\n                console.log(debugging); \n                // debugging is an object containing these: {apiUrl, apiKey, apiEmail, requestParameters}\n                // if an exception happens, the middleware is a no-op and passes through to the next stage of your application\n        }),\n        new snapsearch.Detector()\n    )\n);\n\napp.get('/', function (request, response) {\n    response.send('Was not a robot and we are here inside app');\n});\n\napp.listen(1337);\n```\n\nHere's an example response coming back from SnapSearch's API (not all variables are available, you need to check your request parameters):\n\n```javascript\n{\n    \"code\": \"success\",\n    \"content\": {\n        \"cache\"             => true/false,\n        \"callbackResult\"    => \"\",\n        \"date\"              => 1390382314,\n        \"headers\"           => [\n            {\n                \"name\"  => \"Content-Type\",\n                \"value\" => \"text/html\"\n            }\n        ],\n        \"html\"              => \"<html></html>\",\n        \"message\"           => \"Success/Failed/Validation Errors\",\n        \"pageErrors\"        => [\n            {\n                \"error\"   => \"Error: document.querySelector(...) is null\",\n                \"trace\"   => [\n                    {\n                        \"file\"      => \"filename\",\n                        \"function\"  => \"anonymous\",\n                        \"line\"      => \"41\",\n                        \"sourceURL\" => \"urltofile\"\n                    }\n                ]\n            }\n        ],\n        \"screenshot\"         => \"BASE64 ENCODED IMAGE CONTENT\",\n        \"status\"            => 200\n    }\n}\n```\n\n### Advanced Connect/Express Usage\n\n```javascript\nvar express = require('express');\nvar snapsearch = require('snapsearch-client-nodejs');\n\nvar app = express();\n\napp.use(snapsearch.connect(\n    new snapsearch.Interceptor(\n        new snapsearch.Client('ENTER YOUR EMAIL', 'ENTER YOUR KEY', {}, function (error, debugging) {\n                //mandatory custom exception handler for Client errors such as HTTP errors or validation errors from the API\n                //exceptions will only be called in the event that SnapSearchClient could not contact the API or when there are validation errors\n                //in production you'll just ignore these errors, but log them here, the middleware is a no-op and will just pass through, and will not halt your application\n                console.log(error);\n                console.log(debugging);\n        }),\n        new snapsearch.Detector()\n    ),\n    function (data) {\n        \n        //optional customised response callback\n        //if intercepted, this allows you to specify what kind of status, headers and html body to return\n        //remember headers is in the format of [ { name: '', value: '' },... ]\n        \n        // unless you know what you're doing, the location header is most likely sufficient\n        // if you are setting up gzip compression, see the heroku example https://github.com/SnapSearch/SnapSearch-Client-Node-Heroku-Demo\n        var newHeaders = [];\n        data.headers.forEach(function (header) {\n            if (header.name.toLowerCase() === 'location') {\n                newHeaders.push({name: header.name, value: header.value});\n            }\n        });\n\n        return {\n            status: data.status,\n            headers: newHeaders,\n            html: data.html\n        };\n\n    }\n);\n\napp.get('/', function (request, response) {\n    response.send('Was not a robot and we are here inside app');\n});\n\napp.listen(1337);\n```\n\n### Advanced Usage\n\nThe below shows how you can manipulate the properties and parameters of the client, detector and interceptor. The example shows them being applied on a simple HTTP server, however the principle is the same with Express/Connect integrations.\n\n```javascript\nvar http = require('http');\nvar snapsearch = require('snapsearch-client-nodejs');\n\nvar apiRequestParameters = {\n    //add your API request parameters if you have any...\n};\n\nvar blackListedRoutes = [\n    //add your black listed routes in regex if you have any...\n    //for example: '^/sitemap.xml'\n];\n\nvar whiteListedRoutes = [\n    //add your white listed routes in regex if you have any...\n];\n\nvar checkFileExtensions = false; //if you wish for SnapSearch Client to check if the URL leads to a static file, switch this on to a boolean true, however this is expensive and time consuming, so it's better to use black listed or white listed routes\n\nvar trustedProxy = false; //if you are behind a reverse proxy, switch this to true so we can acquire the real protocol from X-Forwarded-Proto header\n\nvar pathToCustomRobotsJson = ''; //custom robots json path\n\nvar pathToCustomExtensionsJson = ''; //custom extensions json path\n\nvar client = new snapsearch.Client(\n    'ENTER YOUR EMAIL', \n    'ENTER YOUR KEY',\n    apiRequestParameters,\n    function (error, debugging) {\n        // mandatory\n        console.log(error);\n        console.log(debugging);\n    }\n);\n\nvar detector = new snapsearch.Detector(\n    blackListedRoutes,\n    whiteListedRoutes,\n    checkFileExtensions,\n    trustedProxy,\n    pathToCustomRobotsJson,\n    pathToCustomExtensionsJson\n);\n\nvar interceptor = new snapsearch.Interceptor(client, detector);\n\n//robots can be direct accessed and manipulated\ndetector.robots.ignore.push('Adsbot-Google');\ndetector.robots.match.push('SomeBotIWantToMatch');\n\n//extensions can as well, add to 'generic' or 'js'\ndetector.extensions.generic.push('valid generic extension');\ndetector.extensions.js = ['valid js extension']; //there is currently no js extensions\n\n//the beforeIntercept callback is called after the Detector has detected a search engine robot\n//if this callback returns an object, the object will be used as the response to interceptor.intercept\n//use it for client side caching in order to have millisecond responses to search engines\n//the afterIntercept callback can be used to store the snapshot from SnapSearch as a client side cached resource\n//this is of course optional as SnapSearch caches your snapshot as well!\nclientCache = require('hypothetical-client-cache-object');\ninterceptor.beforeIntercept(function (url) {\n    return clientCache.get(url);\n}).afterIntercept(function (url, data) {\n    clientCache.put(url, data);    \n});\n\nhttp.createServer(function (request, response) {\n    try {\n        // call interceptor\n        interceptor.intercept(request, function (data) {\n            // if we get data back it was a bot and we have a snapshot back from SnapSearch\n            if (data) {\n                if (data.headers) {\n                    data.headers.forEach(function (header) {\n                        if (header.name.toLowerCase() === 'location') {\n                            response.setHeader('Location', header.value);\n                        }\n                    });\n                }\n                response.statusCode = data.status;\n                response.end(data.html);\n            } else {\n                // Proceed with the rest of the application...\n            }\n        });\n    } catch (error) {}\n}).listen(1337, '127.0.0.1');\n```\n\nThat's pretty much it. Check the source code for more, it's tiny and well documented.\n\nReverse Proxies\n---------------\n\nIf you are behind a reverse proxy such as NGINX, Apache or certain PAAS providers (Heroku), certain HTTP information between the client and the proxy needs to be explicitly passed by the proxy to the backend, this includes the HTTP protocol and hostname. This information is usually passed in `X-Forwarded-Proto` & `X-Forwarded-Host` headers. Because these headers can be forged, by default we do not automatically trust these headers. But if you control the proxy, and you trust these headers, then you need to switch true the `trustedProxy` boolean flag in the `Detector` function constructor. You may call it like: \n\n```js\nvar trustedProxy = true;\n\nvar detector = new snapsearch.Detector(\n    [],\n    [],\n    false,\n    trustedProxy\n);\n```\n\nIf you use Express, you may also need to enable `app.enable('trust proxy');`. See http://expressjs.com/guide/behind-proxies.html\n\nWe have a demo of a working [SnapSearch enabled express application running on Heroku](https://github.com/SnapSearch/SnapSearch-Client-Node-Heroku-Demo).\n\nDevelopment\n-----------\n\nInstall/update all dependencies:\n\n```\nnpm install\n```\n\nMake your changes. Then use this to create a version in the package.json, ti also creates a new git tag.\n\n```\nnpm version [<newversion> | major | minor | patch] -m \"New release\"\n```\n\nSynchronise and push the tag with:\n\n```\ngit push\ngit push --tags\n```\n\nPush the version to NPM:\n\n```\nnpm publish\n```\n\nTests\n----\n\nUnit tests are written using Mocha and Chai. To run tests use `npm test`.\n\nTo run tests in Windows use `./node_modules/.bin/mocha --reporter spec`.\n","starsCount":0,"created":"2014-02-09T14:06:16.619Z","modified":"2015-06-02T11:40:41.795Z","lastPublisher":{"name":"cmcdragonkai","email":"roger.qiu@polycademy.com"},"owners":[{"name":"cmcdragonkai","email":"roger.qiu@polycademy.com"}],"other":{"_attachments":{},"_from":".","_id":"snapsearch-client-nodejs","_npmUser":{"name":"cmcdragonkai","email":"roger.qiu@polycademy.com"},"_npmVersion":"1.4.9","_rev":"1-c023ae862f80552bf84c6d47fac35cb3","_shasum":"3eb28d77ac41de5080a1ed533064275a455506cc","author":{"name":"Jiby Jose"},"bugs":{"url":"https://github.com/SnapSearch/SnapSearch-Client-Node/issues"},"directories":{},"dist-tags":{"latest":"1.1.6"},"dist":{"shasum":"3eb28d77ac41de5080a1ed533064275a455506cc","tarball":"http://registry.npmjs.org/snapsearch-client-nodejs/-/snapsearch-client-nodejs-1.1.6.tgz"},"maintainers":[{"name":"cmcdragonkai","email":"roger.qiu@polycademy.com"}],"readmeFilename":"README.md","time":{"modified":"2015-06-02T11:40:41.795Z","created":"2014-02-09T14:06:16.619Z","0.0.1":"2014-02-09T14:06:18.016Z","0.0.2":"2014-03-11T05:06:12.789Z","1.0.0":"2014-04-25T16:11:07.763Z","1.1.0":"2015-04-19T11:58:22.361Z","1.1.1":"2015-04-20T12:01:37.617Z","1.1.2":"2015-04-25T09:16:17.225Z","1.1.3":"2015-04-26T03:48:57.409Z","1.1.4":"2015-04-26T06:27:26.380Z","1.1.5":"2015-04-26T06:31:17.438Z","1.1.6":"2015-06-02T11:40:41.795Z"},"users":{}}}