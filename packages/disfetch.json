{"name":"disfetch","version":"0.2.0","description":"Library for sending HTTP requests and dispatching Redux actions accordingly.","main":"dist/disfetch.min.js","files":["dist","src"],"scripts":{"build":"cross-env NODE_ENV=production webpack","dev":"cross-env NODE_ENV=development webpack --progress --colors --watch","test":"cross-env NODE_ENV=test mocha --compilers js:babel-core/register --recursive","clean":"rimraf dist","prepublish":"npm run clean && npm run test && npm run build"},"license":"MIT","dependencies":{"axios":"^0.16.1","lodash":"^4.17.4"},"devDependencies":{"babel-core":"^6.24.1","babel-eslint":"^7.2.3","babel-loader":"^7.0.0","babel-plugin-add-module-exports":"^0.2.1","babel-preset-es2015":"^6.24.1","babel-preset-stage-0":"^6.24.1","chai":"^4.0.0","cross-env":"^5.0.0","eslint":"^3.19.0","eslint-config-standard":"^10.2.1","eslint-loader":"^1.7.1","eslint-plugin-chai-friendly":"^0.3.6","mocha":"^3.4.2","moxios":"^0.4.0","redux":"^3.6.0","redux-mock-store":"^1.2.3","rimraf":"^2.6.1","sinon":"^2.3.2","standard":"^10.0.2","standard-loader":"^6.0.1","webpack":"^2.6.1"},"standard":{"parser":"babel-eslint"},"gitHead":"46a28fc3f014382480a4d32e57be05881cd3a31d","versions":[{"number":"0.1.0","date":"2017-06-01T09:37:53.320Z"},{"number":"0.2.0","date":"2017-06-20T15:17:01.077Z"}],"readme":"# disfetch\r\nDisfetch is a library for sending HTTP requests and dispatching Redux actions accordingly.\r\n\r\n## Purpose of this library\r\nA common task in most Redux-based applications is sending requests to a server and dispatching actions based on the response. This library should simplify that and help you write less verbose code.\r\n\r\n## Example usage\r\nYou can use this in the same way as you would use the [axios](https://github.com/mzabriskie/axios/) library.\r\n\r\n```js\r\n// config always has the lowest priority when considering URL, method and data properties\r\n\r\ndisfetch('/') // the first parameter is always the URL, regardless of the method\r\ndisfetch('/', { method: 'get' }) // the default method\r\n\r\ndisfetch.request('/') // an alias to calling the disfetch instance directly\r\ndisfetch.request('/', { method: 'get' })\r\n\r\ndisfetch.get('/')\r\ndisfetch.get('/', { headers: { /* ... */ } }) // you can also use delete, head and options methods\r\n\r\ndisfetch.post('/')\r\ndisfetch.post('/', { id: 1 })\r\ndisfetch.post('/', { id: 1 }, { headers: { /* ... */ } }) // you can also use put and patch methods\r\n```\r\n\r\nThe interesting stuff comes with using the `with` method.\r\n\r\n```js\r\ndisfetch.with(dispatch, 'APPROVE').get('/')\r\n```\r\n\r\nThis will send a request to the specified URL (`'/'`) and dispatch these actions:\r\n\r\n```js\r\n// before sending the request\r\n\r\n{\r\n  type: 'APPROVE_REQUEST',\r\n  payload: config, // parsed request fetch config (may not include axios default values)\r\n  meta: {\r\n    request: config // also the parsed request config (for convenience)\r\n  }\r\n}\r\n\r\n// if the response is successful\r\n\r\n{\r\n  type: 'APPROVE_SUCCESS',\r\n  payload: response.data,\r\n  meta: {\r\n    request, // request config (from response.request, made available by axios)\r\n    response,\r\n  }\r\n}\r\n\r\n// if the response is not successful\r\n\r\n{\r\n  type: 'APPROVE_FAILURE',\r\n  payload: response.data || response.statusText || response.status || error.message,\r\n  meta: {\r\n    request, // request config (from response.request, made available by axios)\r\n    response // may not be available\r\n  }\r\n}\r\n```\r\n\r\nYou can also pass a configuration object instead of a string.\r\n\r\n```js\r\ndisfetch.with(dispatch, {\r\n  requestAction: 'APPROVE_REQUEST', // mixed types are allowed\r\n  successAction: {\r\n    type: 'APPROVE_SUCCESS'\r\n  },\r\n  failureAction: (payload, { request, response }) => ({\r\n    type: 'APPROVE_FAILURE',\r\n    payload: payload,\r\n    meta: {\r\n      request,\r\n      response\r\n    }\r\n  })\r\n}).post('/', { value: 'waffle' }).then((response) => console.log(response))\r\n```\r\n\r\nThis will send a POST request to the speciifed URL with the supplied JSON body.\r\n\r\nAn action of `'APPROVE_REQUEST'` type will be dispatched before sending the request.\r\n\r\nIf it results in a successful response, the `successAction` is filled with response data and dispatched.\r\n\r\nIf it results in a failed response (or the request could not be sent at all), the `failureAction` function is called and the return value is dispatched.\r\n\r\n## Methods\r\n```js\r\n// these methods return a promise resolved with the response object (see response schema)\r\n\r\ndisfetch( url [, fetchConfig ] )\r\ndisfetch.request( url [, fetchConfig ] )\r\n\r\ndisfetch.delete( url [, fetchConfig ] )\r\ndisfetch.get( url [, fetchConfig ] )\r\ndisfetch.head( url [, fetchConfig ] )\r\ndisfetch.options( url [, fetchConfig ] )\r\n\r\ndisfetch.patch( url [, data [, fetchConfig ] ] )\r\ndisfetch.post( url [, data [, fetchConfig ] ] )\r\ndisfetch.put( url [, data [, fetchConfig ] ] )\r\n\r\n// these methods return a new disfetch instance with new configs set (merged recursively)\r\n\r\ndisfetch.create( [ dispatchConfig [, fetchConfig ] ] )\r\ndisfetch.with( [ dispatch, ] dispatchConfig )\r\n\r\n// these methods return the original disfetch instance, its configs are RESET beforehand\r\n// using these methods will mutate the instance, therefore their use is discouraged\r\n\r\ndisfetch.setDispatchConfig( [ dispatchConfig ] )\r\ndisfetch.setFetchConfig( [ fetchConfig ] )\r\n```\r\n\r\n## Response schema\r\nIt is the unmodified [axios response schema](https://github.com/mzabriskie/axios/#response-schema).\r\n\r\n## Dispatch configuration\r\nIt is merged with the default dispatch configuration of the instance (supplied one takes precedence). The object can be passed as an argument to the `with` or `create` method. Listed below are possible properties of the config. Defaults can also be found [here](https://github.com/wafflepie/disfetch/blob/master/src/defaults.js).\r\n\r\n#### `dispatch`\r\nThe dispatch function to dispatch the actions with. Can be passed as the first argument to the `with` method.\r\n\r\n#### `requestAction`, `successAction`, `failureAction`\r\nActions to be dispatched before sending a request or after receiving a response (a successful one or a failed one).\r\n* It takes precedence over `universalAction`.\r\n* If it's a string, it is wrapped in an object, where the `type` property is the value. Then it behaves as if it were an object.\r\n* If it's an object, the `payload` and `meta` properties are set depending on the event:\r\n  * Request event:\r\n    * `payload: request`\r\n    * `meta: { request }`\r\n  * Success event:\r\n    * `payload: response.data`\r\n    * `meta: { request, response }`\r\n  * Failure event:\r\n    * `payload: response.data || response.statusText || response.status || error.message`\r\n    * `meta: { request, response }`\r\n* If it's a function, it is called with `payload` and `meta` arguments (depending on the event). The return value is then dispatched.\r\n* If it's an array, every element is dispatched based on its type. This behaviour is recursive, arrays can be nested and of mixed types.\r\n* Note that if some edge use-case doesn't suit your needs, you can still use the `transformResponse` and `transformRequest` properties in the fetch config.\r\n* Any mix of types can be used.\r\n\r\n#### `universalAction`\r\nDefault action for all events (request, success and failure). Event actions override the dispatch of this action (event actions take precedence, but if e.g. only one event action is specified, universal action is still dispatched for other events).\r\n* If it's a string, it is suffixed and handled like the corresponding event action (see e.g. `requestAction`).\r\n* If it's an object, it is dispatched like the corresponding event action. The action type is **NOT** suffixed.\r\n* If it's a function, it is called like the corresponding event action and the return value is dispatched afterwards.\r\n* If it's an array, every element is handled like the corresponding event action based on its type. This behaviour is recursive, arrays can be nested and of mixed types.\r\n* Objects and function calls won't be dispatched on request (can be overriden, see e.g. `dispatchObjectOnRequest`).\r\n\r\n#### `requestSuffix`, `successSuffix`, `failureSuffix`\r\nSuffixes to use for action types of corresponding events, default values are `'_REQUEST'`, `'_SUCCESS'` and `'_FAILURE'`.\r\n\r\n#### `smartSuffixing` \r\nIf `universalAction` is a string and ends with any of the suffixes, they are removed and replaced with the correct one. The default value is `true` (this behaviour is enabled).\r\n\r\n#### `dispatchObjectOnRequest`, `dispatchFunctionCallOnRequest`\r\nIf `universalAction` is an object, it will also be dispatched on request event. If it's a function, it is called and the return value will also be dispatched on request event. The default value is `false`. If you pass an object or a function to `universalAction`, the default behaviour is to dispatch it only after the request is fully handled (as `finally` would).\r\n\r\n#### `args`\r\nArray of arguments to call the functions with (appended to the end, an alternative to `fn.bind`). The default value is an empty array. You can also provide a single non-array value. Note that the first two default arguments (payload, meta) **ARE** preserved.\r\n\r\n## Fetch configuration\r\nIt is merged with the default config of the instance (supplied one takes precedence). Passing it to any of the request methods will **NOT** mutate the instance or create a new one – the config will be used just for the request. Listed below are possible properties of the config.\r\n\r\n#### `jwt`\r\nWill add an `'Authorization: Bearer ' + jwt` header if an encoded JSON Web Token string is supplied.\r\n\r\nThe rest is passed straight to axios. See the [axios request config](https://github.com/mzabriskie/axios/#request-config).\r\n","created":"2017-06-01T09:37:53.320Z","modified":"2017-06-20T15:17:01.077Z","lastPublisher":{"name":"wafflepie","email":"vaclav.janc@gmail.com"},"owners":[{"name":"wafflepie","email":"vaclav.janc@gmail.com"}],"other":{"_attachments":{},"_id":"disfetch","_nodeVersion":"7.10.0","_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/disfetch-0.2.0.tgz_1497971820082_0.9633550338912755"},"_npmUser":{"name":"wafflepie","email":"vaclav.janc@gmail.com"},"_npmVersion":"5.0.0","_rev":"2-417d0c0d71d33a356cb0132c774411d2","author":{"name":"Václav Jančařík","email":"vaclav.janc@gmail.com"},"directories":{},"dist-tags":{"latest":"0.2.0"},"dist":{"integrity":"sha512-Gx1LBbOVXWxHHc9fCkVOv5c2uL6yqpniQQ3l93FIOgF7QU0WAc4fEVaOUBFzG3/dpIE8kF9dV0m0gPw73Ft5dQ==","shasum":"d1a064b00445281250736bf96c182da87be3fd6a","tarball":"https://registry.npmjs.org/disfetch/-/disfetch-0.2.0.tgz"},"maintainers":[{"name":"wafflepie","email":"vaclav.janc@gmail.com"}],"readmeFilename":"README.md","time":{"modified":"2017-06-20T15:17:01.077Z","created":"2017-06-01T09:37:53.320Z","0.1.0":"2017-06-01T09:37:53.320Z","0.2.0":"2017-06-20T15:17:01.077Z"}}}