{"name":"multiagent","description":"Simple HTTP client with failover functionality for node.js and browsers","version":"2.1.0","scripts":{"test":"gulp test","prepublish":"gulp build"},"keywords":["http","ajax","browser","request","agent","superagent","failover","service","microservice","discovery","consul","resilient"],"license":"MIT","main":"lib/index.js","browser":"lib/browser.js","repository":"https://github.com/ahelmberger/multiagent","dependencies":{"array-shuffle":"^1.0.1","superagent":"^2.0.0"},"devDependencies":{"babel-core":"^6.10.4","babel-eslint":"^6.1.2","babel-loader":"^6.2.4","babel-preset-es2015":"^6.9.0","babelify":"^7.3.0","browserify":"^13.0.1","cors":"^2.7.1","expect.js":"^0.3.1","express":"^4.14.0","gulp":"^3.9.1","gulp-babel":"^6.1.2","gulp-eslint":"^3.0.1","gulp-mocha":"^2.2.0","gulp-rename":"^1.2.2","gulp-uglify":"^1.5.4","karma":"^1.1.1","karma-browserify":"^5.0.5","karma-chrome-launcher":"^1.0.1","karma-mocha":"^1.1.1","mocha":"^2.5.3","rimraf":"^2.5.3","run-sequence":"^1.2.2","watchify":"^3.7.0","webpack":"^1.13.1","webpack-stream":"^3.2.0"},"gitHead":"332e9eb4cce162d23b598bba233a661295992df7","homepage":"https://github.com/ahelmberger/multiagent#readme","versions":[{"number":"1.0.0","date":"2016-03-12T20:40:33.154Z"},{"number":"1.0.1","date":"2016-03-12T23:36:56.662Z"},{"number":"1.0.2","date":"2016-03-13T01:24:55.545Z"},{"number":"1.1.0","date":"2016-03-17T21:37:23.891Z"},{"number":"1.1.1","date":"2016-03-22T21:51:13.972Z"},{"number":"1.2.0","date":"2016-03-22T22:36:45.747Z"},{"number":"2.0.0","date":"2016-03-22T23:01:21.140Z"},{"number":"2.0.1","date":"2016-03-22T23:13:33.318Z"},{"number":"2.1.0","date":"2016-07-11T21:18:24.731Z"}],"readme":"# multiagent\r\n\r\nSimple HTTP client with failover functionality for node.js and browsers\r\n\r\nIt supports simple fallback addresses as well as dynamic service discovery using [Consul](https://www.consul.io/).\r\n\r\nMultiagent uses [superagent](http://visionmedia.github.io/superagent/) under the covers and exposes\r\nmost of its API as well as an additional promise interface (if native promises are available).\r\n\r\nAll browsers with ECMAScript 5 support should work.\r\n\r\n## Installation\r\n\r\nnode.js, browserify, webpack:\r\n\r\n```sh\r\nnpm install --save multiagent\r\n```\r\n\r\nas a global script in the browser:\r\n\r\n```html\r\n<script src=\"node_modules/multiagent/lib/browser.min.js\"></script>\r\n```\r\n\r\nfrom a CDN:\r\n\r\n```html\r\n<script src=\"https://npmcdn.com/multiagent/lib/browser.min.js\"></script>\r\n```\r\n\r\nIn case you load multiagent with a script reference into the browser,\r\nit will create the global variable `multiagent`.\r\n\r\n## Examples\r\n\r\n### Simple HTTP requests\r\n\r\nMultiagent can be used as a simple HTTP client, pretty much as a drop-in\r\nreplacement of [superagent](http://visionmedia.github.io/superagent/):\r\n\r\n```js\r\nconst agent = require('multiagent');\r\n\r\n// create a request:\r\nconst req = agent.request('GET', 'http://domain.com');\r\n\r\n// or use a shorthand (there's also: 'head', 'post', 'put', 'delete'/'del')\r\nconst req = agent.get('http://domain.com');\r\n\r\n// execute a request, providing a callback:\r\nreq.end((err, res) => console.log(err || res.body));\r\n\r\n// or instead, use the promise interface:\r\nconst promise = req.promise();\r\npromise.then(res => console.log(res.body), err => console.log(err));\r\n\r\n// you can also simply just call 'then' (or 'catch') on the request:\r\nreq.then(res => console.log(res.body), err => console.log(err));\r\n```\r\n\r\n### HTTP client with failover\r\n\r\nIf you have your service running on multiple endpoints, you can provide a list\r\nof hard-coded server URLs and take advantage of multiagent's failover mechanism:\r\n\r\n```js\r\nconst agent = require('multiagent');\r\n\r\n// create a client:\r\nconst client = agent.client({\r\n  servers: ['http://sub1.abc.com', 'http://sub2.abc.com', 'http://sub3.abc.com']\r\n});\r\n\r\n// then do stuff:\r\nclient\r\n  .get('/endpoint') // use just the path without host!\r\n  .timeout(500) // used per individual call!\r\n  .end((err, res) => console.log(err || res.body));\r\n```\r\n\r\n### HTTP client with discovery using Consul\r\n\r\nInstead of hard-coding your server URLs you can use a Consul server\r\nor cluster to dynamically resolve the base URLs for your service calls:\r\n\r\n```js\r\nconst agent = require('multiagent');\r\n\r\n// create a client:\r\nconst client = agent.client({\r\n  discovery: 'consul', // only possible value at the moment, more could be added in the future\r\n  discoveryServers: ['http://consul1.abc.com', 'http://consul2.abc.com', 'http://consul3.abc.com'],\r\n  serviceName: 'my-service'\r\n});\r\n\r\n// then do stuff:\r\nclient\r\n  .get('/endpoint') // use just the path without host!\r\n  .timeout(500) // used per individual service call!\r\n  .end((err, res) => console.log(err || res.body));\r\n```\r\n\r\n### Getting the server URLs without calling an endpoint\r\n\r\nIf you're just interested in the service URLs e.g. from Consul without actually calling any\r\nservice endpoint, you can use the `resolveServers` function provided by the client instance:\r\n\r\n```js\r\nconst agent = require('multiagent');\r\n\r\n// create a client:\r\nconst client = agent.client({\r\n  discovery: 'consul',\r\n  discoveryServers: ['http://consul1.abc.com', 'http://consul2.abc.com', 'http://consul3.abc.com'],\r\n  serviceName: 'my-service'\r\n});\r\n\r\n// get the list of servers providing a callback:\r\nclient.resolveServers((err, servers) => console.log(err || servers));\r\n\r\n// or use the promise interface:\r\nclient.resolveServers().then(servers => console.log(servers));\r\n```\r\n\r\n## Advanced client options\r\n\r\nFor the client using simple failover you can pass the following additional options:\r\n\r\n* __strategy__: string, (sequentially|randomly|simultaneously), default: 'sequentially'\r\n* __shouldFailover__: function, default: `(err, res) => err || res.status >= 400`\r\n\r\nFor the client using Consul you can pass the following additional options:\r\n\r\n* __serviceProtocol__: string, (http|https), default: 'http'\r\n* __serviceStrategy__: string, (sequentially|randomly|simultaneously), default: 'sequentially'\r\n* __discoveryTimeout__: number, in milliseconds, default: 2000\r\n* __discoveryStrategy__: string, (sequentially|randomly|simultaneously), default: 'simultaneously'\r\n* __refreshAfter__: number, in milliseconds, default: 60000\r\n* __shouldFailover__: function, default: `(err, res) => err || res.status >= 400`\r\n* __createConsulRequestPath__: function, default: ``serviceName => `/v1/health/service/${encodeURIComponent(serviceName)}?passing=true` ``,\r\n* __createServerListFromConsulResponse__: function, default: ``(body, serviceProtocol) => body.map(x => `${serviceProtocol}://${x.Service.Address}:${x.Service.Port}`)``\r\n\r\n## Finetuning failover options on a per request basis\r\n\r\nWhen you create a client with failover using `agent.client({ /* options */ })` you can override\r\nthe failover strategy as well as the failover criteria on a per request basis. This is sometimes useful\r\nwhen e.g. in a RESTful environment a response with status code 404 (not found) is a perfectly valid\r\nresult and should not lead to any failover:\r\n\r\n~~~js\r\n// create a client with default options for all requests issued using this client instance:\r\nconst client = agent.client({\r\n  servers: ['http://sub1.abc.com', 'http://sub2.abc.com', 'http://sub3.abc.com'],\r\n  strategy: 'simultaneously',\r\n  shouldFailover: (err, res) => err || res.status >= 400\r\n});\r\n\r\n// this will execute the requests sequentially and NOT failover on a 404 status response,\r\n// thus overriding the options 'strategy' and 'shouldFailover' set as default on the client:\r\nclient\r\n  .get('/endpoint')\r\n  .failover({ strategy: 'sequentially' })\r\n  .failover({ shouldFailover: (err, res) => err || (res.status >= 400 && res.status !== 404) }) \r\n~~~\r\n\r\n## Supported API\r\n\r\nThe following functions from [superagent](http://visionmedia.github.io/superagent/) are supported:\r\n\r\n### On the client\r\n\r\n* head\r\n* get\r\n* post\r\n* put\r\n* delete\r\n* del\r\n\r\nAdditionally:\r\n\r\n* request\r\n* resolveServers\r\n\r\n### On the request\r\n\r\n* set\r\n* query\r\n* send\r\n* type\r\n* accept\r\n* timeout\r\n* auth\r\n* redirects\r\n* attach\r\n* field\r\n* withCredentials\r\n* abort\r\n* end\r\n\r\nAdditionally:\r\n\r\n* failover\r\n* promise\r\n* then\r\n* catch\r\n\r\n## License\r\n\r\nMIT\r\n","created":"2016-03-12T20:40:33.154Z","modified":"2016-07-11T21:18:24.731Z","lastPublisher":{"name":"ahelmberger","email":"public@ahelmberger.de"},"owners":[{"name":"ahelmberger","email":"public@ahelmberger.de"}],"other":{"_attachments":{},"_from":".","_id":"multiagent","_nodeVersion":"4.4.6","_npmOperationalInternal":{"host":"packages-12-west.internal.npmjs.com","tmp":"tmp/multiagent-2.1.0.tgz_1468271902116_0.7274800222367048"},"_npmUser":{"name":"ahelmberger","email":"public@ahelmberger.de"},"_npmVersion":"2.15.5","_rev":"1-97496ddebb3ef9972cda28393c1243b3","_shasum":"35f067925f0b4937d8575f74fa8fdf4a3cd5a198","author":{"name":"Andreas Helmberger","email":"public@ahelmberger.de"},"bugs":{"url":"https://github.com/ahelmberger/multiagent/issues"},"directories":{},"dist-tags":{"latest":"2.1.0"},"dist":{"shasum":"35f067925f0b4937d8575f74fa8fdf4a3cd5a198","tarball":"http://registry.npmjs.org/multiagent/-/multiagent-2.1.0.tgz"},"maintainers":[{"name":"ahelmberger","email":"public@ahelmberger.de"}],"readmeFilename":"README.md","time":{"modified":"2016-07-11T21:18:24.731Z","created":"2016-03-12T20:40:33.154Z","1.0.0":"2016-03-12T20:40:33.154Z","1.0.1":"2016-03-12T23:36:56.662Z","1.0.2":"2016-03-13T01:24:55.545Z","1.1.0":"2016-03-17T21:37:23.891Z","1.1.1":"2016-03-22T21:51:13.972Z","1.2.0":"2016-03-22T22:36:45.747Z","2.0.0":"2016-03-22T23:01:21.140Z","2.0.1":"2016-03-22T23:13:33.318Z","2.1.0":"2016-07-11T21:18:24.731Z"}}}