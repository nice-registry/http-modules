{"name":"simple-fake-server","version":"0.3.2","description":"A small, simple http server for mocking and asserting http calls.  \r This server was developed mainly to isolate the client side code during automation (selenium) tests.","main":"./dist/index.js","license":"MIT","dependencies":{"deep-equal":"1.0.1","is-subset":"0.1.1","koa":"1.1.2","koa-body":"1.4.0","koa-cors":"0.0.16","lodash":"4.17.4"},"devDependencies":{"babel-cli":"6.23.0","babel-jest":"18.0.0","babel-polyfill":"6.22.0","babel-preset-stage-3":"6.22.0","jest":"18.1.0","node-fetch":"1.6.3"},"repository":"https://github.com/Soluto/simple-fake-server","scripts":{"build":"babel src --presets stage-3 --out-dir dist","prepublish":"npm run build","test":"npm run build && jest"},"gitHead":"712e6591155af330ff43e6cee4d22c32437875c3","homepage":"https://github.com/Soluto/simple-fake-server#readme","versions":[{"number":"0.0.1","date":"2016-02-25T13:52:32.005Z"},{"number":"0.0.2","date":"2016-02-25T13:57:32.964Z"},{"number":"0.0.3","date":"2017-02-02T08:44:28.779Z"},{"number":"0.0.4","date":"2017-02-02T08:45:57.055Z"},{"number":"0.0.5","date":"2017-02-02T08:47:03.228Z"},{"number":"0.1.0","date":"2017-02-06T13:29:50.045Z"},{"number":"0.1.1","date":"2017-02-06T13:35:33.352Z"},{"number":"0.1.2","date":"2017-02-07T13:40:28.857Z"},{"number":"0.2.0","date":"2017-02-14T11:52:26.119Z"},{"number":"0.3.0","date":"2017-02-21T17:14:07.771Z"},{"number":"0.3.1","date":"2017-02-22T13:17:52.392Z"},{"number":"0.3.2","date":"2017-02-23T08:57:57.114Z"}],"readme":"# simple-fake-server.js\r\nA small, simple http server for mocking and asserting http calls.  \r\nThis server was developed mainly to isolate the client side code during automation (selenium) tests.  \r\n\r\n## Installation\r\n`npm install simple-fake-server --save-dev`\r\n\r\n## Usage Example\r\n```js\r\nconst chai = require('chai');\r\nchai.should();\r\nconst fakeServer = require('simple-fake-server').fakeServer;\r\nconst http = require('simple-fake-server').httpFakeCalls;\r\n\r\ndescribe('Home Page', () => {\r\n    before(() => {\r\n        fakeServer.start(1234); // the fake server now listens on http://localhost:1234\r\n    });\r\n\r\n    it('Does something', () => {\r\n        var route = http.get().to('/your/api').willReturn({ message: \"hello world\" });\r\n\r\n        return fetch('http://localhost:1234/your/api', { method: 'GET' })\r\n            .then(res => res.json())\r\n            .then(j => {\r\n                j.message.should.eqaul(\"hello world\")\r\n            })\r\n            .then(() => {\r\n                route.call.hasBeenMade().should.equal(true);\r\n            });\r\n    });\r\n\r\n    after(() => {\r\n        fakeServer.stop(); // stop listening\r\n    });\r\n});\r\n```\r\n\r\n## Defining Routes\r\n\r\n```js\r\nlet verbSpec = http.get();  // or http.post() or http.put() - is used to match the request's verb.\r\nlet pathSpec = verbSpec.to(pathRegex); // is used to match the request url.  \r\npathSpec.willReturn(response); // sets the response that the fake server will return for requests matching the path spec.  \r\npathSpec.willSucceed(); // returns status code 200 with no body for requests matching the path spec.  \r\npathSepc.willFail(errorStatusCode); // returns an error response with the provided status code.\r\n```\r\n\r\nThose methods can be chained:\r\n```js\r\nhttp.get().to('/some/path').willSucceed();\r\n```\r\n\r\n## Testing If Route Was Called\r\n\r\n`willReturn()`, `willSucceed()` and `willFail()` return a route call tester object which will allow you to check if calls to that route have been made:\r\n\r\n```js\r\nlet route = http.get().to('/some/path/[a-zA-Z]+$').willSucceed();\r\nroute.call.hasBeenMade(); // returns true/false, based on weather this route was called since the server was started.\r\n```\r\n \r\nYou can use `withPath(specificPath)` to make the test specific to a certain path, rather than the whole path regex:\r\n```js\r\nroute.call.withPath('/some/path/abc').hasBeenMade();\r\n```\r\n\r\n## Body Restrictions\r\n\r\n### When Defining a Route\r\n\r\nWhen you define a route, you may set a body restriction. Requests with body that does not match the restriction will not be matched.\r\n\r\n`withBodyThatMatches(regex)` will match only requests with bodies that match the given regex:\r\n\r\n```js\r\nconst route1 = httpFakeCalls.post().to('/some/path').withBodyThatMatches('[a-zA-Z]+$').willSucceed();\r\nconst route2 = httpFakeCalls.post().to('/some/path').withBodyThatMatches('[0-9]+$').willSucceed();\r\n\r\n// posting a request to '/some/path' with the body 'abc'...\r\n\r\nroute1.call.hasBeenMade().should.equal(true);\r\nroute2.call.hasBeenMade().should.equal(false);\r\n```\r\n\r\n`withBodyThatContains(minimalObject)` will match only requests with content-type header set to 'application/json' and bodies that are *supersets* of the given minimal object:\r\n\r\n```js\r\nconst route1 = httpFakeCalls.post().to('/some/path').withBodyThatContains({ a: 1, b: 2 }).willSucceed();\r\nconst route2 = httpFakeCalls.post().to('/some/path').withBodyThatContains({ a: 1, b: 2, c: 3 }).willSucceed();\r\nconst route3 = httpFakeCalls.post().to('/some/path').withBodyThatContains({ a: 1, b: 2, c: 3, d: 4 }).willSucceed();\r\n\r\n// posting a request to '/some/path' with content-type header set to 'application/json' and the body JSON.stringify({ b: 2, a: 1, c: 3 })...\r\n\r\nroute1.call.hasBeenMade().should.equal(true);\r\nroute2.call.hasBeenMade().should.equal(true);\r\nroute3.call.hasBeenMade().should.equal(false);\r\n```\r\n\r\n`withBody(object)` will match only requests with content-type header set to 'application/json' and bodies that are objects that *deeply equal* the given object:\r\n\r\n```js\r\nconst route1 = httpFakeCalls.post().to('/some/path').withBody({ a: 1, b: 2 }).willSucceed();\r\nconst route2 = httpFakeCalls.post().to('/some/path').withBody({ a: 1, b: 2, c: 3 }).willSucceed();\r\nconst route3 = httpFakeCalls.post().to('/some/path').withBody({ a: 1, b: 2, c: 3, d: 4 }).willSucceed();\r\n\r\n// posting a request to '/some/path' with content-type header set to 'application/json' and the body JSON.stringify({ b: 2, a: 1, c: 3 })...\r\n\r\nroute1.call.hasBeenMade().should.equal(false);\r\nroute2.call.hasBeenMade().should.equal(true);\r\nroute3.call.hasBeenMade().should.equal(false);\r\n```\r\n\r\n### When Testing If Route Was Called\r\n\r\nAfter the route is defined, you can test if there were any calls made to the route with a *specific* body.\r\n\r\n`withBodyText(str);` will restrict `hasBeenMade()` to return true only if there were any requests to the route with a body that equals the *specific* string `str`.\r\nIt can be called only if route was defined with no body restriction or if the route was defined with a regex body restriction (using `withBodyThatMatches(regex)`) and `str` matches the regex.\r\n\r\n```js\r\nconst route1 = httpFakeCalls.post().to('/some/path').willSucceed();\r\nconst route2 = httpFakeCalls.post().to('/some/path').withBodyThatMatches('[a-zA-Z]+$').willSucceed();\r\n\r\n// posting a request to '/some/path' with the body 'abc'...\r\n\r\nroute1.call.withBodyText('xyz').hasBeenMade().should.equal(false);\r\nroute2.call.withBodyText('xyz').hasBeenMade().should.equal(false);\r\nroute1.call.withBodyText('abc').hasBeenMade().should.equal(true);\r\nroute2.call.withBodyText('abc').hasBeenMade().should.equal(true);\r\n\r\nroute2.call.withBodyText('123'); // throws exception - specific string does not match the regex\r\n```\r\n\r\n`withSpecificBody(obj);` will restrict `hasBeenMade()` to return true only if there were any requests to the route with content-type header set to 'application/json' the body deeply equals the *specific* object `obj`.\r\nIt can be called only if route was defined with no body restriction or if the route was defined with a minimal object body restriction (using `withBodyThatContains(minimalObject)`) and `obj` is a superset of the minimal object.\r\n\r\n```js\r\nconst route1 = httpFakeCalls.post().to('/some/path').willSucceed();\r\nconst route2 = httpFakeCalls.post().to('/some/path').withBodyThatContains({ a: 1, b: 2 }).willSucceed();\r\n\r\n// posting a request to '/some/path' with content-type header set to 'application/json' and body JSON.stringify({ a: 1, b: 2, c: 3 })...\r\n\r\nroute1.call.withSpecificBody({ a: 1, b: 2 }).hasBeenMade().should.equal(false);\r\nroute2.call.withSpecificBody({ a: 1, b: 2 }).hasBeenMade().should.equal(false);\r\nroute1.call.withSpecificBody({ c: 3, b: 2, a: 1 }).hasBeenMade().should.equal(true);\r\nroute2.call.withSpecificBody({ c: 3, b: 2, a: 1 }).hasBeenMade().should.equal(true);\r\n\r\nroute2.call.withSpecificBody({ a: 1, c: 3 }); // throws exception - specific body is not a superset of the minimal object\r\n```\r\n\r\nMore examples can be found in this project's tests.","created":"2016-02-25T13:52:32.005Z","modified":"2017-02-23T08:57:57.114Z","lastPublisher":{"name":"npmsoluto","email":"it@soluto.com"},"owners":[{"name":"npmsoluto","email":"it@soluto.com"}],"other":{"_attachments":{},"_from":".","_id":"simple-fake-server","_nodeVersion":"6.9.0","_npmOperationalInternal":{"host":"packages-18-east.internal.npmjs.com","tmp":"tmp/simple-fake-server-0.3.2.tgz_1487840276504_0.05278026359155774"},"_npmUser":{"name":"npmsoluto","email":"it@soluto.com"},"_npmVersion":"3.10.8","_rev":"11-43881a98f48d693ed6c2f0ca466372b2","_shasum":"9121432c9c03c03b6b08f74a07f2bda95a39d3d7","author":{"name":"soluto"},"bugs":{"url":"https://github.com/Soluto/simple-fake-server/issues"},"directories":{},"dist-tags":{"latest":"0.3.2"},"dist":{"shasum":"9121432c9c03c03b6b08f74a07f2bda95a39d3d7","tarball":"https://registry.npmjs.org/simple-fake-server/-/simple-fake-server-0.3.2.tgz"},"maintainers":[{"name":"npmsoluto","email":"it@soluto.com"}],"readmeFilename":"readme.md","time":{"modified":"2017-02-23T08:57:57.114Z","created":"2016-02-25T13:52:32.005Z","0.0.1":"2016-02-25T13:52:32.005Z","0.0.2":"2016-02-25T13:57:32.964Z","0.0.3":"2017-02-02T08:44:28.779Z","0.0.4":"2017-02-02T08:45:57.055Z","0.0.5":"2017-02-02T08:47:03.228Z","0.1.0":"2017-02-06T13:29:50.045Z","0.1.1":"2017-02-06T13:35:33.352Z","0.1.2":"2017-02-07T13:40:28.857Z","0.2.0":"2017-02-14T11:52:26.119Z","0.3.0":"2017-02-21T17:14:07.771Z","0.3.1":"2017-02-22T13:17:52.392Z","0.3.2":"2017-02-23T08:57:57.114Z"}}}