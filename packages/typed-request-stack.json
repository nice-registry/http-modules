{"name":"typed-request-stack","version":"2.0.0","description":"Middleware stack runner for typed HTTP requests","keywords":[],"repository":"https://github.com/uber/typed-request-stack","main":"index","homepage":"https://github.com/uber/typed-request-stack","dependencies":{},"devDependencies":{"coveralls":"^2.10.0","istanbul":"^0.3.5","jshint":"^2.6.0","opn":"^1.0.1","pre-commit":"0.0.9","tap-spec":"^2.1.1","tape":"^3.4.0","uber-licence":"^1.2.0"},"licenses":[{"type":"MIT","url":"http://github.com/uber/typed-request-stack/raw/master/LICENSE"}],"scripts":{"test":"npm run jshint -s && npm run cover -s","add-licence":"uber-licence","check-cover":"istanbul check-coverage --branches=100 --lines=100 --functions=100","check-licence":"uber-licence --dry","cover":"istanbul cover --report html --print detail -- test/index.js && npm run check-cover -s","jshint":"jshint --verbose ./","travis":"npm run cover -s && istanbul report lcov && ((cat coverage/lcov.info | coveralls) || exit 0)","unit-test":"node test/index.js | tap-spec","view-cover":"opn ./coverage/index.html"},"engine":{"node":">= 0.10.x"},"pre-commit":["check-licence","test"],"pre-commit.silent":true,"gitHead":"4f40500caf6b6257838a754efd5d9fad8f06915e","versions":[{"number":"2.0.0","date":"2015-04-15T01:36:25.279Z"}],"readme":"# typed-request-stack\n\n<!--\n    [![build status][build-png]][build]\n    [![Coverage Status][cover-png]][cover]\n    [![Davis Dependency status][dep-png]][dep]\n-->\n\n<!-- [![NPM][npm-png]][npm] -->\n\nMiddleware stack runner for typed HTTP requests\n\n## Example\n\n```js\nvar stack = require(\"typed-request-stack\");\n\nvar middleware = require('./my-service-middleware');\nvar requestValidation = require('./request-validation');\nvar responseValidtion = require('./response-validation');\n\n// -> Exports function (typedRequest, opts, handle)\nmodule.exports = stack([\n    // User-implemented role-based security middleware,\n    middleware.secure(['Admin']),\n\n    // Validation for this endpoint\n    middleware.validate(requestValidation, responseValidation)\n], dummyEndpoint)\n\n// The main body of the endpoint implemetation\nfunction dummyEndpoint(typedRequest, opts, callback) {\n    callback(null, {\n        statusCode: 200,\n        body: \"Hello world\"\n    });\n}\n```\n\n## Docs\n\n### `var endpoint = stack([/*middleware*/], endpointHandler)`\n\n```ocaml\ntyped-request-stack := (\n  stack: Array<TypedHandler>,\n  endpoint?: TypedRequestHandler\n) => (\n  typedRequest: TypedRequest,\n  opts: Object,\n  callback?: (err?: error, value: Any) => void \n) => void\n\n```\n\n`TypedRequestStack` allows you to to compose a collection of \"middleware\"\nfunctions and apply them in order. The stack is descended from the first\nhandler for the request, and then in reverse order for the response.\n\n```\n                 Start                               End\n                   |                                  ^\n                   V                                  |\n        +----------------------+            +----------------------+\n    A - |    Handle request    |     +--->  |    Handle response   |\n        +----------------------+     |      +----------------------+\n                   |                 |                 ^\n                   V                 |                 |\n  middleware A calls handle.request  |  middleware B calls handle.reponse\n                   |                 |                 |\n                   v                 |                 |\n        +----------------------+     |      +----------------------+\n    B - |    Handle request    |  ?--+      |    Handle response   |\n        +----------------------+            +----------------------+\n                   | middleware B could abort         ^\n                   | early (if there was an           |\n                   | error for example) by            |   \n                   | calling handle.response          |\n                   | inside handle request            |\n                   |                                  |\n                   +------+                    +------+ Endpoint calls\n                          |                    |        callback\n                          V                    | \n                         +----------------------+\n                         |       Endpoint       |\n                         +----------------------+\n```\n\nThe callback passed into the function returned by `typed-request-stack` will\nreceive the last result `(err, value)` in the response phase.\n\nWhen a handleResponse function aborts the request by calling handle.response,\nthe parent response handler is first to receive the value. This behaves as if\nthe parent response function is a callback passed into the request handler.\n\n### Defining middleware `TypedHandler`\n\n```\ntype TypedHandler : {\n    handleRequest: TypedRequestHandler,\n    handleResponse: TypedResponseHandler\n}\n```\n\nMiddleware in the stack should implement `handleRequest` or `handleResponse`.\nThere is no obligation to implement both, but one of these functions must be\nimplemented. If the next middleware does not implement a handler for the\nrequest or response phase, it will simply be skipped, and the next handler\nused.\n\n### Example: Implementing middleware\n\n```js\n'use strict';\n\nmodule.exports = Logger;\n\nfunction Logger(logger) {\n    if (!(this instanceof Logger)) {\n        return new Logger(logger);\n    }\n\n    // We can configure our middleware in the constructor\n    this.logger = logger || console.log.bind(console);\n}\n\nLogger.prototype.handleRequest = handleRequest;\n\nLogger.prototpye.handleResponse = handleResponse;\n\nfunction handleRequest(typedRequest, opts, handle) {\n    this.logger.log(typedRequest);\n\n    // Handle the next request in the middleware stack\n    handle.request(opts);\n}\n\nfunction handleResponse(err, value, handle) {\n    if (err) {\n        this.logger.error(err);\n    } else {\n        this.logger.log(value);\n    }\n\n    // Continue back up the response chain\n    handle.response(err, value);\n}\n```\n\n### `function typedRequestHandler(typedRequest, opts, handle)`\n\n```ocaml\ntype TypedRequestHandler : (\n  typedRequest: TypedRequest,\n  opts: Object,\n  handle: Handle\n) => void\n\ntype Handle : {\n  request: (opts: Object) => void,\n  response: (err?: Error, value: Any) => void,\n  sharedState?: Any\n}\n```\n\nWhen calling `handle.request(opts)` - the opts passed in here is passed on to\nthe next request handler (below the current) in the stack.\n\nIf a typed request handler wishes to abort and start returning a value through\nthe response phase, it can do so by calling `handle.reponse(opts)`\n\nA typed request handler must call either `handle.request` or `handle.reponse` at\nsome point. Precisely one of these functions must be called exactly one time.\n\n### `function typedResponseHandler(err, value, handle)`\n\n```ocaml\ntype TypedResponseHandler : (\n  err?: Error,\n  value: Any,\n  handle: Handle\n)\n```\n\nWhen calling `handle.reponse(err)` or `handle.response(null, value)`, the\nnext response handler (above the current) in the stack will receive these\nvalues.\n\nEventually, after fully ascending the stack, the final error or value will be\npassed into a callback function supplied by the stack caller.\n\nA `TypedResponseHandler` must call `handle.response` exactly once, and must\nnever call `handle.request`.\n\n### `handle.sharedState`\n\nWhen request and response handlers are paired together for a single unit of\nmiddleware, they often wish to share some state per request. It's important\nto stress that the properties on the middleware instance itself are global to\nall requests, and so you *must not use `this` to store per-request state*.\n\n`handle.sharedState` provides a mechanism for sharing state for this middleware\nbetween the request and response handler. `handle.sharedState` may be set to\nanything inside `handleRequest`, and it will be available on the `handle`\ninstance inside `handleResponse`.\n\n#### Example: computing and sharing state for each request\n\n```js\nfunction RequestTimer(logger) {\n    this.logger = logger || console.log.bind(console);  \n}\n\nRequestTimer.prototype.handleRequest = handleTimedRequest;\nRequestTimer.prototype.handleResponse = handleTimedResponse;\n\nfunction handleTimedRequest(typedRequest, opts, handle) {\n    // Write the shared state by setting handle.sharedState\n    handle.sharedState = {\n        startTime: Date.now()\n    };\n\n    handle.request(opts);\n}\n\nfunction handleTimedResponse(err, value, handle) {\n    // Read the shared state from `handle`, set in handleTimedRequest\n    var sharedState = handle.sharedState;\n    var requestTime = Date.now() - sharedState.startTime;\n\n    this.logger.log('Request took ' + requestTime + 'ms');\n\n    handle.response(err, value);\n}\n```\n\n## Motivation\n\nThe implementation of an HTTP endpoint should be\n\n  - Debuggable\n  - Efficient\n  - Modular\n  - Safe\n\n### Debuggable\n\n`typed-request-stack` aids with debugging by unwraping the closures that would\notherwise be relied on to implement middleware stacks. This allows us to\ninspect, or even modify the stack of handlers that will run for a given\nendpoint.\n\nInspecting `handle._stack` will allow you to see which middleware has been\napplied to the stack, and this can be inspected at any stage.\n\nFurthermore, in the case of a core/heap dump, the configuration of your server's\nendpoints becomes easier to debug. You can look for the instances of your\nendpoints on the heap and inspect them. You can look for instances of\n`TypedRequestHandle` to see all of the in-flight requests at the time of a\ncrash, and know exactly which endpoint stack the request was executing through.\n\nYou can also rely on the `handle._handlerIndex` to derive which specific\nhandler was executing at that point in time, and `handle._typedRequest` to\ninspect the incoming request.\n\n\n### Efficient\n\nWhen relying on closure based stacks, you will often be creating closures at\nruntime for each request you serve.\n\nThis middleware stack approach completely removes the need to rely on closures,\nwhich means no more on-the-fly function generation. Using constructors also\nprovides minor V8 efficiencies through the use of hidden classes.\n\n\n### Modular\n\nThe middleware pattern allows us to create shared units of funtionality and\napply them easily. By implementing these shared units with the same consistent\ninterface, we can easily combine them together in a stack.\n\nThis further promotes indepedent testing of these units with full coverage,\nreducing likely copy/paste errors and errors caused by not understanding a new\ninterface.\n\n\n### Safe\n\nOne of the biggest problems with chaining modules together is understanding\nwhen a module will call the callback. There is always the question of whether\nthe module calls the callback more than once, what the impact would be and how\nwe would debug it if it did happen.\n\n`typed-request-stack` ensures that the callback is called only once and that\nmiddleware act in-order. Out-of-order middleware could easily corrupt state or\nbehave in ways that are hard to reason about. The `handle` passed into each\nfunction is wrapped with a `SafeHandle` type to ensure the correct calling\nconventions are met.\n\n## Installation\n\n`npm install typed-request-stack`\n\n## Tests\n\n`npm test`\n\n## Contributors\n\n - Matt Esch\n\n## MIT Licensed\n\n  [build-png]: https://secure.travis-ci.org/uber/typed-request-stack.png\n  [build]: https://travis-ci.org/uber/typed-request-stack\n  [cover-png]: https://coveralls.io/repos/uber/typed-request-stack/badge.png\n  [cover]: https://coveralls.io/r/uber/typed-request-stack\n  [dep-png]: https://david-dm.org/uber/typed-request-stack.png\n  [dep]: https://david-dm.org/uber/typed-request-stack\n  [test-png]: https://ci.testling.com/uber/typed-request-stack.png\n  [tes]: https://ci.testling.com/uber/typed-request-stack\n  [npm-png]: https://nodei.co/npm/typed-request-stack.png?stars&downloads\n  [npm]: https://nodei.co/npm/typed-request-stack\n","starsCount":1,"created":"2015-04-15T01:36:25.279Z","modified":"2015-04-15T01:37:42.555Z","lastPublisher":{"name":"mattesch","email":"matt@mattesch.info"},"owners":[{"name":"mattesch","email":"matt@mattesch.info"},{"name":"uber","email":"opensource@uber.com"}],"other":{"_attachments":{},"_from":".","_id":"typed-request-stack","_nodeVersion":"1.6.4","_npmUser":{"name":"mattesch","email":"matt@mattesch.info"},"_npmVersion":"2.7.5","_rev":"1-af0bec9e84e5e25783e54db0228b66bd","_shasum":"365aca2cea10c3b81b303e2081dd9324a0139d75","author":{"name":"Matt Esch","email":"mattesch@uber.com"},"bugs":{"url":"https://github.com/uber/typed-request-stack/issues","email":"mattesch@uber.com"},"contributors":[{"name":"Matt Esch"}],"directories":{},"dist-tags":{"latest":"2.0.0"},"dist":{"shasum":"365aca2cea10c3b81b303e2081dd9324a0139d75","tarball":"http://registry.npmjs.org/typed-request-stack/-/typed-request-stack-2.0.0.tgz"},"maintainers":[{"name":"mattesch","email":"matt@mattesch.info"},{"name":"uber","email":"opensource@uber.com"}],"readmeFilename":"README.md","time":{"modified":"2015-04-15T01:37:42.555Z","created":"2015-04-15T01:36:25.279Z","2.0.0":"2015-04-15T01:36:25.279Z"},"users":{"wenbing":true}}}